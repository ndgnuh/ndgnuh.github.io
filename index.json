[{"content":"Trong khi lập trình, để rút ngắn và làm mã nguồn trong sạch, dễ đọc hơn, chúng ta thường viết các hàm với những chức răng riêng biệt. Tuy nhiên, đôi lúc viết hàm không phải là đủ. Khai báo hàm có thể cồng kềnh, bị lồng vào nhau, những cấu trúc lặp đi lặp lại nhưng không dùng hàm xử lý được\u0026hellip; Những trường hợp đó là nơi macro tỏa sáng. May thay, những nhà khoa học MIT đã lường trước điều này và thiết kế Julia với một hệ thống macro - meta programming đầy đủ chức năng.\nSử dụng Macro Macro được tận dụng khá nhiều trong Julia. Chúng thường được nhận biết bằng dấu @ ở đầu. Một số macro quen thuộc là:\n @time: đo độ trễ khi chạy một biểu thức @show: hiện giá trị một biến @info: hiện một thông báo với chữ màu @error: quăng một lỗi, không dừng chương trình @warning: quăng một cảnh báo, không dừng chương trình @.: broadcast mọi hàm trong scope  Khi dùng macro, chúng ta đặt macro trước biểu thức cần tác động vào. Macro sẽ có hiệu lực trong biểu thức đứng trước nó. Ví dụ:\n1 2 3 4  x = [1, 2, 3] @. sum(x^2) # [1, 4, 9] sum(@. x^2) # 14 @. x^2, x^3 # ([1, 4, 9], [1, 8, 27])   Ngoài ra, chúng ta còn có macro với đuôi _str. Đây là những macro được thiết kế đặc biệt cho kiểu dữ liệu String, và có cách gọi rút gọn:\n1 2 3 4 5  using Markdown @md_str \u0026#34;**Bold**\u0026#34; md\u0026#34;**Bold**\u0026#34; @html_str \u0026#34;\u0026lt;b\u0026gt;Bold\u0026lt;/b\u0026gt;\u0026#34; str\u0026#34;\u0026lt;b\u0026gt;Bold\u0026lt;/b\u0026gt;\u0026#34;   Để xem macro sẽ tạo ra đoạn code như nào, ta dùng macro @macroexpand:\n1 2 3 4  @macroexpand @. sum(x^2) # trả về :(sum.((^).(x, 2))) @macroexpand sum(@. x^2) # trả về :(sum((^).(x, 2)))   Từ ví dụ trên có thể thấy @. sum(...) tác động tới cả hàm sum vì sum nằm trong biểu thức mà nó tác động vào, còn sum(@. ...) thì không.\nTự tạo macro Kiểu dữ liệu Expr Khi một đoạn mã Julia được dịch, trước hết nó được đưa qua Abstract Syntax Tree (AST). Kiểu dữ liệu Expr biểu diễn đoạn mã julia khi được đưa qua AST. Một Expr gồm hai phần là head và args. Trong đó head là phần cho biết đoạn mã nguồn thuộc loại biểu thức gì (gọi hàm, lặp, rẽ nhánh\u0026hellip;); args là một vector chứa những biểu thức con.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  expr = :(1 + (2 + 3)) dump(expr) # Expr # head:  # Symbol call # args: Array{Any}((3,)) # 1: Symbol + # 2: Int64 1 # 3: Expr # head: Symbol call # args: Array{Any}((3,)) # 1: Symbol + # 2: Int64 2 # 3: Int64 3   Hàm dump in ra một cách trực quan cấu trúc của Expr. Để tạo ra một Expr, nếu biểu thức ngắn, chúng ta có thể bọc :(...) quanh biểu thức.\nex = :(sum(c)) ex.head # :call ex.args # 2-element Array{Any,1}: # :sum # :c Hoặc dùng khối quote với một nhóm biểu thức hoặc một biểu thức dài:\nex = quote a = 1 b = 2 a + b end ex.head # :block ex.args # 6-element Array{Any,1}: # :(#= REPL[96]:2 =#) # :(a = 1) # :(#= REPL[96]:3 =#) # :(b = 2) # :(#= REPL[96]:4 =#) # :(a + b) Gọi Meta.parse để chuyển một đoạn code về AST:\n1 2 3 4 5 6 7 8  expr = Meta.parse(\u0026#34;1 + 1\u0026#34;) dump(expr) # Expr # head: Symbol call # args: Array{Any}((3,)) # 1: Symbol + # 2: Int64 1 # 3: Int64 1   Cách cuối cùng là gọi trực tiếp Expr với tham số là các biểu thức:\n1 2  ex = Expr(:call, :(+), 1, 1) # :(1 + 1)   Mặc dù nhìn như lời gọi hàm như tất cả mọi thứ chỉ là biểu thức, do đó nếu có một biến số, hàm bên trong Expr thì nó không cần được xác định cho tới khi Expr được đánh giá. Để đánh giá một biểu thức ở dạng Expr, chúng ta dùng hàm eval.\n1 2 3 4  ex = :(sum(c)) # không gây lỗi, vì :c chỉ là một biểu thức con eval(ex) # gây lỗi vì `c` chưa được định nghĩa c = [1,2,3] eval(ex) # trả về 6   Nếu muốn đưa một biến có sẵn vào trong Expression, chúng ta dùng cú pháp nội suy giống trong xâu kí tự:\n1 2 3 4 5 6 7 8 9  x = π expr = :(1 + $x) dump(expr) # Expr # head: Symbol call # args: Array{Any}((3,)) # 1: Symbol + # 2: Int64 1 # 3: Irrational{:π} π   Có thể nói, bản thân mã nguồn cũng chỉ là một kiểu dữ liệu trong Julia. Do đó việc meta-programming trong Julia diễn ra rất tự nhiên.\nCách viết macro Cú pháp của macro khá giống hàm\n1 2 3  macro tên_macro(expr) # thân macro end   Cách hoạt động của macro có thể được hiểu như sau:\n Macro nhận biểu thức cần tác động qua tham số đầu tiên của nó dưới kiểu dữ liệu Expr Phần thân macro biến đổi biểu thức, trả về một Expr khác Julia lấy biểu thức Expr do macro trả về và đánh giá nó  Chúng ta có thể \u0026ldquo;thử\u0026rdquo; thông qua macro sau\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  macro m1(ex) @show typeof(ex) @show ex return ex end @m1 1 + 1 # typeof(ex) = Expr # ex = :(1 + 1) # 2 @m1 1 + 1, 2 * 2 # typeof(ex) = Expr # ex = :((1 + 1, 2 * 2)) # (2, 4)   Có thể thấy, macro @show đã được gọi trong phần thân của m1, kết quả trả về của @m1 là một biểu thức và được đánh giá ngay lập tức. Dưới đây là một macro mà tìm nghịch đảo của một biểu thức:\n1 2 3 4 5  macro inv(ex) Expr(:call, :(/), 1, ex) end @inv 4 # 0.25 @inv 5 # 0.2   Thực ra, macro cũng có thể nhận nhiều tham số, tham số của macro được ngăn cách bằng dấu ,, sẽ phải dùng ngoặc (trước ngoặc không có dấu cách), hoặc dùng dấu cách:\n1 2 3 4 5 6  macro inv2(ex, i = 1) Expr(:call, :(/), i, ex) end @inv2 4 # 0.25 @inv2(5, 2) # 0.4 @inv2 5 2 # 0.4   Dưới đây là một phiên bản khác của macro dùng quote.\n1 2 3 4 5  macro inv(ex) quote 1 / $(ex) end end   phần expression được bọc trong cú pháp nội suy $(...).\nMacro hygiene Macro trong những ví dụ trên chạy rất bình thường. Giả sử chúng ta đang viết một phần mềm, chúng ta muốn chia module, và có một module như sau\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  module MyMacro \u0026#34;\u0026#34;\u0026#34; @inv expr Nghịch đảo biểu thức \u0026#34;\u0026#34;\u0026#34; macro inv(ex) quote 1 / $(ex) end end # end of module end   Sau khi chạy đoạn mã nguồn module trên, chúng ta nhập macro đó để sử dụng:\n1  using Main.MacroExample: @inv   Nhưng đoạn mã nguồn sau sẽ gây lỗi:\n1 2 3 4 5  x = 4 @inv x # ERROR: UndefVarError: x not defined # Stacktrace: # [1] top-level scope at REPL[1]:...   Nhưng x đã được định nghĩa, vậy chuyện gì đã xảy ra? Macro trên được gọi là \u0026ldquo;vệ sinh\u0026rdquo; (hygiene), tức là nó chỉ dùng những biến trong phạm vi mà macro đã được định nghĩa (trong module). Trong trường hợp này MacroExample.@inv sẽ gọi tới MacroExample.x (không tồn tại), dẫn đến lỗi như trên.\nGiờ biến x cần được trỏ tới x trong môi trường gọi macro. Chúng ta có thể giải quyết vấn đề này bằng cách esc (escape) nó. Macro @inv sẽ được định nghĩa như sau:\n1 2 3 4 5  macro inv(ex) quote 1 / $(esc(ex)) end end   Nói cách khác, macro này dùng biến trong môi trường gọi macro, tức là nó \u0026ldquo;không vệ sinh\u0026rdquo; (unhygiene). Một phiên bản gọn hơn của @inv\nmacro inv(ex) Expr(:call, :(/), 1, esc(ex)) end Vậy chuyện gì sẽ sảy ra nếu trong môi trường khai báo có một biến trùng tên với biến nội bộ của macro?\n1 2 3 4 5 6 7  macro inv3(ex) x = 1 Expr(:call, :(/), x, esc(ex)) end x = 4 @inv3 x # 0.25   Câu trả lời là không có gì xảy ra, macro vẫn hoạt động bình thường, vì hàm gensym của Julia tạo ra một biểu tượng độc nhất cho mỗi biến nội bộ của macro.\nMacro \u0026amp; multiple dispatch Vì macro giống function nên cũng có các method khác nhau, vẫn là ví dụ inv:\n1 2 3 4 5 6 7 8 9 10 11  macro inv(ex) Expr(:call, :(/), x, esc(ex)) end macro inv(ex...) quote map($(esc(ex))) do x 1 / x end end end @inv 1 2 4 5 # (1.0, 0.5, 0.25, 0.2)   Macro với cách gọi tắt cho string Những macro có tên với đuôi _str sẽ tự động có cách gọi tắt với String.\n1 2 3 4 5 6 7  macro capslock_party_str(s) quote uppercase($(esc(s))) end end capslock_party\u0026#34;wooloowooloo\u0026#34; # \u0026#34;WOOLOOWOOLOO\u0026#34;   Đương nhiên ta vẫn có thể gọi theo cách thông thường:\n1 2  s = \u0026#34;wooloowooloo\u0026#34; @capslock_party_str s # \u0026#34;WOOLOOWOOLOO\u0026#34;   Khi nào dùng macro Trường hợp thường thấy khi dùng macro là macro cho string (@..._str), trường hợp thường thấy tiếp theo là chúng ta có một cấu trúc code lặp đi lặp lại, nhưng lại là cấu trúc không thể dùng hàm để mô tả được. Khi đó macro sẽ giảm thiểu tối đa việc trùng lặp. Giả sử chúng ta đang cần một kiểu dữ liệu biểu diễn tổng của các số mà không làm mất đi thông tin các số hạng.\n1 2 3 4 5  struct Summation{T\u0026lt;:Real} \u0026lt;: Real terms::AbstractArray{T} Summation(xs...) = Summation(collect(xs)) Summation(xs::AbstractArray) = new{eltype(xs)}(vec(xs)) end   Giờ chúng ta muốn định nghĩa lại các hàm sơ cấp lượng giác trên kiểu dữ liệu này. Nếu không dùng macro chúng ta sẽ dùng như sau:\n1 2 3 4 5 6 7 8 9 10 11  Base.sum(s::Summation) = sum(s.terms) Base.length(s::Summation) = length(s.terms) Base.sin(s::Summation) = sin(sum(s)) Base.cos(s::Summation) = cos(sum(s)) Base.tan(s::Summation) = tan(sum(s)) Base.cot(s::Summation) = tan(sum(s)) Base.asin(s::Summation) = asin(sum(s)) Base.acos(s::Summation) = acos(sum(s)) Base.atan(s::Summation) = atan(sum(s)) Base.acot(s::Summation) = acot(sum(s)) # sinh, cosh, tanh, cosh, asinh, acosh....   Nói chung là dài. Với macro, chúng ta có thể làm như sau (hãy mở lại Julia và định nghĩa lại struct trên trước khi thử)\n1 2 3 4  for op in (:sin, :cos, :tan, :cot), vop in Symbol.([op, \u0026#34;a$(op)\u0026#34;, \u0026#34;$(op)h\u0026#34;, \u0026#34;a$(op)h\u0026#34;]) @eval Base.$vop(s::Summation) = $vop(sum(s)) end   Trong đó @evals x là macro cho eval(:(x)). Giờ thử với methodswith:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  methodswith(Summation) # [1] acos(s::Summation) in Main at REPL[2]:2 # [2] acosh(s::Summation) in Main at REPL[2]:2 # [3] acot(s::Summation) in Main at REPL[2]:2 # [4] acoth(s::Summation) in Main at REPL[2]:2 # [5] asin(s::Summation) in Main at REPL[2]:2 # [6] asinh(s::Summation) in Main at REPL[2]:2 # [7] atan(s::Summation) in Main at REPL[2]:2 # [8] atanh(s::Summation) in Main at REPL[2]:2 # [9] cos(s::Summation) in Main at REPL[2]:2 # [10] cosh(s::Summation) in Main at REPL[2]:2 # [11] cot(s::Summation) in Main at REPL[2]:2 # [12] coth(s::Summation) in Main at REPL[2]:2 # [13] sin(s::Summation) in Main at REPL[2]:2 # [14] sinh(s::Summation) in Main at REPL[2]:2 # [15] tan(s::Summation) in Main at REPL[2]:2 # [16] tanh(s::Summation) in Main at REPL[2]:2   Như vậy chúng ta với 4 dòng gọn gàng chúng ta đã định nghĩa được 16 method cho kiểu dữ liệu này mà không có dòng nào bị trùng lặp hay thừa.\nNhững macro hữu dụng Đây không phải tất cả macro, trong các module khác có thể có nhiều macro hơn nữa. Macro khá ít so với hàm nên có thể được tìm nhanh bằng cách gõ @ và tab trên REPL.\n   Macro chức năng     @time tính thời gian thực thi   @btime (từ Benchmark.jl) tính thời gian thực thi, nhưng chính xác hơn và không bao gồm thời gian JIT   @benchmark (từ Benchmark.jl) đánh giá biểu thức, bao gồm thống kê thời gian thực thi và phân bố bộ nhớ   @. thực hiện broadcast (f.(x)) trên tất cả các phép toán và hàm trong cùng phạm vi   @simd thực hiện simd cho vòng lặp, map và filter   @inbounds không kiểm tra chỉ số khi truy cập mảng, tăng tốc đáng kể trong trường hợp kiểm soát được chỉ số mảng   @show,@info,@error các macro hỗ trợ debug   Base.@kwdef định nghĩa struct với method khởi tạo dùng keyword   @isdefined kiểm tra xem một biến được định nghĩa hay chưa   @deprecate cảnh báo rằng một hàm, đoạn mã nguồn đã bị lỗi thời, không nên dùng   @view/@views tạo View khi lấy chỉ số của Array thay vì tạo ra một array mới   @inline/@noinline báo với compiler rằng một hàm có nên được inline hay không   @DIR đường dẫn thư mục chứa file mà macro này được gọi   @FILE đường dẫn file chứa lời gọi macro   @MODULE module mà code đang được gọi từ   @which xem một method, hàm, biến nằm trong module nào    Kết Macro có vẻ là một thức khá thần thánh và hữu dụng trong nhiều trường hợp. Tuy nhiên macro không nên bị làm dụng, đa số các tình huống có thể xử lý được (một cách đủ tốt) bằng hàm và có thể kết hợp với những macro có sẵn. Dùng macro bừa bãi có thể khiến chương trình thiếu ổn định (vì macro sinh mã nguồn nên khó kiểm soát), và một số trường hợp gây ảnh hưởng tới hiệu năng.\n","description":"","id":0,"section":"posts","tags":["julia"],"title":"Julia dojo: Macro \u0026 meta programming","uri":"https://ndgnuh.github.io/posts/julia-dojo/macro/"},{"content":"LyX cung cấp khả năng tương thích với mọi lệnh trong môi trường toán của TeX. Khi có những biểu thức toán dài và lặp lại nhiều lần, ta tạo ra một macro trong TeX để rút gọn câu lệnh và tiết kiệm thời gian. Trong LyX cũng hỗ trợ tạo những macro cho môi trường toán, tuy nhiên cấu trúc của macro trong LyX hơi khác một chút.\nSử dụng macro Tạo một macro Macro trong LyX được tạo bởi phím tắt Alt-I + H + O (Insert \u0026gt; Math \u0026gt; Macro). Macro trong LyX gồm ba phần:\n Phần tên (Name) Phần câu lệnh (TeX) Phần hiển thị (LyX)  Phần tên là câu lệnh rút gọn mà ta cần tạo. Phần câu lệnh chính là phần code LaTeX sẽ được dùng khi tạo văn bản. Phần hiển thị chỉ là phần mà LyX sẽ hiển thị cho chúng ta khi dùng câu lệnh đó, phần này không ảnh hưởng tới văn bản được tạo ra. Nếu để trống phần hiển thị thì LyX sẽ mặc định hiển thị những thứ trong phần TeX.\nMacro có tham số Nhiều khi, biểu thức toán lặp lại nhiều lần với cấu trúc gần giống nhau, chỉ khác nhau một chút. Đó là lúc chúng ta cần tới tham số. Để chèn tham số trong macro, chúng ta chèn \\#\u0026lt;thứ tự tham số\u0026gt; vào nơi muốn đặt tham số đó. Ví dụ:\nTrong hình định nghĩa macro \\ang, với 2 tham số đặt trong ngoặc nhọn.\nMột số loại macro thường dùng Macro toán tử, macro hàm Trong LaTeX chúng ta định nghĩa một toán tử bằng \\operatorname. Tuy nhiên LyX không cung cấp hiển thị cho lệnh này, lý do vì không cần thiết. Khi muốn tạo một toán tử trong LyX, chúng ta tạo một macro với phần TeX là \\operatorname{\u0026lt;tên toán tứ\u0026gt;} và dùng \\mathrm ở phần hiển thị để toán tử hiển thị gọn gàng khi edit. Hình minh họa một macro với tên \\name được định nghĩa, tạo ra một toán tử tên \u0026ldquo;name\u0026rdquo;, và sẽ hiển thị là \\mathrm{name} trên trình soạn thảo.\nTuy dùng \\mathrm có vẻ nhanh nhưng \\mathrm trong văn bản cuối sẽ gây ra sai khoảng cách, do đó chỉ dùng \\mathrm để hiển thị trong LyX chứ không dùng \\mathrm cho tên hàm, toán tử trong TeX.\nCó thể vì ký hiệu khá đa dạng, LyX (và có thể cả TeX) không định nghĩa sẵn một số hàm lượng giác (hyperbolic) ngược, do đó chúng ta cần tự định nghĩa bằng macro:\nMacro ngoặc (khó dịch, delimiters) Những cặp ngoặc như (){}[]|| trong LyX được gọi chung là Delimiters. Ngoài những cặp ngoặc này ra chúng ta còn những cặp thường dùng khác nhưng không được gắn phím tắt mặc định. Ví dụ như:\nNhững cặp ngoặc này có thể được chèn bằng Alt-I + R hoặc Insert \u0026gt; Math \u0026gt; Delimiters..., hộp thoại chèn delimiter có cấu trúc như sau:\n Ô chọn ngoặc trái phải Câu lệnh TeX tương ứng Keep matched khi được đánh dấu sẽ làm cho ngoặc trái với ngoặc phải cùng loại với nhau. Swap \u0026amp; Reverse đổi chỗ ngoặc trái và phải. Size là kích cỡ ngoặc, chọn variable để ngoặc kéo dài bao phủ hết phần bên trong ngoặc.  Dưới đây là các macro tương ứng với hình ở trên. Ngoặc trái của lệnh \\sub được chọn là (none), tức là không có ngoặc.\nMacro alias Khi có một lệnh dài nhưng xuất hiện nhiều lần, ta tạo alias cho nó bằng macro để tăng tốc độ soạn thao. Ví dụ, các tập số thường được kí hiệu bằng \\mathbb{tên} (ví dụ như \\mathbb{R}). Dù LyX có hỗ trợ nhưng tần suất xuất hiện của lệnh này khá cao, dẫn đến chậm khi gõ. Do đó, để tiện thì chúng ta có thể định ra macro với một chữ cái cho các tập số:\nLưu macro thường dùng Sau một thời gian sử dụng, số macro cần dùng sẽ tăng lên kha khá. Do đó copy hoặc víết tất cả macro với mỗi văn bản cần dùng macro đó sẽ phiền vô cùng. LyX khắc phục điều này với hệ thống Child document (nói thêm sau).\nĐầu tiên, chúng ta cần lưu macro vào một file LyX. File này không có gì ngoài Macro. Giả sử file này có tên macro.lyx, với mỗi văn bản mà ta cần dùng macro, ta chèn file macro.lyx trên đầu của file hiện tại bằng cách di con trỏ soạn thảo lên đầu (Ctrl-Home), sau đó nhấn tổ hợp phím Alt-I + E + D (hoặc Insert \u0026gt; File \u0026gt; Child Document...). Tại hộp văn bản hiện ra:\n Nhấn vào browse, tìm và chọn file macro.lyx. Chọn Input tại include type Nhấn Ok để đóng hộp thoại  Sau đó, tất cả macro sẽ tự nhiên hoạt động trong văn bản một cách kì diệu :)\nKết luận Cũng như việc dùng phím tắt ra, macro tăng tốc độ soạn thảo văn bản lên đáng kể. Ngoài ra còn một số lưu ý nhỏ sau khi tạo macro:\n Kiểm tra xem macro đó có được định nghĩa bởi LaTeX hay không (nếu nó được định nghĩa trước thì tạo macro có thể gây lỗi). Cách dễ nhất là xóa macro đi, tạo môi trường toán và thử xem lệnh đó có tồn tại hay không. Macro cũng như lệnh trong môi trường toán, do đó cũng có thể được sử dụng với phím tắt như một lệnh toán (dùng math-insert \u0026lt;tên macro\u0026gt;)  ","description":"","id":1,"section":"posts","tags":["true","linux","foss","lyx","latex","tex"],"title":"Gõ tắt sử dụng macro trong Lyx","uri":"https://ndgnuh.github.io/posts/lyx-macro/"},{"content":"Có thể nói, LyX là một trong những nỗ lực của tác giả để thích nghi với việc học online, vì khi học online, việc ghi chép với vở trở nên rất lỉnh kỉnh do có nhiều công cụ trên bàn, hơn nữa một số giáo viên nói rất nhanh khi sử dụnng slide thay vì viết bảng. Tuy nhiên, dùng LyX với cả bàn phím và chuột sẽ không thể đạt được tốc độ tối đa. Do đó bài viết này sẽ cung cấp những thông tin cần thiết để làm việc với LyX chỉ bằng bàn phím (và có thể là một ít chuột). Đây có lẽ cũng là bài viết quan trọng nhất trong những bài về LyX.\nBài viết có thể khá dài nhưng chỉ có hai điều chủ yếu nên nhớ:\n Việc học thuộc phím tắt là hoàn toàn không cần thiết, cứ dùng một vài lần và phím tắt sẽ thành phản xạ. Alt - p cho đoạn văn (paragraph), Alt - m cho toán (math).  Hơn nữa, phần sau bài viết này đa phần mang tính giới thiệu. Phần đầu khá ngắn và cung cấp đủ thông tin về cách dùng phím tắt trong LyX.\nSử dụng cơ bản Xem và cài đặt phím tắt Như ở đầu bài viết nói, tất cả phím tắt có thể xem và tùy chỉnh trong Tools \u0026gt; Preferences \u0026gt; Editing \u0026gt; Shortcuts.\nỞ trên cùng, chúng ta có khung chọn bind file. Bind file là một file với đuôi .bind lưu preset cho phím tắt. Một số bind file được viết sẵn cho người dùng như emacs, mac (mặc định là cue). Những file này được lưu trong /usr/share/lyx/bind/ (hoặc /usr/local/share/lyx/bind) trên *Nix, Lyx.app \u0026gt; show package \u0026gt; Contents/Library (cần người test) và C:\\Program Files\\LyX\u0026lt;phiên bản\u0026gt;\\Resources\\bind.\nTiếp theo là dòng show key-bindings containing. Đây thực ra là một cái hộp textbox với bộ lọc để tìm phím tắt hiện có.\n Trong hình không nhìn thấy textbox vì màu nền của textbox trùng với màu nền cửa sổ. Hơi sida :v\n Ở giữa, to nhất là bảng phím tắt. Bảng này được chia thành các mục lớn để dễ quản lý hơn. Mathematical Symbols (công thức toán) và Font, Layout and Textclasses (chỉnh sửa liên quan tới format văn bản) là hai mục chúng ta hay dùng nhất. Cursor, Mouse and Editing functions là những phím tắt liên quan tới điều hướng. Document and Window gồm những phím tắt điều khiển cửa sổ của LyX, đóng mở văn bản\u0026hellip; System and Miscellaneous là những phím tắt không được xếp loại.\nTrong mỗi mục, các phím tắt có thể được sửa bằng cách nhấm đúp vào phím tắt hoặc chọn phím tắt và nhấn Modify. Hộp thoại nhỏ chính là phần để chỉnh sửa phím tắt.\n Function: là câu lệnh của LyX được gán cho phím tắt Shortcut: nhấn vào ô bên cạnh chữ shortcut và nhấm phím mình muốn để cài phím tắt Delete key: xóa một phím trong tổ hợp phím tắt Clear: xóa tất cả phím trong tổ hợp phím tắt Ok: lưu Cancel: hủy  Phím tắt mới có thể được thêm bằng nút New, hoặc xóa đi bằng phím Remove. Sau khi cài đặt xong. Cuối cùng, nút Apply hoặc Ok có thể dùng để lưu phím tắt khi cài đặt xong.\nTìm câu lệnh \u0026amp; phím tắt của LyX Để tạo ra phím tắt mới, chúng ta cần có thông tin về câu lệnh của LyX. Cách đơn giản nhất để tìm câu lệnh của LyX là dùng thử một vài phím tắt, sau đó tìm câu lệnh của những phím tắt đó trong phần cài đặt (Phần Function). Đối với những chức năng sử dụng menu, phím tắt được ghi:\n Ở bên phải của item trên menu. Được gạch chân  Menu trên thanh menu (bên dưới tiêu đề) có thể được truy cập bằng cách Alt-\u0026lt;Phím tắt\u0026gt;. Phím tắt được gạch chân ở tiêu đề menu và sẽ hiện khi nhấn giữ Alt.\nTuy nhiên, khi cần thêm một lệnh nào lạ lạ mà chúng ta không mò được bằng phím tắt, chúng ta cần cách khác. Đầu tiên, mở menu View và đảm bảo rằng Messages pane được bật. Messages pane chính là phần cửa sổ với tiêu đề (Progress/Debug Messages) chiếm nửa dưới màn hình.\nTiếp theo, ở phần Messages Pane, chọn Settings và cài đặt như sau (xem thêm hình):\n Chọn selected ở phần Debug Messages Ở phần debug level, chuyển action - User commands thành yes.  Sau đó, chuyển lại sang phần Output và khi một hành động được thực hiện. Câu lệnh của hành động đó sẽ hiện lên ở phần Messages Pane (phần bôi đen trong hình)\nCâu lệnh chính là phần trong ngoặc (dialog show character). Nó có thể được gắn với một phím tắt bằng cách thêm câu lệnh vào phần Function của phím tắt đó.\nSao lưu và khôi phục phím tắt LyX lưu phím tắt người dùng thư mục tên bind trong đường dẫn như sau (~ là thư mục home):\n Linux/Unix nói chung: ~/.lyx MacOS: ~/Library/Application Support/LyX-\u0026lt;phiên bản\u0026gt;/ (chưa test) Windows: C:\\Documents and Settings\\\u0026lt;tên người dùng\u0026gt;\\Application Data\\lyx\u0026lt;phiên bản\u0026gt;\\, C:\\Program files\\lyx\\resources\\lyx\\ (chưa test)  Chỉ cần lưu lại file bind và đặt nó vào đúng các thư mục trên là ok.\n Ngoài ra, nếu không tìm thấy thư mục LyX thì có thể vào phần Help \u0026gt; About LyX trên menu. Phần này sẽ có cả thông tin về thư mục người dùng và hệ thống của LyX.\n Một số phím tắt hữu dụng Phím tắt thao túng môi trường Nếu bạn không làm việc với toán hoặc các ký hiệu kỹ thuật (chỉ cần viết chữ), bạn có thể skip mục này.\n Từ \u0026ldquo;môi trường\u0026rdquo; chỉ là một từ bịa ra cho dễ nói thôi, không trực tiếp tương ứng với môi trường trong LaTeX, đừng lo về nó quá.\n Trong LyX có ba loại môi trường mà chúng ta sẽ làm việc cùng:\n Môi trường văn bản: là môi trường mặc định mà chúng ta sử dụng. Vì nó là mặc định nên không cần insert. Môi trường toán: là môi trường mà chúng ta có thể nhét các lệnh trong môi trường toán của LaTeX vào. Đừng lo quá về chữ toán. E.R.T (evil red text): môi trường này cho phép sử dụng lệnh bất kì của LaTeX. Điểm khác biệt với môi trường toán là nó sẽ không có preview mặc định như môi trường toán; và lệnh nằm trong E.R.T tương ứng với môi trường bình thường của LaTeX (thay vì môi trường toán). Môi trường này có thể được insert bởi phím tắt Ctrl-l.  Môi trường toán Với môi trường toán, chúng ta có phím tắt cơ bản nhất là Ctrl-m, hoặc Alt-m m trong môi trường văn bản. Phím tắt này chèn một môi trường toán inline, môi trường này tương ứng với $...$ trong LaTeX. Inline có nghĩa rằng trong văn bản cuối cùng phần toán sẽ nằm cùng với phần chữ.\nMôi trường toán thứ hai là môi trường display, tương ứng với $$...$$ trong LaTeX. Môi trường này tạo ra một dòng riêng cho phần toán. Môi trường display có thể được tạo ra với phím tắt Alt-m d. Nếu dùng Alt-m d một lần nữa trong môi trường display thì LyX sẽ chuyển lại môi trường inline.\nMôi trường toán thứ ba là môi trường align, tương ứng với \\begin{align} \\end{align} trong LaTeX. Có hai cách để tạo môi trường Align, cách một là Alt-i h a trong môi trường text, cách hai là dùng tổ hợp Alt-m t a hoặc Ctrl-Enter trong môi trường toán. Môi trường align cũng tạo khu vực gồm nhiều dòng cho phần toán, các dòng được căn chỉnh để có một sự thẳng hàng nhất định (xem hình sẽ rõ).\nCác ô lẻ trong một dòng được căn lề trái, các ô chẵn căn lề phải. Môi trường align mặc định cung cấp còn có phím tắt để thêm dòng, cột:\n Thêm dòng sau dòng hiện tại: Alt-m w i Thêm cột sau cột hiện tại: Alt-m c i Xóa dòng hiện tại: Alt-m w d Xóa cột hiện tại: Alt-m c d Thêm dòng mới, nhưng chia nội dung dòng hiện tại ở vị trí con trỏ soạn thảo: Ctrl-Enter   Cách để nhớ phím tắt dễ hơn: w tương ứng với dòng, c tương ứng với cột, i là insert (chèn thêm), d là delete (xóa).\n LyX hỗ trợ việc lồng cái môi trường vào nhau. Để gõ chữ trong môi trường toán bất kì hãy dùng phím tắt Ctrl-m hoặc Alt-m m, LyX sẽ chèn một môi trường văn bản vào vị trí hiện tại. Ngoài những môi trường toán trên, LyX còn cung cấp những môi trường toán khác, nhưng chúng không hay được dùng lắm nên thường không có phím tắt mặc định. Những môi trường này có thể được sử dụng bằng cách nhấn chuột phải vào một môi trường toán và chọn AMS Environment.\nPhím tắt điều hướng  Một số trong những phím tắt này, thực chất, là những phím tắt rất phổ biến, do đó không chỉ được dùng trong LyX, chúng được dùng trong khá nhiều các phần mềm khác mà có chứng năng soạn thảo (trình duyệt, hệ điều hành,\u0026hellip;)\n Phím tắt điều hướng chung\n Trên/dưới/trái/phải: Dịch con trỏ soạn thảo lên, xuống, trái, phải một cách tương ứng. Ctrl-trái/Ctrl-phải: Dịch chuyển con trỏ soạn thảo sang từ bên trái hoặc phải. Home/End: Dịch con trỏ soạn thảo về đầu/cuối dòng chữ. Page up/down: Cuộn lên, xuống với khoảng cách là độ dài màn hình. Ctrl-Page up/down: Chuyển sang văn bản phía trước/phía sau (nếu đang mở nhiều văn bản). Ctrl-Home/End: Nhảy xuống đầu/cuối văn bản.  Ngoài ra, chúng ta có một số phím tắt dùng trong môi trường toán:\n Lệnh ở phần này ám chỉ lệnh có dạng như trong LaTeX, ví dụ như \\lim.\n  Tab: Nếu đang viết dở một lệnh, Tab sẽ tự hoàn thành lệnh đó. Nếu có nhiều cách đề hoàn thành thì một bảng gợi ý sẽ hiện ra. Khi không viết lệnh nào, Tab được dùng để nhảy sang ô tiếp theo trong môi trường align (hoặc những môi trường có nhiều ô để viết). Nếu không có ô nào để nhảy thì nó sẽ thoát khỏi môi trường. Shift-Tab: Tương tự như Tab nhưng thay vì nhảy sang ô tiếp theo thì nhảy về ô ở phía trước. Space: Phím cách có tác dụng hoàn thành lệnh đang viết dở, nhưng Space sẽ ngắt lệnh ngay lập tức thay vì tự điền lệnh. Ngoài ra, Space có tác dụng thoát ra khỏi môi trường toán khi không viết lệnh.  Trong khi dùng những phím tắt điều hướng, phím Shift có thể được giữ để đánh dấu phần văn bản giũa hai vị trí con trỏ.\nPhím tắt chuyển layout Trong LyX, mỗi đoạn văn đi kèm với một layout, layout có thể là:\n tiêu đề, section, subsection\u0026hellip; đoạn văn bản liệt kê (đánh số hoặc không đánh số) đầu đoạn văn bản \u0026hellip;  Phím tắt Alt-P trong LyX liên kết tới tất cả các layout. Đầu tiên, các phím tắt từ Alt-P-1 cho tới Alt-P-5 được dùng cho các đề mục trong văn bản:\n Chapter (chương) Section (phần) Subsection (phần con) Subsubsection (phần cháu) Paragraph (đầu đoạn văn)\nNgược lại với những layout đề mục, ta có Alt-P-s là layout mặc định, s là viết tắt của standard (tiêu chuẩn). Tiếp theo, chúng ta có:   Alt-P-t: (t = title) tiêu đề cho cả văn bản Alt-P-e hoặc Alt-P-n: (n = numbered, e = enumerate) layout liệt kê có đánh số Alt-P-b: (b = bullet) layout liệt kê không đánh số  Còn nhiều phím tắt khác nhưng chúng sẽ không liệt kê ở đây mà để người đọc tự mò (dùng Alt-P). Với những layout không có phím tắt, sau khi sử dụng Alt-P-Space, một menu cho phép người dùng nhập keyword, LyX sẽ search keyword đó để tìm ra layout người dùng muốn (nhấn Enter để chọn, Escape để hủy, Backspace để xóa keyword).\nPhím tắt chèn Phím tắt chèn có thể được xem trong menu insert, các phím tắt được gạch chân. Để mở menu insert, chúng ta cũng có phím tắt là Alt-I. Phím tắt cũng có thể được kết hợp với nhau. Ví dụ như Alt-I H Y sẽ chèn một ma trận. Trong môi trường toán Alt-M được dùng để chèn gần như đủ mọi thứ. Phần này người đọc được khuyên tự xem và tùy chỉnh phím tắt phù hợp ý mình. Tuy nhiên, vẫn có một số phím tắt toán thông dụng là:\n Alt-M F: \\Frac - phân số Alt-M S: Square root - căn bậc 2 Alt-M R: Root - căn bậc tùy ý Alt-M \u0026lt;ngoặc\u0026gt;: Chèn cặp ngoặc, mặc định áp dụng cho (), {}, [], ||, \u0026lt;\u0026gt;. phím tắt này được khuyên dùng thay vì dùng ngoặc đơn thuần. Lý do thứ nhất vì nó sẽ dùng \\left, \\right tự động để căn chỉnh độ rộng của ngoặc. Lý do thứ hai vì việc điều hướng dễ hơn. Cặp ngoặc chèn bởi phím tắt này sẽ tạo điểm neo cho phím tắt điều hướng. Alt-M E: Chèn chỉ số trên, được khuyên dùng thay cho ^, vì tay sẽ phải với ít hơn và phím 6 rất khó bấm. Alt-M X: Chèn chỉ số dưới, được khuyên dùng thay cho _ vì lý do tương tự. Alt-M U: Chèn dấu tổng  Kết Mới đầu, việc dùng phím tắt có thể hơi phức tạp và dài dòng nhưng sau đó, phím tắt sẽ boost tốc độ gõ lên rất, rất, rất nhiều. Lời khuyên thứ nhất là không nên học thuộc tất cả, chỉ cần sử dụng một vài lần với những chức năng thường dùng và tay sẽ quen với việc dùng phím tắt. Lời khuyên thứ hai là các phím tắt có tính gợi nhớ và thường là từ tiếng Anh nào đó. Mong rằng người đọc bài viết có thể làm việc hiệu quả với công cụ này.\n","description":"","id":2,"section":"posts","tags":["linux","foss","lyx","latex","tex","học online","productivity"],"title":"Phím tắt trong LyX \u0026 ghi chép tốc độ","uri":"https://ndgnuh.github.io/posts/lyx-shortcut-and-fast-note/"},{"content":"Chào mừng quay trở lại với series Julia Dojo. Ở bài viết trước chúng ta đã tìm hiểu về hệ thống kiểu dữ liệu trong Julia. Chúng ta cũng đã biết rằng để viết hàm thì không cần định kiểu dữ liệu. Vậy tại sao lại có những hàm hoạt động với nhiều kiểu dữ liệu khác nhau? Đó là do multiple dispatch. Những hàm với đầu vào không cố định kiểu dữ liệu như vậy được gọi là generic function.\nMultiple dispatch là gì? Trong Julia, mỗi khi một generic function được gọi với một kiểu dữ liệu mới, bộ dịch sẽ tạo ra một \u0026ldquo;phiên bản\u0026rdquo; của function đó. Sự kết hợp của một hàm và một đầu vào có kiểu cụ thể này được gọi là một method. Danh sách tất cả method đi với một function sẽ được khi trong một bảng nhớ ảo trong chính function đó. Trong runtime (thời gian chạy), Julia sẽ tìm chính xác method cần gọi trong bảng trên, dựa vào những tham số đầu vào khi gọi hàm. Điều này khả thi vì khi gọi hàm, thông tin về tham số đầu vào đều sẵn có.\nCơ chế này không chỉ riêng Julia có, nhưng rất ít ngôn ngữ khác được thiết kế theo cơ chế này. Một ví dụ nhỏ với phép toán *:\n1 2 3 4 5 6 7  mat_a = [1 2; 3 4] mat_b = [2 0; 1 1] x = 4 y = 5 mat_a * mat_b # nhân ma trận mat_a * x # nhân ma trận với số x * y # nhân số với số   Phép toán trên thực chất cũng là một hàm và có thể gọi như hàm thông thường (*(1, 3) == 3). Để xem tất cả methods của một hàm, ta dùng hàm methods.\n1 2 3 4 5 6  methods(sum) # 13 methods for generic function \u0026#34;sum\u0026#34;: # [1] sum(x::Tuple{Any,Vararg{Any,N} where N}) in Base at tuple.jl:396 # [2] sum(r::StepRangeLen) in Base at twiceprecision.jl:536 # [3] sum(r::AbstractRange{#s69} where #s69\u0026lt;:Real) in Base at range.jl:978 # ... Kết quả khá dài   Class là không cần thiết Bản thân tác giả lần đầu tìm hiểu Julia cũng không thấy mặn mà vì thiếu đi class, sau một thời gian sử dụng Julia mới thấy Multiple Dispatch có những ưu điểm của class, thậm chí có nhứng ưu điểm mà class không có.\nĐa hình Điều này là hiển nhiên vì Multiple Dispatch tạo method với mỗi kiểu dữ liệu mới. Điểm khác biệt với những ngôn ngữ lập trình hướng đối tượng với class là: method trong những ngôn ngữ này gắn liền với class, trong khi method trong Julia gắn với function.\nĐiều này thậm chí có một vài ưu điểm so với ngôn ngữ với những ngôn ngữ với class. Thứ nhất, vì method gắn với hàm chứ không phải class, chúng ta có thể định nghĩa generic một cách dễ dàng. Thứ hai, với Multiple Dispatch, chúng ta có thể mở rộng chức năng cho một kiểu dữ liệu tùy ý mà không cần thay đổi mã nguồn của kiểu dữ liệu hay tạo ra kiểu dữ liệu mới.\nVí dụ, một thư viện cung cấp hệ màu RGB, bạn muốn một hàm chuyển đổi từ RGB sang YMCK nhưng thư viện này không cung cấp. Trong ngôn ngữ với class, bạn hoặc phải viết lại toàn bộ mã nguồn của class - Không hay cho lắm, hoặc phải kế thừa lại class RGB và viết method cho class mới đó. Nhưng chuyện kế thừa lại cũng nhiều vấn đề: class mới tên là gì, có ý nghĩa gì, thậm chí class RGB trên có thể không được cho kế thứa\u0026hellip; Với Multiple Dispatch, bạn có thể đơn giản viết một hàm như sau:\n1 2 3  function YMCK(color::RGB) # convert logic trong này end   Không có class nào cần phải viết lại, không có class nào để kế thừa, chỉ cần viết hàm.\nĐóng gói Nếu như những ngôn ngữ khác sử dụng namespace để quản lý tên thì Julia cũng có module. Một module bao gồm những hàm, kiểu dữ liệu, và biến số. Một số đặc điểm trong module của Julia là:\n Namespace trong những ngôn ngữ class chỉ có class bên trong, còn module có hàm, kiểu dữ liệu (struct) và biến/hằng số Một module có thể mở rộng hàm của module khác, ví dụ như gói SymEngine định nghĩa ra kiểu dữ liệu là Basic và phép cộng trừ nhân chia, cộng nhân ma trận trên đó. Tuy nhiên, khi thực hiện các thao tác trên chúng ta vẫn chỉ cần viết dấu *, + và det(...) mà không phải làm mấy trò con bò như SymEngine.sym_mul, SymEngine.sym_add hay SymEngine.sym_matrix_det. Lý do vì gói này đã mở rộng thêm những method cho hàm cộng và nhân trong module Base (module gốc của Julia). Cơ chế này không chỉ áp dụng cho toán tử mà tất cả các hàm, kể cả hàm tự định nghĩa. Việc gọi hàm không nhất thiết phải chỉ ra hàm đó thuộc namespace nào, lý do vì các gói Julia thường extend lại hàm của nhau và mỗi khi dùng gói, ta chỉ lấy thêm những method được định nghĩa trong module đó. Ví dụ:  Kế thừa Trong Julia, kiểu dữ liệu chia làm trừu tượng (AbstractArray, Number, Real\u0026hellip;) và cụ thể (Float32, Bool, Int64\u0026hellip;). Cơ chế kế thừa của Julia rất đơn giản: dùng method với kiểu dữ liệu cụ thể nhất có thể. Nói cách khác, khi ta gọi một hàm, nếu kiểu của tham số có một method cụ thể, nếu không thì Julia sẽ tìm tới method của những kiểu dữ liệu trừu tượng hơn.\n Vẫn không hiểu?\n Sau đây là một ví dụ nho nhỏ:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function square(x::Number) @info \u0026#34;square cho Number nói chung\u0026#34; x * x end square(2) # square cho Number square(1 + 2im) # square cho Number function square(x::Real) @info \u0026#34;square cho Real, Real \u0026lt;: Number\u0026#34; x * x end square(2) # square cho Real square(1 + 2im) # square cho Number function square(x::Float32) @info \u0026#34;square cho Float32, Float32 \u0026lt;: AbstractFloat \u0026lt;: Real\u0026#34; x * x end square(2f0) # square cho Float32 square(2) # square cho Real square(1 + 2im) # square cho Number   Vì kiểu dữ liệu cụ thể không thể làm kiểu dữ liệu con của nhau trong Julia, chỉ có method mới có thể được kế thừa từ kiểu dữ liệu cha.\nMultiple Dispatch đặc biệt Dispatch với DataType Hàm rand của Julia có một số cách gọi như sau:\n1 2 3 4  rand(DataType, ...) rand(Float32, ...) rand(Int, ...) rand(Distribution, ...) # từ gói Distributions.jl   Mỗi cách gọi sẽ trả về một số, ma trận ngẫu nhiên tùy vào kiểu dữ liệu được ở tham số thứ nhất. Dispatch như trên có thể được viết bằng cú pháp:\n1 2 3  function f(::Type{DataTypeHere}, ...) # thân hàm end   Ví dụ:\n1 2 3 4 5 6 7 8 9 10  function f(::Type{Real}, x) x + 1 end function f(::Type{Complex}, x) x * 2 end f(Real, 10) # trả về 11 f(Complex, 11) # trẻ về 22 f(Float32, 1) # lỗi, không có method nào như thế này   Dispatch với tham số là kiểu dữ liệu không sử dụng kiểu dữ liệu con, do đó gọi f với Float32 như ở trong ví dụ trên lỗi (dù Float32 là kiểu con của Real). Đương nhiên, tham số dựa trên kiểu dữ liệu có thể được đặt ở bất cứ vị trí nào trong hàm, nhưng hàm trong Julia thường viết với tham số loại này ở đầu.\nDispatch với Val Kiểu dữ liệu Val được dùng để dispatch trên một số giá trị biết trước. Sử dụng Val hơi giống với switch - case trong C, nhưng gọn hơn rất nhiều. Cách viết dispatch với Val khá giống với cách viết của dispatch kiểu dữ liệu, nhưng thay vì Type{DataType} thì ta viết Val{giá trị}.\n1 2 3 4 5 6 7 8 9  function do_something(x, ::Val{:double}) x * 2 end function do_something(x, ::Val{:sqrt}) sqrt(x) end function do_something(x, ::Val{:add3}) x + 3 end   Để gọi một hàm với giá trị như trên chúng ta phải dùng hàm Val:\n1 2 3  do_something(4, Val(:double)) # 8 do_something(4, Val(:sqrt)) # 2.0 do_something(4, Val(:add3)) # 7   Lưu ý: Để viết hàm ta dùng Val{...} (ngoặc nhọn), để gọi hàm ta dùng Val(...) (ngoặc tròn).\nTrong một vài trường hợp, chúng ta có thể làm một trick nho nhỏ như sau để gọi hàm tiện lợi hơn:\ndo_something(x, action::Symbol) = do_something(x, Val(action)) Khi đó chúng ta có thể gọi hàm với kiểu Symbol mà không cần Val:\n1 2 3  do_something(4, :double) # 8 do_something(4, :sqrt) # 2.0 do_something(4, :add3) # 7   Lưu ý khi extend function Chúng ta sẽ kết thúc bài này bằng một vài lưu ý. Thứ nhất, có thể có hai hàm cùng tên. Nếu muốn extend một hàm từ một module của thư viện khác, tốt nhất hãy dùng: TênModule.tên_function khi khai báo một method mới cho một hàm có sẵn. Ngoài ra, bạn cũng có thể dùng\n1  Import: hàm_1, hàm_2, ...# danh sách hàm cần extend   trước khi định nghĩa method mới. Nếu không muốn định nghĩa method mới mà viết hàm mới thì không cần làm những việc trên, chỉ cần không export hàm đó ra là được (export là gì nói sau).\nThứ hai, khi extend một hàm từ module Base, những module khác cũng sẽ dùng method mới được định nghĩa đó. Ví dụ, nếu định nghĩa * với kiểu Symbol như sau:\nmodule A import Base.* *(x::Symbol, y::Symbol) = Symbol(x,y) end Thì tất cả các module khác dùng Base mà dùng * cũng có thể dùng method trên. Vì vậy hãy cận thận kiểm tra xem method đó đã được định nghĩa chưa trước khi khai báo.\n","description":"Multiple dispatch và lý do Julia không cần class","id":3,"section":"posts","tags":["julia"],"title":"Julia Dojo: Multiple Dispatch","uri":"https://ndgnuh.github.io/posts/julia-dojo/multiple-dispatch/"},{"content":"Chào mừng trở lại với Julia Dojo, đã khá lâu rồi không đăng bài có bài đăng với lý do deadline ngập mồm :( Bài viết trước đã giới thiệu một số kiểu dữ liệu cơ bản như số, từ điển, mảng. Trong bài viết này chúng ta sẽ khám phá một các tổng quan hơn về hệ thống kiểu dữ liệu của Julia.\nĐộng, nhưng không hẳn Mặc dù Julia có hệ thống kiểu dữ liệu, Julia vẫn có những lợi thế của hệ thống kiểu tĩnh bằng khả năng định kiểu dữ liệu cho các giá trị. Lợi thế tuyệt vời nhất là: hệ thống kiểu này cho phép dispatch dựa trên kiểu dữ liệu trong bất kì hàm nào.\nMình không biết dịch dispatch là gì, bạn hiểu nôm na rằng, khi code chạy và hàm được gọi, kiểu dữ liệu của các tham số đều sẽ được biết hết, do đó Julia có thể tạo ra một phương thức phù hợp cho kiểu dữ liệu đó, compile nó thành mã máy và chạy. Điều này xảy ra với mọi hàm, bất kể bạn gọi nó ở đâu, do đó, bạn có thể viết hàm mà không cần định kiểu nhưng code vẫn có thể chặt chẽ và nhanh.\nVí dụ như hàm map, hàm này nhận vào 1 hàm f, một mảng xs (không hẳn là mảng, nhưng phần đó sẽ được nói sau), trả về một mảng khác với các phần tử của nó là f(x) với x thuộc xs. Đoạn code dưới đây sẽ chạy ngon lành mặc dù hàm x -\u0026gt; x * ... không có định kiểu.\n1 2  map(x -\u0026gt; x * 1, [1,2,3]) map(x -\u0026gt; x * \u0026#34;!\u0026#34;, [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;])   Định kiểu cho một giá trị Mặc dù tôi nói ở trên bạn có thể viết hàm mà không cần định kiểu, nhưng đôi lúc bạn sẽ cần phải làm chuyện ấy. Một số lý do chúng ta sẽ muốn định kiểu:\n Đưa ra quy tắc, giúp phần mềm của chúng ta sẽ chạy như mong muốn Đưa thêm thông tin cho bộ dịch, có thể cải thiện hiệu năng trong một số trường hợp (nói sau)  Vậy chúng ta làm thế nào để gắn một kiểu dữ liệu vào giá trị? Chúng ta sẽ dùng phép toán :: (\u0026ldquo;phát âm\u0026rdquo;: là một thực thể thuộc \u0026hellip;). Cú pháp:\n1 2 3 4 5  # môt điều tôi thích ở Julia là: # dòng code này hoàn toàn legit :) giá_trị::KiểuDữLiệu 100::Int 100.0::AbstractFloat   Bạn có thể định kiểu cho các biến địa phương. Khi khai báo kiểu cho biến địa phương, mọi giá trị sẽ được ép kiểu với hàm convert trước khi gán vào biến:\n1 2 3 4 5  function() local n::Int8 = 2 n = 10 # ok n = 255 # lỗi vì Int8 không biểu diễn được end   Ngoài ra, bạn cũng có thể định kiểu cho tham số và giá trị trả về của hàm. Tham số sẽ được ép kiểu trước khi chạy và đầu ra sẽ được ép kiểu sau khi trả về (nếu được):\n1 2  f(x::Integer) = x + 1 # ép kiểu tham số x thành Int f(n)::Float32 = sin(n) # ép kiểu đầu ra thành Float32   Kiểu trừu tượng (AbstractType) Trong ví dụ ở trên một kiểu là AbstractFloat, đó chính là một hình ảnh về kiểu trừu tượng (phân biệt với kiểu dữ liệu trừu tượng nhé).\nĐể hiểu về kiểu trừu tượng trong Julia, hãy tưởng tượng một đồ thị có hướng, mỗi nút là một kiểu dữ liệu, và A → B có nghĩa rằng: kiểu B kế thừa mọi hành động từ kiểu A.\nKiểu trừu tượng trong Julia đóng vai trò là một nút phụ trong cái đồ thị trên. Ta có thể gọi một kiểu dữ liệu là kiểu dữ liệu con (subdatatype) của kiểu dữ liệu A nếu nó kế thừa những hành động của A. Một kiểu trừu tượng được định nghĩa bằng cú pháp:\n1  abstract type KiểuA end   Một số ví dụ về kiểu trừu tượng trong Julia là Real, Number, Integer và AbstractArray. Bạn có thể kiểm tra một kiểu cụ thể có thuộc một kiểu trừu tượng không bằng phép toán \u0026lt;: hoặc \u0026gt;:.\n1 2  Int \u0026lt;: Integer # true Real \u0026gt;: Float64 # true   Trong Julia, kiểu dữ liệu trừu tượng cũng có thể đóng vai trò là kiểu con. Mọi kiểu dữ liệu trong Julia là kiểu con của một kiểu trừu tượng là Any. Hãy chạy thử ví dụ dưới đây:\n1 2 3 4  Real \u0026lt;: Number Number \u0026lt;: Any Real \u0026lt;: Any abstract type KiểuB \u0026lt;: KiểuA end   Lưu ý rằng không phải kiểu dữ liệu nào cũng so sánh được, khi đó phép so sánh sẽ mặc định trả về false:\n1 2  Real \u0026lt;: Complex Complex \u0026lt;: Real   Kiểu dữ liệu có tham số Trong Julia, đôi lúc chúng ta thấy những kiểu dữ liệu như sau:\n1 2 3 4 5 6 7 8  julia\u0026gt; typeof([1,2,3]) Array{Int64,1} julia\u0026gt; typeof(1+2im) Complex{Int64} julia\u0026gt; typeof(1+2.0im) Complex{Float64}   Những kiểu dữ liệu như trên gọi là kiểu dữ liệu có tham số (hay parametric type). Phần ở trong cặp dấu {}. Trong trường hợp Array, tham số thứ nhất cho biết Array đó chứa kiểu dữ liệu thuộc loại gì, tham số thứ hai cho biết số chiều của Array đó. Trong trường hợp Complex, tham số cho biết phần thực và phần ảo của số phức thuộc loại gì.\nKhi so sánh kiểu có tham số, cần lưu ý rằng tham số không được đưa vào so sánh, ví dụ:\n1  Array{Int} \u0026lt;: Array{Number} # false   Tạo một kiểu dữ liệu mới Julia hỗ trợ tạo kiểu dữ liệu mới thông qua cú pháp struct hoặc abstract type. Cú pháp abstract type tạo một kiểu trừu tượng, vậy còn struct thì sao?\n1 2 3 4  struct MyDataStruct prop1 prop2::Real end   Cú pháp struct như trên tạo ra một kiểu dữ liệu cụ thể. Cú pháp struct cũng hỗ trợ tham số kiểu:\n1 2 3 4  struct MyDataStruct{T, N} prop1::Array{T, N} prop2::{T} end   Với struct chúng ta có thể định ra một hàm với cùng tên để khởi tạo ra một thực thể của kiểu đó:\n1 2 3 4 5 6 7 8 9  struct MyDataStruct{T} prop1::Matrix{T} prop2::T function MyDataStruct(x) T = typeof(x) arr = rand(T, 3, 3) new{T}(arr, x) end end   Với ví dụ trên ta có thể gọi ra MyDataStruct(3) và chúng ta sẽ có MyDataStruct với thuộc tính đầu tiên là một ma trận ngẫu nhiên có kiểu Int và thuộc tính số hai là 3. Hàm new là một hàm đặc biệt để tạo ra một thực thể mới. Trong trường hợp struct có tham số, new cần được gọi với các tham số kiểu (như ví dụ trên là new{T}).\nMặc định, kiểu dữ kiệu định nghĩa với struct trong Julia không thay đổi được (nguyên văn là immutable, dịch hơi khó). Điều đó nghĩa rằng một khi ta gọi x = MyDataStruct(3) thì các thuộc tính của x không thay đổi được. Để định nghĩa nghĩa ra một kiểu dữ liệu mà có thay đổi được, ta cần dùng thêm từ khóa mutable\n1 2 3  mutable struct MyMutableDataStruct val end   Sau khi tạo x = MyMutableDataStruct(3), chúng ta có thể đổi thuộc tính val bằng cách x.val = 10.\nNgoài ra, kiểu dữ liệu có thể được định nghĩa là kiểu dữ liệu con của một kiểu trừu tượng như sau:\n1 2  abstract type MyAbstractType end struct MyType \u0026lt;: MyAbstractType end   Cuối cùng, bạn có thể đưa một tham số vào một kiểu dữ liệu cụ thể để tạo ra kiểu dữ liệu mới.\n1  ComplexFloat = Complex{Float64}   Kết Bài này nói về khá nhiều thứ. Một số điểm quan trọng là:\n Trong Julia có kiểu dữ liệu con mà kế thừa hành động của kiểu dữ liệu cha (super type) của nó Kiểu dữ liệu có thể có tham số  Ngoài ra một số kiểu dữ liệu còn có bí danh (alias), ví dụ như Int là bí danh có Int32 hoặc Int64, Vector là bí danh của Array{T, 1} where T. Kiểu dữ liệu là một trong những lý do chính mà Julia nhanh, nhưng việc đó để cho bài viết khác. Sau khi biết về hệ thống kiểu dữ liệu, ở bài viết sau chúng ta có thể tìm hiểu về multiple dispatch trong Julia.\n","description":"Nói thêm về hệ thống kiểu dữ liệu trong Julia","id":4,"section":"posts","tags":["julia"],"title":"Julia dojo: nói thêm về kiểu dữ liệu","uri":"https://ndgnuh.github.io/posts/julia-dojo/more-on-types/"},{"content":"Bài viết trước đã giới thiệu về cách dùng cơ bản của LyX. Tuy nhiên, vì cách mà LaTeX hoạt động, chúng ta chưa thể tạo được một văn bản tiếng Việt ngay được. Bài viết này sẽ trình bày những cách để tạo văn bản tiếng Việt trong LyX.\nSử dụng PDFLatex Khi dùng pdflatex, những gói LaTeX bổ trợ cần phải được sử dụng khi muốn gõ tiếng Việt. Cụ thể hơn, có hai gói thường hay sử dụng, đó là vntex và babel.\nVới VNTex Nếu hệ điều hành hỗ trợ phân phối cả những gói của LaTeX, gói vntex thường được phân phối qua một gói ngôn ngữ, vĩ dụ như trên Arch Linux thì nó nằm đâu đó trong gói texlive-langextra (xem tại đây). Nếu hệ điều hành không phân phối gói của LaTeX, bạn có thể sử dụng trình quản lý gói của TeXLive để cài đặt:\n# giả sử texlive được cài đặt đúng cách # chạy cái này trong terminal hoặc cmd tlmgr install vntex Nèu vì một lý do nào đó mà bạn không có quyền ghi vào thư mục cài đặt, hãy dùng --usermode để cài đặt riêng cho người dùng của mình\nSau khi cài đặt xong, hãy mở văn bản của bạn trên lyx, ấn tổ hợp phím Alt + D, sau đó nhấn S (hoặc dùng chuột click vào Document \u0026gt; Settings).\nClick vào phần preamble ở góc dưới bên trái. Sau đó viết vào vùng trắng ở bên cạnh:\n1  \\usepackage[utf8]{vietnamese}   Tiếp theo, hãy mở phần Language và chỉnh ngôn ngữ thành Vietnamese (như trong hình)\nSau đó nhấn Apply (Alt + A) và văn bản này sẽ compile bình thường.\nVới Babel Để dùng Babel bạn cần phải có gói babel-vietnamese\ntlmgr install babel-vietnamese Phương pháp với Babel thì không cần phải cài đặt thủ công phần preamble như trên. Bạn chỉ cần vào phần cài đặt văn bản (Alt + D, S), sau đó qua phần language và chỉnh ngôn ngữ thành Vietnamese.\nPhần encoding bạn có thể chọn: Language default, Unicode (ucs - extended) (utf8x) hoặc Unicode (XeLaTeX). Tuy nhiên bạn với hai tùy chọn đầu bạn có thể sẽ phải cài thêm gói ucs từ LaTeX.\ntlmgr install ucs Sử dụng XeLaTeX, LuaLaTeX Compile tiếng Việt với hai TeX engine này khá đơn giản. Trong cài đặt văn bản, hãy nhấn vào phần Font và đánh dấu ô Use non-Tex fonts như trong ảnh.\nBạn có thể tiếp tục dùng font mặc định của LaTeX hoặc sử dụng một font trên máy bạn. Với LuaLaTeX, nếu bạn gặp lỗi về font, hãy cài gói luaotfload. Gói này cần cho việc load font của LuaLaTeX.\ntlmgr install luaotfload # cập nhật lại hệ thống load font luaotfload-tool --update Trong LuaLaTeX, có một lỗi khiến cho font Latin Modern Roman (font mặc định) không thể tìm thấy được (hên xui gặp phải). Cách xử lý là bạn cài gói lm (đề phòng trường hợp bạn chưa có font này)\ntlmgr install lm Nếu việc compile vẫn lỗi. Hãy vào thư mục cài đặt font Latin Modern Roman của LaTeX (\u0026lt;thư mục cài LaTeX\u0026gt;/texmf-dist/fonts/opentype/public/lm/) và cài đặt những font đó lên máy bạn. Trên *Nix bạn chỉ cần symlink thư mục đó tới /usr/share/fonts/ (trong ví dụ sẽ symlink toàn bộ thư mục font của LaTeX vào hệ thống)\n1 2 3 4  # cả hệ thống ln -s $(realpath \u0026lt;thư mục LaTeX\u0026gt;/texmf-dist/fonts/) /usr/share/fonts/LaTeX # một người dùng ln -s $(realpath \u0026lt;thư mục LaTeX\u0026gt;/texmf-dist/fonts/) ~/.local/share/fonts/LaTeX   Cuối cùng, trong phần cài đặt, chuyển sang phần Format và chọn Output Format là Pdf (LuaLaTeX) hoặc Pdf (XeLaTeX) theo ý muốn của bạn.\nLưu lại thay đổi cho văn bản sau này Nếu bạn phải làm việc với văn bản tiếng Việt thường xuyên, việc phải chỉnh Language mỗi khi viết văn bản mới sẽ rất bất tiện. LyX cung cấp chức năng lưu lại những tùy chọn của bạn và dùng nó cho những văn bản mới. Để làm việc này, bạn chỉ cần vào cài đặt văn bản (Alt + D, S), sau đó nhấn Save as document defaults. Những văn bản bạn tạo ra sau đó sẽ mặc định có những tùy chọn như bạn đã thiết lập.\nKết luận Đến đây thì việc build một văn bản tiếng Việt trong LyX không còn là vấn đề. Các bộ gõ tiếng Việt cũng hoạt động khá tốt trên LyX. Riêng với người dùng *Nix, nếu bạn dùng Ibus Unikey, chế độ preedit có thể hơi khó chịu một chút vì phải commit trước khi dùng phím tắt. Theo tôi, cách ổn nhất là dùng Ibus Bamboo, hãy chuyển sang chế độ 5 (forward as commit), vừa có thể gõ rất ổn và vừa có thể dùng được phím tắt.\nNếu bạn muốn tìm hiểu thêm về tiếng Việt trong LaTeX thì có thể tham khảo bài viết http://vntex.sourceforge.net/doc/vn-fonts.html\n","description":"","id":5,"section":"posts","tags":["linux","foss","lyx","latex","tex"],"title":"Lyx và văn bản tiếng Việt","uri":"https://ndgnuh.github.io/posts/lyx-tieng-viet/"},{"content":"LyX là gì? Trình xử lý văn bản LyX là sự kết hợp tuyệt vời giữa LaTeX và một giao diện đồ hoạ. Nếu bạn không biết LaTeX cũng đừng lo, dù kiến thức về LaTeX sẽ hữu dụng để dùng LyX, bạn không cần phải là một chuyên gia LaTeX để dùng LyX, thậm chí có thể vừa dùng LyX vừa học LaTeX. Thực tế, LyX có giao diện làm việc hơi hơi giống microsoft words (nhưng cách làm việc khác hoàn toàn nhé):\nLyX sử dụng LaTeX làm backend và do đó hoạt động theo nguyên lý What You See Is What You Mean (WYSIWYM). Hiểu một cách đơn giản là các khối văn bản được \u0026ldquo;phân loại\u0026rdquo; tùy theo mục đích của chúng. Điều này - theo tôi - tốt hơn rất nhiều so với What You See Is What You Get (WYSIWYG) như MS Words, Libreoffice Writer và một số trình xử lý văn bản khác. Bài viết này sẽ giới thiệu sơ qua về cách cài đặt và sử dụng LyX.\nCài đặt LyX LyX là một phần mềm tự do mã nguồn mở giấy phép GPL-2.0. Điều đó có nghĩa rằng bạn có thể quyền sử dụng, sửa đổi và tái phân phối LyX mà không tốn một đồng nào mua bản quyền như những phần mềm thương mại. Để tải LyX hãy truy cập vào trang Web sau: https://www.lyx.org/Download sau đó chọn file cài đặt phù hợp với hệ điều hành của mình. Nếu dùng *Nix bạn có thể cài đặt qua trình quản lý gói của mình cho tiện.\nLưu ý rằng để sử dụng LyX bạn cần phải có một bản phân phối LaTeX đang hoạt động trên máy. Tôi khuyến cáo dùng TeXLive vì nó khá phổ biến nên dễ google lỗi hoặc những vấn đề về gói. Những bài viết này cũng sẽ sử dụng TeXLive. Bạn có thể tải nó tại đây, hoặc dùng package manager để cài đặt.\nBạn cũng có thể sẽ cần phải cài thêm Python 2 (việc nâng câp lên Python 3 đang được thực hiện) và Qt4.8 hoặc Qt5.6. Nếu bạn dùng package manager thì khả năng cao bạn không cần phải lo về việc này. Nếu bạn dùng bộ cài cho Windows hay Mac cũng đừng lo quá vì có thể hai cái này sẽ được bundle cùng với bộ cài. Nếu bạn vẫn gặp vấn đề thì hãy thử:\n cài đặt Python 2 trước nếu LyX vẫn không khởi chạy hãy cài Qt  Sử dụng cơ bản Mở LyX lên lần đầu tiên bạn sẽ nhận được giao diện như trong hình. Hãy nhấn Ctrl + n để tạo một file mới, hoặc Ctrl + o để mở một file có sẵn. Tôi sẽ giả định rằng bạn tạo một văn bản mới.\nHãy gõ hello world và nhấn Ctrl + r. Nếu bạn cài đặt LyX đúng cách và có một trình xem pdf thì một file pdf hiện ra với dòng chữ \u0026ldquo;hello world\u0026rdquo;.\nLyX đã đưa phần văn bản bạn nhập vào và tạo ra file pdf xem trước cho bạn, mà không cần những thứ khai báo lằng nhằng ở LaTeX. Giờ hãy quay lại LyX. đưa con trỏ tới cuối dòng và nhấn Ctrl + m. Bạn sẽ thấy một cái hộp nhỏ hiện ra, hãy gõ \\lim_n\\to\\infty x_n  (để ý dấu cách).\nCông thức toán hiện ra rất dễ nhìn trong hộp thoại. Đây cũng chính là một trong những điểm khác biệt của LyX so với những front-end khác của LaTeX. Không những công thức toán mà tất cả những lệnh trong môi trường toán của LaTeX đều được hỗ trợ (một số lệnh đặc biệt sẽ được dùng hơi khác). Tiếp theo hãy nhấn Ctrl + Shift + r, chuyển qua trình xem pdf lúc nãy và dùng refresh trình xem pdf của bạn (tôi không biết bạn dùng cái gì), bạn sẽ sẽ thấy file pdf được update (cách làm cho việc update xảy ra tự động sẽ nói sau).\nGiờ hãy quay lại LyX. Hãy nhấn Ctrl + s để lưu file của bạn lại. Lưu ý rằng lưu file sẽ tạo ra file lyx thay vì file pdf, nếu bạn muốn file pdf, hãy click vào file \u0026gt; export và chọn định dạng bạn mong muốn.\nKết luận Đây chỉ là một trong những cái nhìn đầu tiên về LyX (như một trình xử lý văn bản dễ dùng). Hiện tại chúng ta đã biết\n Ctrl + n tạo mới Ctrl + o mở văn bản LyX Ctrl + s lưu văn bản LyX Ctrl + r chế độ xem trước Ctrl + Shift + r update xem trước file \u0026gt; export xuất ra file pdf (hoặc định dạng khác)  Với LyX chúng ta sẽ có thể tạo ra những văn bản (mang tính kĩ thuật hoặc không) rất nhanh chóng và đẹp (báo cáo, viết sách, ghi bài, đồ án\u0026hellip; làm được hết). Tuy nhiên tới đây bài viết cũng khá dài (và đây là một bài viết mang tính giới thiệu) nên những tính nay hay ho của LyX sẽ được trình bày trong những bài viết sau.\nEdit: Nếu bạn thử gõ tiếng Việt và LyX báo lỗi thì đừng lo, đây là do LaTeX chứ không phải LyX. Việc gõ tiếng Việt hoàn toàn khả thi và rất dễ thôi, nhưng mình sẽ nói trong bài viết khác.\nEdit: Để sử dụng đầy đủ những tính năng trong LyX, bạn cần có một số gói LaTeX như sau, hãy dùng lệnh ở dưới để cài chúng (mình sẽ cố lọc ra gói nào dùng cho việc gì ở bài viết sau):\ntlmgr install algorithm2e algorithms apacite bbding bezos bibtopic tlmgr install breakurl covington csquotes diagbox endnotes enumitem tlmgr install epstopdf esint eurosym feyn fragments framed frankenstein tlmgr install harvard hyphenat jurabib lettrine luainputenc marginnote tlmgr install mathdesign mathdots mhchem multirow nicefrac nomencl tlmgr install picinpar pict2e prettyref preview rotfloat rsfs shapepar tlmgr install sidecap splitindex symbol tex-gyre ulem units wasy wasysym tlmgr install wrapfig xargs ","description":"","id":6,"section":"posts","tags":["linux","foss","lyx","latex","tex"],"title":"LyX: trình sửa văn bản WYSIWYM","uri":"https://ndgnuh.github.io/posts/lyx-tex-editor/"},{"content":"Hello friend. Nếu bạn đã sử dụng bất kì hệ điều hành Unix based (Linux, BSD), bạn rất có thể đã gặp khá nhiều vấn đề trong việc gõ tiếng Việt. Đặc biệt nếu bạn gõ telex và những công cụ của bạn sử dụng phím tắt bàn phím như Vim.\nVấn đề Nếu bạn đang xem bài viết này, khả năng là bạn đã quen sử dụng Vim rồi nên mình cũng chẳng giới thiệu về Vim làm gì. Vấn đề chủ yếu mình gặp phải khi gõ tiếng Việt với Vim là:\n Chế độ Preedit (ibus-unikey) vốn rất khó chịu rồi, khi trong chế độ normal mà không tắt tiếng Việt thì sẽ luôn phải nhấn một phím nào đó để commit, thậm chí phải thêm 1 lần nhấn nữa để bỏ dấu Chế độ gõ không dùng preedit trong bọ gõ ibus-bamboo đã xử đẹp thằng unikey, tuy nhiên bạn vẫn phải nhấn thêm 1 lần nữa để bỏ dấu, ví dụ như thay cho dd thì bạn phải nhấn ddd, vì dd sẽ chỉ gửi chữ đ thẳng vào terminal của bạn (theo mình biết là vậy). Một số chế độ khác của Bamboo sửa được cái đó, nhưng việc gõ tiếng Việt trong chế độ đó lại bị lỗi. Terminal với nhập liệu bị trễ, mình gặp với alacritty.  Trong bài viết này, chúng ta sẽ bàn bạc cách xử lý những vấn đề trên\nXử lý Thực chất vấn đề với nhập liệu không phải vấn đề riêng của các bộ gõ tiếng Việt, nó là một vấn đề chung với người dùng Vim. Nhưng khi quan sát, bạn nhận ra rằng gõ tiếng Việt hoàn toàn vô dụng, thậm chí gây khó chịu khi bạn không ở trong insert mode của Vim. Để giải quyết vấn đề này chúng ta có thể dùng một trong ba cách dưới đây:\nCách 1 là không dùng IBus, dùng keymap của Vim. Nếu bạn dùng Neovim hay vì một lý do nào đó mà bạn không có file keymap thì có thể tải nó tại thư mục nay, copy thư mục config của Vim với đường dẫn runtime/keymap/. Và thêm dòng này trong config của bạn:\n1 2  \u0026#34; thay telex bằng VNI và VIQRset keymap=vietnamese-telex  Cách này khá ổn nếu bạn phải làm việc qua ssh và server không có IBus. Tuy nhiên bạn sẽ phải gõ chính xác từng kí tự, nếu không thì nó sẽ không hoạt động (chữ â yêu cầu phải gõ 2 chữ a liên tiếp, danga sẽ không tạo ra dâng). Vì lí do đó, nếu bạn dùng cho mục đích cá nhân, mình recommend 2 cách ở dưới\nCách 2 là dùng Vim barbaric. Đây là một plugin giúp bạn chuyển IBus về tiếng Anh khi bạn không ở trong insert mode. Nó được thiết kế để có thể hoạt động ngay khi cài xong. Chi cần thêm nó với trình quản lý gói Vim của bạn (Mình dùng Plug, nó khá đơn giản và nhẹ):\n1  Plug \u0026#39;rlue/vim-barbaric\u0026#39;  Tuy nhiên, plugin này vẫn chưa thỏa mãn mình lắm.\n Dùng 1 plugin để thực hiện chức năng như trên có vẻ hơi overkill (lí do khá\nchủ quan :v) Khi vào search mode plugin không tự chuyển sang gõ tiếng Việt cho bạn  Vì hai lý do trên, mình viết một giải pháp gọn nhẹ của riêng mình - Cách 3 - autocmd và giao diện dòng lệnh của IBus. Đầu tiên chúng ta cần có tính năng tắt IBus và lưu engine mà chúng ta đang dùng lại. Chúng ta có thể dùng ibus engine để lấy ra tên của engine hiẹn tại và ibus engine \u0026lt;tên engine\u0026gt; để sử dụng một IBus engine:\n1 2 3 4 5 6 7 8 9  function! IBusOff()\u0026#34; Lưu engine hiện tại\tlet g:ibus_prev_engine = system(\u0026#39;ibus engine\u0026#39;)\u0026#34; Chuyển sang engine tiếng Anh\u0026#34; Nếu bạn thấy cái cờ ở đây\u0026#34; khả năng là font của bạn đang render emoji lung tung...\u0026#34; xkb : us :: eng (không có dấu cách)\texecute \u0026#39;silent !ibus engine xkb🇺🇸:eng\u0026#39;endfunction  Tiếp theo chúng ta cài đặt tính năng để sử dụng lại engine đã được lưu:\n1 2 3 4 5 6 7 8 9 10  function! IBusOn()\tlet l:current_engine = system(\u0026#39;ibus engine\u0026#39;)\u0026#34; nếu engine được set trong normal mode thì\u0026#34; lúc vào insert mode duùn luôn engine đó\tif l:current_engine !~? \u0026#39;xkb🇺🇸:eng\u0026#39;\tlet g:ibus_prev_engine = l:current_engine\tendif\u0026#34; Khôi phục lại engine\texecute \u0026#39;silent !\u0026#39; . \u0026#39;ibus engine \u0026#39; . g:ibus_prev_engineendfunction  Cuối cùng chúng ta cài autocmd để Vim tự động kích hoạt các tính năng trên:\n1 2 3 4 5 6 7 8 9 10 11  augroup IBusHandler\u0026#34; Khôi phục ibus engine khi tìm kiếm\tautocmd CmdLineEnter [/?] silent call IBusOn()\tautocmd CmdLineLeave [/?] silent call IBusOff()\tautocmd CmdLineEnter \\? silent call IBusOn()\tautocmd CmdLineLeave \\? silent call IBusOff()\u0026#34; Khôi phục ibus engine khi vào insert mode\tautocmd InsertEnter * silent call IBusOn()\u0026#34; Tắt ibus engine khi vào normal mode\tautocmd InsertLeave * silent call IBusOff()augroup END  Cái này là tùy chọn, nhưng nếu bạn muốn IBus được tắt khi vào Vim, bạn có thể\nthêm dòng sau:\n1  silent call IBusOff()  Chúng ta cần có silent để trong trường hợp IBus sập (IBus theo mình không ổn định lắm, rất hay lỗi\u0026hellip;), Vim sẽ không ném một đống thứ linh tinh vào mặt bạn. Đương nhiên, giấu lỗi đi nghe không hay lắm, nhưng nếu dùng những thứ như ps và grep để kiểm tra thì CPU sẽ không chịu được nhiệt.\nOk, vậy chúng ta đã làm IBus hoạt động ngon lành trong Vim. Nhưng vẫn có vấn đề, một trường hợp hi hữu như sau: Bạn ở trong Normal Mode, bạn quay ra phần mềm khác (trình duyệt chẳng hạn), bật gõ tiếng Việt lên, và quay lại Vim.\nĐể xử lý vấn đề này, IBus có một tính năng là dùng input method riêng cho mỗi cửa sổ. Bạn chỉ cần chạy ibus-setup, chuyển sang tab advanced, bỏ dấu ở phần share the same input method among applications. Tuy nhiên, tính năng này theo mình không ổn định lắm. Có thể ở những phiên bản sau của IBus họ đã fix lỗi nên mình dùng chưa thấy sập hay gì, nhưng có những distro sử dụng mô hình stable release khiến cho việc update phần mềm có thể bị chậm.\nNgoài ra, nếu bạn dùng AwesomeWM bạn cũng có thể cài đặt một signal để nhận biết khi nào focus/unfocus cửa sổ có Vim để giải quyết vấn đề trên.\nTổng kết Gõ tiếng Việt với Vim:\n hoặc không dùng IBus, dùng Vim keymap tắt IBus khi thoát Insert Mode  Dùng plugin Dùng code mình share ở trên Tắt chế độ share input method của IBus    Vấn đề terminal bị trễ nhập liệu rất tiếc mình không xử lý được (nó là bug trên upstream của terminal). Cách xử lý đơn giản nhất là dùng 1 terminal khác. Một số gợi ý của mình (mình đã dùng qua và thấy gõ tiếng Việt OK):\n Termite (cái này hơi khó kiếm trên 1 số distro) URxvt QTerminal Xfce4-terminal  Gõ tiếng Việt vui vẻ :v\n","description":"","id":7,"section":"posts","tags":["linux","foss"],"title":"Gõ tiếng Việt và Vim","uri":"https://ndgnuh.github.io/posts/ibus-and-vim/"},{"content":"Chào các bạn trở lại với Julia Dojo, trong bài viết này, mình sẽ hướng dẫn về một số các kiểu dữ liệu dưới dạng tập hợp, Dict (từ điển), Set (tập hợp)\nTừ điển Trong Julia có rất nhiều kiểu từ điển, nhưng hai kiểu mình thấy hay gặp nhất là Dict và ImmutableDict. Từ điển sẽ tạo một bảng băm để ta \u0026ldquo;chiếu\u0026rdquo; các giá trị, cú pháp để làm việc với từ điển Dict như sau:\n1 2 3 4 5 6 7 8  d = Dict( 1 =\u0026gt; \u0026#34;số một\u0026#34;, 2 =\u0026gt; \u0026#34;số hai\u0026#34;, 10 =\u0026gt; \u0026#34;số mười\u0026#34;) d[1] # lấy ra giá trị d[3] = \u0026#34;abc\u0026#34; # thêm một giá trị vào từ điển keys(d) # lấy ra các khóa values(d) # lấy ra các giá trị   Kiểu từ điển có hai tham số kiểu: Dict{K, V}, trong đó K là kiểu của khóa, V là kiểu của giá trị trỏ bởi khóa đó. Bạn có thể định kiểu một cách tường minh cho từ điển:\n1 2 3  d = Dict{String, Number}() d[\u0026#34;thực\u0026#34;] = 1.0 d[\u0026#34;ảo\u0026#34;] = 1+2im   Ngoài ra, các bạn có thể \u0026ldquo;thu thập các giá trị của từ điển để tạo thành một mảng gồm các cặp (Pair), hoặc lặp qua một từ điểm trong một vòng lặp:\n1 2 3 4  collect(d) # thu thập for (k,v) in d println(\u0026#34;khóa $k: giá trị $v\u0026#34;) end   Đối với ImmutableDict cách làm việc hơi khác một chút so với Dict. Immutable nghĩa là bạn sẽ không thể chỉnh sửa nó được, do đó chúng ta không thể:\n thêm khóa xóa một khóa  ImmutableDict được cài đặt như một danh sách liên kết, vậy nên nó sử dụng nó sẽ hiệu quả hơn khi bạn cần thêm liên tục. Nghe nghịch lý vì chúng ta không thể thay đổi được ImmutableDict, nhưng thực chất nó sẽ tạo một từ điển mới mỗi lần ta thêm khóa:\n1 2 3  ImmutableDict = Base.ImmutableDict # không nằm sẵn trong global scope d = ImmutableDict(:a =\u0026gt; 1) # trả về một từ điển mới, với 1 khóa d = ImmutableDict(d, :b =\u0026gt; 1) # trả về một từ điển mới, vởi 2 khóa   Ngoài những điều trên ra, bạn vẫn có thể thực hiện các thao tác giống như Dict một cách bình thường\nTập hợp Tập hợp là kiểu được cài đặt giống với định nghĩa toán học tương ứng. Đây là kiểu dữ liệu khá đơn giản nên mình chỉ giới thiệu cú pháp sử dụng thôi:\n1 2 3 4 5 6 7 8 9 10 11  s1 = Set([1, 2, 3]) s2 = Set([3, 3, 4, 5, 6]) # sẽ tự bỏ phần tử trùng s1 ∪ s1 # hợp, viết bằng cách \\cup\u0026lt;tab\u0026gt; s1 ∩ s2 # giao, viết bằng cách \\cap\u0026lt;tab\u0026gt; setdiff(s1, s2) # hiệu tập hợp s1 \\ s2 for x in s1 @show x end # lặp qua tập hợp filter(x -\u0026gt; x \u0026lt; 3, s1) # lọc phần tử filter(s1) do # cũng là lọc phần tử x \u0026lt; 3 end collect(s1) # đưa thành mảng   Tạm kết Ok, bài này mình sẽ kết thúc ở đây. Qua bài này chúng ta đã biết cách thao tác với từ điển và tập hợp. Ngoài ra, bạn có thể tham khảo thêm các kiểu từ điển khác như IdDict hay WeakKeyDict tại tài liệu chính thức của Julia. Hẹn gặp lại các bạn torng những bài viết sau.\n","description":"","id":8,"section":"posts","tags":["julia"],"title":"Julia Dojo: từ điển \u0026 tập hợp","uri":"https://ndgnuh.github.io/julia-dojo/tu-dien-va-tap-hop-trong-julia/"},{"content":"Chào mừng mọi người quay trở lại Julia Dojo. Trong level trước mình đã cover kha khá những cú pháp cơ bản trong Julia. Nhưng mọi người có nhận ra rằng, mình chưa nói về cách để nhập dữ liệu?\nNếu bạn được học C trên trường (nếu không học cũng không sao), chắc hẳn bạn đã được dạy cách nhập tay một dữ liệu bằng hàm scanf. Trong Julia, bạn cũng có thể làm điều tương tự với hàm readline. Nhưng, nếu chúng ta cần đưa vào xử lí những dữ liệu cồng kềnh (không nhất thiết lớn), việc nhập từ tay trở nên không thực dụng. Khi ấy, chúng ta sẽ phải làm việc với file.\nLưu và nạp dữ liệu Đóng mở file Để mở một file trong Julia, chúng ta dùng hàm open. Hàm này sẽ trả về một con trỏ file\n1 2  io = open(\u0026#34;đương dẫn tới file\u0026#34;) io = open(\u0026#34;đương dẫn tới file\u0026#34;, \u0026#34;mode\u0026#34;)     Các giá trị của mode   \u0026quot;r\u0026quot;: đọc \u0026quot;w\u0026quot;: ghi, tạo mới, cắt bớt \u0026quot;a\u0026quot;: ghi, tạo mới, ghi thêm \u0026quot;r+\u0026quot;: đọc, ghi \u0026quot;w+\u0026quot;: đọc, ghi, tạo, cắt bớt \u0026quot;a+\u0026quot;: đọc, ghi, tạo, ghi thêm  Đừng lo lắng quá về các chế độ mở file. Theo mình, trong đa số trường hợp, bạn không cần quan tâm lắm về cái này.    Sau khi làm việc với file xong, đừng quên đóng nó lại:\n1  close(io)   Ngoài ra, bạn có thể dùng cú pháp do:\n1 2 3 4  open(\u0026#34;đường dẫn file\u0026#34;, mode) do # làm gì đó với file # file sẽ được tự động đóng end   Nhưng làm việc với file kiểu gì?\nFile văn bản Sau khi mở một file văn bản, bạn có thể tiến hành đọc từ file đó bằng hàm read hoặc readline để đọc từng dòng.\n1 2 3 4 5 6 7 8  read(io) # đọc đến hết dưới dạng kí tự read(io, String) # đọc đến hết dưới dạng xâu read(io, Char) # đọc kí tự tiếp theo while !eof(io) # đọc 1 dòng # keep = true thì giữ kí tự xuống dòng @show readline(io; keep = false) end   Lưu ý rằng, việc đọc file sẽ đẩy con trỏ file của bạn. Nếu bạn không biết con trỏ file là gì, hãy hiểu đơn giản rằng: nó đánh dấu vị trí bạn bắt đầu đọc. Để quay lại vị trí ban đầu, chúng ta dùng các hàm seek:\n1 2 3  seekstart(io) # quay con trỏ file lên đầu seek(io, i) # quay con trỏ file đến vị trí i seekend(io) # đưa con trỏ file xuống vị trí cuối (eof)   Việc đọc file không phải do Julia xử lí, vị trí của con trỏ file cũng không giống với đánh chỉ số trong Julia. Nói cách khác, vị trí đầu tiên của con trỏ file là 0, không phải 1.  Để ghi một file, chúng ta phải mở file theo những chế đọc cho phép ghi (xem bảng trên). Sau đó:\n1  write(io, \u0026#34;Hello world\u0026#34;);   Việc ghi vào file không thực sự ghi vào ổ đĩa nơi chứa file, nó chỉ lưu vào một vùng đệm thôi. Việc ghi vào ổ đĩa sẽ xảy ra khi bạn đóng file.\nHãy cẩn thận, nếu dùng chế độ w hoặc w+, file của bạn sẽ bị xóa sạch để ghi lại từ đầu.  Ngoài ra, trong một số trường hợp, bạn muốn đọc toàn bộ file hoặc ghi đè toàn bộ file, chúng ta có thể không cần mở, đóng file mà dùng trực tiếp read với write luôn:\n1 2  read(\u0026#34;tên file\u0026#34;, String) write(\u0026#34;tên file\u0026#34;, \u0026#34;Hello world\u0026#34;)   Ma trận Trong Julia thì có muôn vàn cách để đọc, ghi ma trận ra ổ cứng. Bạn có thể dùng file văn bản (CSV chẳng hạn), file Excel, file của Matlab, file của Python và thậm chí cả những định dạng riêng của Julia nữa.\nCách đơn giản nhất để lưu ma trận là một file văn bản. Julia cũng cấp một module tiêu chuẩn tên là DelimitedFiles, dùng để đọc và ghi những file dữ liệu được ngăn cách, chẳng hạn như file mat.csv dưới đây:\n1 2  3, 3.3, 1.0 0.8, 1.9, 3.2   Chúng ta dùng DelimitedFiles để đọc file trên thành ma trận một cách dễ dàng:\n1 2 3 4 5  using DelimitedFiles # đọc file mat.csv thành ma trận # sử dụng dấu \u0026#39;,\u0026#39; để ngăn cách # ép kiểu phần tử ma trận ra vào thành Float32 readdlm(\u0026#34;mat.csv\u0026#34;, \u0026#39;,\u0026#39;, Float32)   Để ghi một ma trận ra file thay vì dùng \u0026ldquo;read\u0026rdquo;, chúng ta dùng \u0026ldquo;write\u0026rdquo;:\n1 2 3 4 5 6  # Ma trận tạo ngẫu nhiên số phức cỡ 3 × 3 A = rand(ComplexF32, 3, 3) # Ghi ma trận A ra file mat.txt # dùng dấu \u0026#39;,\u0026#39; để ngăn cách # mặt định là kí tự \\t writedlm(\u0026#34;mat.txt\u0026#34;, A, \u0026#39;,\u0026#39;)   Sử dụng tên file sẽ ghi đè hoàn toàn file cũ. Nếu bạn muốn viết tiếp vào file hiện có, bạn có thể dùng lệnh open như ở trên với mode \u0026quot;a\u0026quot;, sau đó thay tên file trong những hàm trên bằng con trỏ file.  Ưu điểm của cách này là nó rất dễ, nhưng:\n cách này không lưu lại kiểu dữ liệu của ma trận (chẳng hạn mình có một ma trận nhưng ma trận này không chứa số) chậm: ví dụ chỉ lấy ma trận vuông kích cỡ 3 nên điều này không thể hiện rõ lắm.  Vậy chúng ta dùng cách nào để lưu? Cách đơn giản thứ 2 là dùng file .npy (file ma trận của Numpy). Để làm điều này chúng ta cần có gói Pycall. PyCall cung cấp giao diện giá đơn giản để chúng ta thao tác với Numpy.\n1 2 3 4 5 6 7 8  # lôi thằng numpy ra using PyCall numpy = pyimport(numpy) # tạo ma trận random M = rand(10000, 10000) # ghi và đọc file ma trận numpy.save(\u0026#34;mat.npy\u0026#34;, M) numpy.read(\u0026#34;mat.npy\u0026#34;)   Việc đọc/ghi file ma trận với ma trận M như trên sẽ chỉ mất khoảng 1 giây. Còn với DelimitedFiles chúng ta sẽ mất kha khá thơi gian. Nếu bạn cần đọc file .csv hãy dùng gói CSV.jl hoặc DataFrames.jl.\nNgoài ra, chúng ta có thể dùng file ma trận của Matlab với gói MAT.jl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  using MAT # mở file dữ liệu matlab io = matopen(\u0026#34;data.mat\u0026#34;) # tạo ma trận random, lưu vào file matlab M = rand(10000, 10000) # lưu biến Julia M vào thành biến matlab matM write(io, \u0026#34;matM\u0026#34;, M) # hoặc matwrite(\u0026#34;data.mat\u0026#34;, Dict(\u0026#34;matM\u0026#34; =\u0026gt; M); compress = true) # đọc 1 biến từ file Matlab names(io) # lấy ra những tên biến Matlab M = read(io, \u0026#34;matM\u0026#34;) # đọc biến matM trong file # đọc tất cả biến Matlab vars = matread(\u0026#34;data.mat\u0026#34;) # trả về một từ điển   Lưu trữ vạn năng Ở trên mình có nói chúng ta có thể lưu ma trận theo \u0026ldquo;định dạng riêng của Julia\u0026rdquo;. Thực ra có một vài, không chỉ một định dạng, trong đó khá nổi bật là hai định dạng của JuliaDB và JLD2.\nCả hai định dạng file trên đều rất nhanh và tiện lợi để dùng. Không những lưu được số, chữ hay những kiểu dữ liệu nguyên thủy, hai anh này còn lưu được gần như tất cả các loại dữ liệu trong Julia, kể cả dữ liệu người dùng định nghĩa.\nJuliaDB thiên về lưu trữ cơ sở dữ liệu nhiều hơn (lưu các bảng dữ liệu), mình sẽ không nói thêm. Các bạn tự tìm hiểu nhé!  JLD2 cung cấp hai macro để tiện lưu, nạp dữ liệu:\n1 2 3 4 5  hello = \u0026#34;world\u0026#34; foo = :bar # lưu dữ liệu @save \u0026#34;data.jld2\u0026#34; hello foo @load \u0026#34;data.jld2\u0026#34; hello foo   Cách trên không tiện lắm vì chúng ta không đổi được tên của các biến được lưu hay nạp, đồng thời chúng ta cũng không thể ghi thêm hay gì khác. Thay vào đó, chúng ta có thể mở file .jld2 và tạo con trỏ file như những loại file khác.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # lưu dữ liệu # tạo file mới để ghi vào jldopen(\u0026#34;data.jld2\u0026#34;, \u0026#34;w\u0026#34;) do file # lưu giá trị \u0026#34;warudo\u0026#34; với nhãn \u0026#34;hello\u0026#34; trong file file[\u0026#34;hello\u0026#34;] = \u0026#34;warudo\u0026#34; # hoặc write(file, \u0026#34;Hello\u0026#34;, \u0026#34;warudo\u0026#34;) end # nạp dữ liệu za = jldopen(\u0026#34;data.jld2\u0026#34;) do file # in ra tên các \u0026#34;biến\u0026#34; có trong file @show keys(file) # nạp lại giá trị của nhãn \u0026#34;hello\u0026#34; read(file, \u0026#34;Hello\u0026#34;) # hoặc file[\u0026#34;hello\u0026#34;] end @show za   Ngoài ra, có một gói mang tên FileIO.jl, gói này cung cấp giao diện để mở và làm việc kha khá nhiều loại file. JLD2 cũng được hỗ trợ:\n1 2 3  using FileIO save(\u0026#34;data.jld2\u0026#34;, Dict(\u0026#34;hello\u0026#34; =\u0026gt; :friend)) goodbye = load(\u0026#34;data.jld2\u0026#34;, \u0026#34;hello\u0026#34;)   Lưu ý rằng FileIO không trực tiếp mở file mà phải sử dụng một gói khác hỗ trợ. Bạn vẫn cần JLD2 để làm việc với file .jld2.\nĐiều hay nhất của JLD2 và FileIO là, khi bạn lưu, thông tin về kiểu dữ liệu của bạn cũng sẽ được lưu. Khi nạp lại để sử dụng, chúng ta không cần xử lí thêm về kiểu.\nKiểu file dữ liệu khác Ngoài ra chúng ta còn có những kiểu dữ liệu phức hợp khác được lưu dưới dạng file. Mình sẽ chỉ nêu tên gói, các bạn sẽ tự tìm hiểu nhé:\n   Kiểu dữ liệu Các gói liên quan     npy, pickle PyCall.jl   XML EzXML.jl, XMLDict.jl, LightXML   Excel ExcelFiles.jl, ExcelReaders.jl   JSON JSON.jl   BSON BSON.jl   HDF5 HDF5.jl   Một số file âm thanh LibSndFile.jl, MP3.jl, WAV.jl   File ảnh Images.jl   Arrow, Feather Feather.jl, Arrow.jl    Làm việc với hệ thống file Các hệ điều hành thường sử dụng các hệ thống file các nhau. Cụ thể hơn, chúng ta thường phải quan tâm về cách tương tác vì chúng ta là người dùng. May thay, Julia cung cấp một giao diện chung để tương tác với hệ thống file khác nhau, giúp chúng ta tập trung vào những việc khác. Mình sẽ giới thiệu một số hàm mình nghĩ rằng hữu dụng.\nĐường dẫn tới thư mục hiện tại.\n1  pwd()   Đường dẫn tới thư mục/file tạm thời tương ứng với mỗi hệ điều hành.\n1 2  tempdir() tempname()   Chuyển tới một thư mục.\n1  cd(\u0026#34;đường dẫn\u0026#34;)   Ghép các đường dẫn, hàm này dùng để xử lý sự khác biệt giữa hệ thống file của Windows và *Nix.\n1 2 3  joinpath(\u0026#34;dir\u0026#34;, \u0026#34;subdir\u0026#34;, \u0026#34;file\u0026#34;) # trả về \u0026#34;dir/subdir/file\u0026#34; trên *Nix (Linux, BSD...) # trả về \u0026#34;dir\\subdir\\file\u0026#34; trên Windows   Tạo thư mục, mkdir sẽ tạo thư mục nếu tìm thấy các thư mục cha, còn mkpath sẽ tạo thư mục cha nếu không tìm thấy.\n1 2  mkdir(\u0026#34;đường dẫn\u0026#34;) mkpath(\u0026#34;đường dẫn\u0026#34;)   Đọc thư mục:\n1 2 3 4 5 6 7 8 9 10 11 12 13  # lấy ra tất cả tên file readdir(\u0026#34;đường dẫn tới thư mục\u0026#34;) # lấy ra từng tên file một for (root, dirs, files) in walkdir(\u0026#34;.\u0026#34;) println(\u0026#34;Đường dẫn tới các thư mục $root\u0026#34;) for dir in dirs println(joinpath(root, dir)) end println(\u0026#34;Các đường dẫn tới file trong $root\u0026#34;) for file in files println(joinpath(root, file)) end end   Copy (cp), di chuyển (mv), xóa (rm) file:\n1 2 3  cp(\u0026#34;đường dẫn\u0026#34;, \u0026#34;đường dẫn mới\u0026#34;) mv(\u0026#34;đường dẫn cũ\u0026#34;, \u0026#34;đường dẫn mới\u0026#34;) rm(\u0026#34;đường dẫn\u0026#34;)   Kiểm tra xem một đường dẫn có ứng với một file/thư mục/đường dẫn hay không:\n1 2 3  isfile(\u0026#34;xâu\u0026#34;) isdir(\u0026#34;xâu\u0026#34;) ispath(\u0026#34;xâu\u0026#34;)   Thư mục của người dùng:\n1  homedir()   Lấy ra đường dẫn thư mục, tên file từ dường dẫn:\n1 2 3  dirname(\u0026#34;/home/hung/\u0026#34;) # trả về \u0026#34;/home/hung\u0026#34; dirname(\u0026#34;/home/hung\u0026#34;) # trả về \u0026#34;/home\u0026#34; basename(\u0026#34;/tmp/something.jl\u0026#34;) # trả về \u0026#34;something.jl\u0026#34;   Tạm kết Lúc đầu viết mình cũng không nghĩ bài sẽ dài như thế này. Tổng kết lại, chúng ta đã tìm hiểu về:\n Cách đọc, ghi file Lưu trữ tùy ý các kiểu dữ liệu của Julia Tương tác với hệ thống file thông qua Julia  Lưu ý thêm, nếu bạn sử dụng con trỏ file, đừng quên đóng file sau khi làm việc xong. Ngoài ra, với cú pháp do, con trỏ file được cho là local và file sẽ đóng ngay khi khối do chạy xong.\nTham khảo:\n https://docs.julialang.org/en/v1/base/file/# https://docs.julialang.org/en/v1/base/io-network/ https://docs.julialang.org/en/v1/stdlib/DelimitedFiles https://github.com/JuliaIO/FileIO.jl https://github.com/JuliaIO/JLD2.jl https://github.com/JuliaIO/  ","description":"","id":9,"section":"posts","tags":["julia"],"title":"Julia Dojo: làm việc với file","uri":"https://ndgnuh.github.io/julia-dojo/lam-viec-voi-file-trong-julia/"},{"content":"Chào mừng mọi người đến với Julia Dojo.\nLà con người, không phải ai trong số chúng ta cũng có khả năng cân tất cả các việc cùng một lúc, đặc biệt với đống kiến thức tích lũy qua cả trăm năm của nhân loại. Hiển nhiên rằng, một người không thể lập trình mọi thứ từ con số không. Vì vậy, chúng ta có cộng đồng người dùng, có các gói bổ trợ cho một ngôn ngữ lập trình. Trong bài viết ngày hôm nay, chúng ta sẽ tìm hiểu về cách quản lí và sử dụng các gói như vậy trong Julia.\nQuản lí một gói Julia cung cấp tính năng quản lí gói một cách mặc định trong Julia REPL. Để kích hoạt trình quản lí gói, chúng ta nhấn phím ] ở trên một dòng trống.\nGiao diện quản lí gói, đầu dòng chuyển thành `pkg\u0026gt;`   Mọi đoạn code sau đây được sử dụng trong chế độ quản lí gói của Julia  Để cài gói trong Julia, chúng ta sử dụng cú pháp add gói. Chúng ta có thể cài một hoặc nhiều gói, hoặc dùng link github để cài.\nadd DataFrame IJulia add https://github.com/tlienart/Franklin.jl Lưu ý rằng link github sẽ tải bản mới nhất hiện có, bao gồm cả các tính năng thử nghiệm. Sau khi cài đặt một thời gian, chúng ta sẽ cần update gói\nupdate IJulia update Lệnh update sẽ update toàn bộ gói trong khi update TênGói chỉ update một gói được định sẵn thôi.\nKiểm tra những gói được cài đặt:\nst st TênGói Nếu có gói không dùng, chúng ta xóa bỏ nó bằng cách\nrm TênGóiKhôngDùng Khi cài hoặc update gói, những gói phụ thược sẽ được cài đặt theo, khi xóa gói chúng sẽ được tự xóa đi, nên các bạn không cần lo về gói phụ thuộc.\nSử dụng một gói Cách sử dụng một gói trong Julia rất đơn giản. Một gói thông thường sẽ có nhiều module, trong đó có một module chính mang tên của gói đó (ví dụ như gói IJulia.jl sẽ có module IJulia). Chúng ta có hai từ khóa import và using (sử dụng trong chế độ bình thường)\n1 2  import TênModule using TênModule   Sử dụng import sẽ chỉ nhập tên của gói vào phạm vi toàn cục, trong khi using sẽ nhập toàn bộ những hằng số, biến số hoặc hàm mà gói đó xuất ra.\n1 2  import Module1 using Module2   Giả sử Module1 có hàm_a, Module2 có hàm_b. Trong ví dụ trên, nếu chúng ta muốn gọi hai hàm:\n1 2  Module2.hàm_a() hàm_b() # hàm_b được cho ra phạm vi toàn cục   Ngoài ra chúng ta có thể chỉ using một số thành phần của gói:\n1 2  using LinearAlgebra: svd # chỉ hàm svd sẽ được nhập ?svd # xem hàm svd   Môi trường của gói Trình quản lí gói của Julia quản lí theo môi trường, nhìn lại ảnh phía trên, chúng ta sẽ thấy có phần (v1.3) ở trước chữ pkg\u0026gt;:\nmôi trường mặc định, Julia 1.3   Phần v1.3 cho biết môi trường đang hiện hoạt của Julia. Hãy hiểu một cách đơn giản:\n Julia có nhiều môi trường khác nhau Trong môi trường sẽ có những gói được cài khác nhau Môi trường thực chất chỉ là một thư mục, thư mục này chứa một file, file này là danh mục các gói đã được cài Nếu môi trường không có gói nào thì sẽ không dùng được gói đó, dù nó đã được cài (using gây lỗi) Khi làm việc sẽ có một môi trường được kích hoạt (môi trường hiện hành) Bạn có thể chuyển giữa các môi trường  Khi cài một gói mà đã được cài ở môi trường khác, Julia chỉ thêm gói đó vào trong danh mục gói của môi trường hiện hành, chứ không tải hay cài lại. Điều này giúp tránh sự trùng lặp khi cài gói.\nTương tự, việc xóa gói đôi lúc chỉ xóa gói đó khỏi chỉ mục chứ không thực sự xóa nó khỏi ổ đĩa.\nNếu bạn muốn xóa những gói không cài trong môi trường nào, dùng lệnh gc.\n Môi trường mặc định của Julia là môi trường có chứa tên phiên bản, đây sẽ là môi trường bạn sử dụng nhiều nhất cho việc nghiên cứu hay nháp. Nếu bạn đổi sang môi trường khác, bạn sẽ thấy phần trong ngoặc cũng thay đổi.\nĐể chuyển vào một môi trường, ta dùng lệnh activate (trong chế độ quán lí gói).\nactivate /đường/dẫn/tới/thư/mục Để chuyển về môi trường mặc định, chúng ta sử dụng lệnh activate mà không truyền tham số vào.\nMột số gói/module trong Julia Mình chỉ giới thiệu một số thôi, chỗ này không phải tất cả nhé!\nMột số module đi kèm trong Julia, không cần cài đặt (standard library):\n   Tên Chức năng     Dates Làm việc với thời gian   Distributed Hỗ trợ tính toán song song   LibGit2 Binding của một thư viện C để làm việc với Git   Libdl Làm việc với thư viện liên kết động   LinearAlgebra Đại số tuyến tính, svd, lu, trị riêng \u0026hellip;   SparseArray Ma trận thưa thớt   SharedArrays Dữ liệu được lưu trên vùng nhớ chung   Sockets Làm việc với Unix sockets   Statistics Công cụ thống kê   Test Unit testing   Profile Profile code    Một số gói do cộng đồng viết:\n   Tên gói Chức năng     IJulia Dùng Julia với Jupyter notebook   DataFrames Bảng dữ liệu   Distributions Các loại phân phối xác suất   DataStructures Các loại cấu trúc dữ liệu   DifferentialEquations Giải các pt vi phân   JuMP Công cụ tối ưu   Plots Vẽ đồ thị (nhiều backend)   HTTP, Genie, Mux Công cụ làm Web App, Web API   CUDAnative Công cụ cho CUDA   PyCall Gọi python từ Julia   TensorFlow Wrapper cho TensorFlow   ScikitLearn Cài đặt lại hoàn toàn ScikitLearn trong Julia    Tạm kết Trong bài viết này, chúng ta đã tìm hiểu về:\n Cách cài đặt, update, xem và xóa gói Julia Cách sử dụng các module trong Julia Làm việc với môi trường của gói Một số module và gói trong Julia  Trong bài viết sau, chúng ta sẽ học cách sử dụng Julia với Jupyter notebook hoặc Jupyter lab. Hẹn gặp lại các bạn.\nTham khảo thêm:\n Quản lí gói: https://docs.julialang.org/en/v1.0/stdlib/Pkg/ Thư viện tiêu chuẩn: https://docs.julialang.org/en/v1/stdlib/Base64/ Tìm kiếm gói Julia: https://pkg.julialang.org/docs/  ","description":"Hướng dẫn cài đặt và sử dụng các gói trong Julia","id":10,"section":"posts","tags":["julia"],"title":"Julia Dojo: quản lí gói trong Julia","uri":"https://ndgnuh.github.io/julia-dojo/cai-dat-va-su-dung-goi-julia/"},{"content":"Chào mừng mọi người quay trở lại Julia Dojo. Trong bài trước chúng ta đã học về trình quản lí gói và cách để sử dụng các gói. Hôm nay, chúng ta sẽ thực hành cài đặt và sử dụng gói đầu tiên, cũng chính là gói mà hỗ trợ chúng ta làm việc với Jupyter Notebook.\nCó thể bạn chưa biết, tên của project Jupyter thực ra được tạo thành từ ba ngôn ngữ: Julia, Python và R. Dù không phải viết tắt trực tiếp của ba ngôn ngữ nhưng cái tên này đã cho thấy rất rõ ràng định hướng của project.  Cấu hình \u0026amp; cài đặt Trước khi cấu hình Julia để làm việc với Jupyter, chúng ta cần có Python hoặc Jupyter notebook/lab cài đặt sẵn trong máy (Python là phụ thuộc của Jupyter). Sau đó chúng ta tiến hành cài gói Julia. Mình sẽ không hướng dẫn cài đặt Python ở đây, rất nhiều hướng dẫn khác đã tồn tại trên mạng.\nSau khi thỏa mãn mọi điều kiện, bạn mở REPL và cài đặt gói IJulia.\n1  ]add IJulia   Nếu các bạn không quen với Jupyter (thường được biết đến với Jupyter Notebook), mình sẽ giải thích một cách ngắn gọn: Jupyter là một giao diện hơi giống REPL trên nền web dành cho các ngôn ngữ lập trình. Jupyter khác REPL ở chỗ, nó lưu lại lệnh và ghi chú của bạn. Để Jupyter hoạt động được, chúng ta cần có một thứ gọi là \u0026ldquo;nhân\u0026rdquo; của ngôn ngữ lập trình. Quy trình làm việc như sau:\n Jupyter nhận input của bạn Jupyter sẽ gửi code đến nhân Nhiệm vụ của nhân là chạy đoạn code đó, sau đó gửi output tới Jupyter Jupyter hiện output cho bạn  Gói IJulia chính là \u0026ldquo;nhân\u0026rdquo; dành cho ngôn ngữ Julia. Sau khi cài gói xong, chúng ta cần chạy lần đầu để Julia cài đặt nhân và cấu hình Jupyter để sử dụng nó. Bạn không cần lo về việc cài Jupyter, khi chạy IJulia lần đầu, Julia sẽ cài đặt Jupyter cho chúng ta nếu cần.\n1 2 3  using IJulia notebook() # để dùng Jupyter Notebook jupyterlab() # để dùng Jupyter Lab   Sử dụng Chúng ta có thể sử dụng Julia với Jupyter theo cách ở trên, tuy nhiên, Jupyter sẽ dùng thư mục mà chúng ta dùng đang mở (thư mục mà chúng ta dùng để chạy Julia). Sau khi cấu hình với lần chạy đầu tiên của IJulia, chúng ta sẽ không cần mở REPL lên để dùng notebook nữa. Thay vào đó, chúng ta hãy mở một terminal tại thư mục bạn muốn. Ví dụ, mình dùng notebook:\n1 2 3 4  cd notebook jupyter notebook # hoặc bạn muốn dùng jupyter lab jupyter lab   Mình chỉ hướng dẫn notebook thôi, lab bạn tự tìm hiểu nhé. Sau khi chạy lệnh trên, một cửa sổ trình duyệt sẽ hiện lên:\nGiao diện Jupyter Notebook   Để tạo một notebook, hãy ấn vào nút New ở góc phải màn hình. Sau đó một danh sách các nhân đã cài sẽ hiện lên, ở đây mình có hơi nhiều :)\nMenu tạo notebook mới   Click vào Julia x.y.z để tạo một notebook sử dụng Julia, một cửa sổ khác sẽ hiện lên.\nGiao diện của một notebook   Trong cửa sổ này, chúng ta có thể thêm, sửa, xóa, chạy các ô code hoặc nhấn phím m để chuyển qua viết ghi chú. Phím y dùng để chuyển lại một ô thành code và tổ hợp Ctrl/Shift + Enter dùng để chạy ô code đó.\nChạy code Julia, viết Markdown và LaTeX   Tạm kết Qua bài viết lần này, chúng ta đã biết cách cấu hình Julia để sử dụng với Jupyter Notebook. Những phần còn lại của giao diện notebook mời các bạn tự khám phá thêm, mình xin kết thúc bài viết này ở đây, tạm biệt và hẹn gặp lại các bạn trong những bài viết sau.\nTham khảo:\n https://github.com/JuliaLang/IJulia.jl https://jupyter.org/install  ","description":"Hướng dẫn cấu hình Julia để sử dụng với Jupyter Notebook và Jupyter Lab","id":11,"section":"posts","tags":["julia"],"title":"Julia Dojo: Julia + Project Jupyter","uri":"https://ndgnuh.github.io/julia-dojo/dung-julia-voi-jupyter-notebook-va-jupyter-lab/"},{"content":"Mọi người có thể gửi feedback cho mình thông qua các cách sau:\n Email: ndgnuh@protonmail.com Github (gửi issue hoặc pr): https://github.com/ndgnuh/ndgnuh.github.io Google form: https://forms.gle/EPHRrgPggS1dNEjW9  Nếu bạn muốn gửi feedback nặc danh, không dùng bất kì loại tài khoản nào, hãy dùng google form.  ","description":"","id":12,"section":"","tags":null,"title":"Liên hệ","uri":"https://ndgnuh.github.io/lien-he/"},{"content":"Chào mừng các mọi người quay trở lại với series Julia Dojo. Như mình đã giới thiệu, Julia là một ngôn ngữ lập trình hàm, và ngôn ngữ lập trình hàm thì\u0026hellip; không thể thiếu hàm. Thậm chí, hàm là thực thể \u0026ldquo;hạng nhất\u0026rdquo; của Julia. Trong bài viết này, mình sẽ giới thiệu về cú pháp viết và sử dụng các hàm, cũng như một số trường hợp hay gặp.\nBài viết chủ yếu giới thiệu các cú pháp để làm việc với hàm nên không nói quá chi tiết. Phần đó được dành cho một bài viết khác  Như mình nói ở phần cấu trúc điều khiển, nếu cấu trúc điều khiển của bạn quá phức tạp, bạn có thể sẽ phải viết một hàm. Trong bài viết này mình sẽ nói về việc khai báo, phạm vi biến và gọi hàm.\nKhai báo một hàm Ba kiểu khai báo Việc khai báo một hàm trong Julia có thể được làm theo nhiều cách. Cách 1 là dùng khối function:\n1 2 3 4  function tên_hàm(tham_số) # thân hàm return (giá trị trả về) end   Đoạn code trên là ví dụ đơn giản nhất của một hàm. Từ khóa return không thực sự cần thiết, nếu không có return hàm trên sẽ trả về giá trị của biểu thức cuối cùng được chạy (giống khối if).\nVì Julia là ngôn ngữ động nên hàm trên sẽ chạy với mọi kiểu dữ liệu. Tuy vậy, chúng ta vẫn có thể kiểm soát kiểu dữ liệu của tham số được truyền vào, cũng như kiểu dữ liệu mà hàm trả về.\n1 2 3 4 5  # đây chỉ là ví dụ # đừng viết hàm kiểu này function cộng_một(n::Int)::Int n + 1 # trả về (n + 1) vì đây là biểu thức cuối end   Vì chúng ta chưa tìm hiểu sâu về kiểu dữ liệu nên tạm thời hãy viết những hàm mà chạy với tất cả các kiểu (tức là không định kiểu). Những hàm như vậy được gọi là \u0026ldquo;generic\u0026rdquo; (tổng quát).\nVới những hàm ngắn gọn như vậy, chúng ta có thể dùng hai cú pháp sau:\n1  cộng_một(n) = n + 1   Mình nghĩ họ gọi kiểu hàm trên là hàm \u0026ldquo;inline\u0026rdquo;. Ngoài việc nhìn trông rất thích mắt (nhìn giống với hàm toán học), nếu được cài đặt đúng cách, khi chúng được gọi, thân hàm sẽ được thay thế trực tiếp vào phần code đang gọi nó (tức là code chạy nhanh hơn, không tốn thêm stack).\nTrong Julia, chúng ta có thể khai báo các hàm mà không cần đặt tên cho chúng, chỉ cần bỏ phần tên khỏi hàm:\n1 2 3  function(n) n + 1 end   Những hàm kiểu này thường được dùng làm tham số của một hàm khác. Do dó Julia cung cấp cho chúng ta một cách khai báo tiện gợi hơn:\n1  n -\u0026gt; n + 1   Đương nhiên, nếu muốn chúng ta vẫn có thể gắn tên cho chúng, vì hàm trong Julia có thể được coi là một biến:\n1 2 3 4  cộng_một = n -\u0026gt; n + 1 cộng_một = function(n) n + 1 end   Tuy nhiên, cú pháp với -\u0026gt; thường được sử dụng cho hàm vô danh, những hàm bạn chỉ dùng một lần rồi vứt, không nên dùng để khai báo một hàm có tên như vậy.\nChúng ta cũng có thể khai báo một hàm là toàn cục hay nội bộ với từ khóa local hoặc global\n1 2 3 4 5 6  global function our_func() # thân hàm end local function our_func() # thân hàm end   Tham số mặc định Trong Julia bạn có thể gắn giá trị mặc định cho tham số của hàm:\n1  cộng(n, i = 1) = n + 1   Khi gọi hàm trên, nếu bạn không truyền tham số i thì i sẽ nhận giá trị mặc định là 1\n1  cộng(10) # trả về 11   Tham số có tên Ngoài những tham số được sắp theo thứ tự như trên, hàm trong Julia còn hỗ trợ tham số có tên (keyword arguments). Mặc dù không cần thiết, tham số có tên được ngăn cách với tham số \u0026ldquo;bình thường\u0026rdquo; bằng dấu ; (cả khi gọi và khai báo hàm).\n1 2  cộng(n; m) = n + m cộng(10; m = 20) # trả về 20   Tham số có tên cũng có thể nhận giá trị mặc định. Khi gọi, thứ tự của tham số này không quan trọng, chỉ cần chúng ta định đúng tên:\n1 2 3 4 5  cộng(n; m = 2, p = 3) = n + m + p cộng(10) # trả về 15 cộng(10; p = 8) # trả về 20 cộng(10; z = 100) # lỗi, không có z cộng(10, m = 17) # dùng dấu `,` cũng không sao   Tùy lượng tham số Cuối cùng, chúng ta có một kiểu tham số đặc biệt. Mình nghĩ nó sẽ dễ hiểu hơn với một ví dụ:\n1 2 3 4  trung_bình(args...) = sum(args) / length(args) trung_bình(1, 3, 8) # trả về 4 trung_bình(1, 1, 1, 3) # 1.5 trung_bình(1) # 1   Hàm sum có thể dùng để tính tổng của một mảng, còn length dùng để đếm số phần tử. Như vậy, khi khai báo hàm như trên, những tham số được \u0026ldquo;nhét\u0026rdquo; vào một mảng và cũng ta thao tác trực tiếp trên mảng đó. Điều đó có nghĩa chúng ta có thể truyền một cách tùy, bao nhiêu tham số cũng được.\nGọi hàm Gọi hàm trong Julia rất đơn giản, chúng ta thậm chí đã gọi một số hàm trước đây rồi. Hàm được gọi bằng cú pháp tên_hàm(tham_số; tham_số_có_khóa)\n1  sort([1, -3, 2]; rev = true) # sắp xếp giảm dần   Chúng ta cũng có thể gọi hàm một cách lồng nhau:\n1 2 3  # tạo random mảng 4 phân tử trong khoảng [-9, 9] # sau đó sắp xếp giảm dần sort(rand(-9:9, 4); rev = true)   Tuy nhiên, với những hàm gọi lồng nhau mà không cần tham số nào khác, kiểu như sau:\n1 2 3 4 5  # khai báo f(x) = x + 1 g(x) = 42x # gọi hàm g(f(1))   Julia cung cấp cho chúng ta toán tử rất tiện lợi để tổ hợp hàm:\n1 2  # cách gõ: \\circ\u0026lt;tab\u0026gt; (g ∘ f)(1) # tương dương với g(f(1))   Sự tiện lợi chưa dừng ở đây. Bạn có thể áp dụng một hàm lên một tập hợp giống như lúc làm với toán tử, bằng cách thêm dấu . ở giữa tên hàm và tham số truyền vào:\n1 2 3  M = [1 2 3; 2 3 4; 4 5 6] f(x) = x^2 + 3 f.(M) # lấy mọi phần tử trong ma trận M, mũ 2 rồi cộng 3   Phạm vi biến trong hàm Julia Giống với các vòng lặp, mọi biến trong hàm của Julia đều mặc định có phạm vi là nội bộ. Hàm có thể thay đổi khai báo hoặc thay đổi biến toàn cục, nhưng phải dùng từ khóa global.\nHàm lồng trong hàm Như mình nói phần khai báo hàm, chúng ta có thể thay đổi phạm vi của hàm, vậy các hàm local dùng ở đâu? Đương nhiên là dùng trong các khối khác, dễ hình dung nhất là \u0026ldquo;hàm lồng trong hàm\u0026rdquo;.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function hàm_cha(n) # tính toán function hàm_con(tham_số_con) # thân hàm con end # tính toán while(điều_kiện) # tính toán for i in một_cái_gì_đó # tính toán dùng hàm con vì logic ở đây khá dài hàm_con(tham_số_con) # tính toán end # tính toán end end   Vì những biến được định nghĩa trong hàm mặc định là local - và những hàm trong Julia có thể được coi là một biến, hàm định nghĩa trong hàm mặc định cũng là local. Trong trường hợp trên, hàm_con sẽ không bị \u0026ldquo;rò rỉ\u0026rdquo; ra ngoài phạm vi toàn cục. Chúng ta cũng có thể khai báo hàm local ở trong các khối khác, không nhất thiết phải trong một hàm:\n1 2 3 4 5 6  for i = 1:3 cộng_thêm_i(x) = x + i for j = 2:3 @show cộng_thêm_i(j) end end   Hành vi với tham số truyền vào Trong Julia, đa số các hàm chỉ nhận tham trị và không thay đổi các biến đầu vào. Đương nhiên chúng ta vẫn có những hàm thay đổi tham số của nó. Những hàm này nếu dùng không cẩn thận có thể gây ra những hành vi rất khó đoán, việc phân biệt chúng cũng rất đau đầu trong một số ngôn ngữ.\nMay thay, Julia cung cấp một quy ước để định ra những hàm thay đổi tham số truyền vào của chúng. Những hàm này sẽ có một dấu ! ở sau tên của chúng.\n1 2 3 4 5  arr = [1, -3, 2] sort(arr) # hàm này chỉ trả về mảng đã sắp xếp @show arr sort!(arr) # hàm này sắp xếp luôn mảng arr @show arr   Lưu ý rằng đây chỉ là một quy ước, bạn hoàn toàn có thể viết hàm thay đổi tham số đầu vào mà không có dấu ! trong tên và ngược lại.\nTạm kết Mình xin kết thúc bài giới thiệu về hàm ở đây. Vậy là chúng ta đã kết thúc level 1 của Julia Dojo. Tuy vậy, tất cả những thứ trong level này đều mang tính giới thiệu. Điều đó cũng khá hiển nhiên thôi, một ngôn ngữ vừa nhanh vừa tiện để viết, dù nó đơn giản nhưng bạn cũng không mong nó đơn giản tới mức cục mịch chứ? :)\nĐừng lo, dù phức tạp đi nữa thì Julia khá dễ vọc, không như kiểu hợp ngữ đâu. Mình sẽ cố giải thích cho các bạn những thứ cơ bản, đến khi đủ để các bạn tự tìm hiểu. Nếu các bạn có thắc mắc hoặc thấy thiếu sót đừng ngại liên hệ. Hẹn gặp mọi người trong những level tiếp theo.\n","description":"Giới thiệu về hàm trong Julia","id":13,"section":"posts","tags":["julia"],"title":"Julia Dojo: hàm","uri":"https://ndgnuh.github.io/julia-dojo/ham-trong-julia/"},{"content":"Chào mừng các bạn trở lại với Julia Dojo. Chúng ta đã tìm hiểu về cách khai báo biến và làm việc với một số kiểu dữ liệu trong bài viết biến số, kiểu dữ liệu, phép toán. Nhưng một chương trình chỉ có gán, gọi hàm và phép toán không thì không đủ, do đó, chúng ta ta có các cấu trúc điều khiển.\n  Nội dung chỉnh sửa  29/01/2020:\n- thêm phần lặp for, lặp với bước nhảy không phải 1\n- thêm phần khối lệnh (vốn định đưa sang bài hàm, nhưng thôi)   Khối lệnh Đến phần này, chúng ta sẽ phải biết cách nhận biết một khối lệnh trong Julia. Trong các ngôn ngữ như C hoặc Java, chúng ta dùng một cặp { } để đánh dấu các dòng lệnh. Ở đây chúng tôi không làm vậy.\nLỗi: meme được dùng đi dùng lại quá nhiều  Thay vào đó, mỗi từ khóa end sẽ được kết hợp với các từ khóa lặp, khai báo hàm, rẽ nhánh, v.v\u0026hellip; ở đầu của một khối lệnh. Một cặp \u0026ldquo;từ khóa mở đầu - end\u0026rdquo; sẽ đánh dấu một khối lệnh trong Julia. Khối lệnh đơn giản nhất trong Julia, là\u0026hellip; một khối lệnh theo đúng nghĩa. Nó bắt đầu với từ khóa begin, mình thường dùng khi phép gán của mình có một biểu thức rất dài, nên muốn chia nó thành các biến phụ cho đỡ rối mắt.\n1 2 3 4 5  z = begin local x = 1 local y = 2 # tưởng tượng nó rất dài hộ mình :) x + y end   Khối lệnh sẽ trả ra giá trị ứng với biểu thức ứng cuối cùng của nó (tức x + y trong ví dụ trên). Ngoài ra chúng ta cũng có thể dùng từ khóa return để trả về một giá trị và kết thúc việc thực hiện khối lệnh. Hãy cẩn thận, khối begin có thể thay đổi biến toàn cục mà không báo trước, đó cũng là lí do mình dùng từ khóa local ở trên.\nNếu bạn không thích dùng begin, end chúng ta cũng có thể viết:\n1 2 3 4  z = (local x = 1; local y = 2; x + y) z = (local x = 1; local y = 2; x + y)   Mình là người có điều kiện If\u0026hellip; Hãy thử tượng tượng phải lập trình nhưng không được dùng các cấu trúc rẽ nhánh xem. Bạn sẽ làm ra một chương trình mà, hoặc không thể sử dụng được, hoặc chứa một đống các loại đa hình để thay cho cấu trúc rẽ nhánh (cũng không lí tưởng lắm!). Vậy nên, tội gì không sử dụng if - else cho cuộc sống dễ dàng.\n1 2 3 4 5 6 7 8  x = rand(-1:1) if x == 1 println(x) elseif x == 0 println(x + 1) else println(x + 2) end   Chúc mừng, bạn đã viết thành công chương trình in ra số 1 (dùng if - else - end). Trong cấu trúc rẽ nhánh, các từ khóa elseif, else là không bắt buộc, nếu bạn không có nhiều trường hợp thì không phải viết chúng.\nNếu các bạn đang tự hỏi Julia có cấu trúc switch hay không, mình trả lời luôn là không, lí do là\u0026hellip; không cần thiết. Thực chất cấu trúc switch có thể được thay thế bằng if và một đống elseif, mỗi điều kiện chính là một case, và else chính là default.\nToán tử ba ngôi Trong Julia, mọi cấu trúc if đều trả về một giá trị nào đó. Bạn hoàn toàn có thể viết như sau:\n1 2 3 4 5 6  @show a = rand(0:1) # a nhận giá trị 0 hoặc 1, ngẫu nhiên b = if a == 0 0 else 1 end; println(\u0026#34;b = $b\u0026#34;)   Đoạn chương trình trên\u0026hellip; in ra số 0 và gắn b bằng a rồi in ra b. Giá trị của if trả về chính là câu lệnh cuối cùng mà nó chạy. nhưng nếu thích bạn có thể viết từ khóa return để \u0026ldquo;trang trí\u0026rdquo;.\n1 2 3 4 5  b = if a == 0 return 0 else return 1 end   Nhưng mà thực sự, đừng làm như vậy :) Chúng ta có toán tử ba ngôi cho những việc như thế này.\n1 2  a = rand(0:1) b = (a == 1) ? 1 : 0   Vẫn là chương trình random a rồi gán b bằng a, nhưng gọn hơn rất nhiều (mình không nói là cách gọn nhất\u0026hellip;). Dấu ngoặc bao quanh điều kiện là không cần thiết, nhưng mình viết vậy vì nó dễ nhìn.\nNếu dùng @show lên toán tử ba ngôi, chúng ta sẽ thấy nó chỉ là một khối if được đơn giản hóa.\n1 2 3 4 5 6 7  julia\u0026gt; @show (x == 1) ? 1 : 0 if x == 1 1 else 0 end = 1 1   Phạm vi của biến trong if Những biến được khai báo trong khối if sẽ tồn tại ở cả bên ngoài khối. Ví dụ trong đoạn code dưới đây:\n1 2 3 4 5 6  if rand(Bool) x = 1 else x = 10 end @show x   Nếu biến x chưa tồn tại, nó sẽ được khai báo. Nếu nó đã tồn tại, giá trị của nó sẽ được thay đổi. Việc thêm từ khóa local sẽ không có tác dụng gì. Nói cách khác, khối if có cùng phạm vi biến (scope) với khối lệnh chứa nó\nLặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp\u0026hellip; Thử tưởng tượng lập trình mà không có vòng lặp xem (thực ra các bạn có thể dùng đệ quy thay cho vòng lặp, nhưng mình thấy lặp vẵn dễ sống hơn!). Vòng lặp khác với hai khối trên (ngoài việc nó lặp) ở chỗ: nó không trả về giá trị gì cả, trừ khi bạn ném từ khóa return vào trong vòng lặp.\nJulia cung cấp cho chúng ta hai loại vòng lặp: for và while, hãy cùng tìm hiểu chúng.\nVòng lặp for Đầu tiên chúng ta có vòng lặp for để lặp với số lần xác định trước:\n1 2 3 4 5 6  for i = 1:10 println(i) end for i = 1:2:10 # lặp với bước nhảy 2, mặc định bước nhảy là 1 println(i) end   Bạn cũng có thể dùng lặp với từng phần tử của một tập hợp hay một mảng nào đó.\n1 2 3 4  arr = [1, 2, 3] for x in arr println(x) end   Chúng ta cũng có thể lặp qua một xâu kí tự:\n1 2 3 4  s = \u0026#34;xin chào\u0026#34; for i = 1:length(s) println(s[i]) end   Khi chạy đoạn code trên, chúng ta sẽ thu được\u0026hellip; lỗi.\n1 2 3 4 5 6  ERROR: StringIndexError(\u0026#34;xin chào\u0026#34;, 8) Stacktrace: [1] string_index_err(::String, ::Int64) at ./strings/string.jl:12 [2] getindex_continued(::String, ::Int64, ::UInt32) at ./strings/string.jl:220 [3] getindex(::String, ::Int64) at ./strings/string.jl:213 [4] top-level scope at ./REPL[4]:2   Điều này xảy ra vì Julia hỗ trợ unicode, do đó không phải string nào cũng là ascii (bạn có thể kiểm tra bằng hàm isascii). Những kí tự không nằm trong bảng ascii sẽ chiếm một số lượng index không xác định. Vậy muốn lặp qua một xâu kí tự an toàn thì làm như thế nào?\n1 2 3  for i in eachindex(s) println(s[i]) end   Hàm eachindex sẽ sinh ra một bộ chỉ số của xâu s và bạn có thể lặp qua từng kí tự của s một cách an toàn. Hơn nữa, eachindex nhìn đẹp hơn 1:length(s). Nếu bạn không cần chỉ số mà chỉ cần kí tự, bạn có thể lặp như sau:\n1 2 3  for c in s println(c) end   Không chỉ với string, eachindex hoạt động với tất cả các kiễu dữ liệu có thể lặp được (nói sau nhé), bao gồm cả mảng, ma trận. Nếu mình không nhầm, dùng nó cũng có lợi về hiệu năng hơn vì Julia sẽ không phải kiểm tra việc đánh chỉ số có đúng hay không.\nBạn có thể dùng nhiều vòng lặp lồng nhau như các ngôn ngữ lập trình khác:\n1 2 3 4 5 6 7  for i = 1:2 for j = 3:4 for k = 5:6 @show (i, j, k) end end end   Trong trường hợp vòng lặp bên ngoài không có nhiệm vụ gì ngoài gọi vòng lặp con như trên, code của chúng ta sẽ trông như cái tam giác trống, nhìn hơi tù. Julia cung cấp cho chúng ta cách chồng các vòng lặp lên nhau.\n1 2 3  for i=1:2, j=3:4, k=5:6 @show (i, j, k) end   Đoạn code này sẽ in ra cùng một kết quả như trên, nhưng lại gọn gàng và dễ nhìn hơn. Dù sao, nếu bạn phải dùng tới ba bốn vòng lặp, logic trong code của bạn có thể đã trở nên phức tạp và đó là dấu hiệu của việc bạn nên viết hàm.\nVòng lặp while Cấu trúc lặp while thì mạnh mẽ hơn lặp for rất nhiều, nó có thể dùng để lặp với số lần lặp không xác định (hoặc có, nhưng đó là việc của for). Vòng lặp while không có nhiều thứ cần đặc biệt lưu ý giống như for, các bạn có thể dùng nó với cú pháp như sau:\n1 2 3 4 5  điều_kiện = true # biểu thức điều kiện while điều_kiện # làm gì đó # với dữ liệu end   Phạm vi biến của cấu trúc lặp Vòng lặp trong julia có phạm vi biến riêng. Điều đó có nghĩa, các vòng lặp sẽ không thay đổi các biến toàn cục một các tùy tiện.\n1 2 3 4 5 6  # phạm vi toàn cục (global scope) x = 10 for i = 1:10 x = i # biến i vẫn truy cập được end @show x # x vẫn là 10   Tuy nhiên, khi vòng lặp được lồng trong một phạm vi nội bộ (một vòng lặp khác, một hàm), chúng có thể cập nhật biến trong phạm vi đó:\n1 2 3 4 5 6 7  for i = 1:2 x = i for j = 3:4 x = x * j end @show x # biến x sẽ thay đổi end   Nếu bạn muốn thay đổi biến toàn cục, hãy dùng từ khóa global:\n1 2 3 4 5  x = 10 for i = 1:5 global x *= i end @show x # x = 1200   Thoát lặp, nhảy lặp Nếu bạn đang lặp mà muốn dừng giữa chừng, bạn có thể dùng break để thoát hoàn toàn khỏi vòng lặp.\n1 2 3 4 5 6 7  đếm = 1 while true global đếm += 1 if đếm == 4 break end end   Nếu vì lí do nào đó, bạn muốn nhảy cóc một vòng lặp, bạn có thể dùng từ khóa continue.\n1 2 3 4 5 6 7  for i = 1:4 if i == 3 continue else @show i end end   Với những đoạn rẽ nhánh đơn giản như trên, chúng ta có thể dùng kết hợp với toán tử ba ngôi cho gọn:\n1 2 3  for i = 1:4 i == 3 ? continue : @show i end   Tạm kết Sau khi biết được các cấu trúc điều khiển cơ bản. Hãy nhớ rằng nếu bạn lồng quá nhiều cấu trúc điều khiển với nhau, bạn có thể đang cần tách logic trong code ra thành một hàm. Viết hàm thế nào, hồi sau sẽ rõ :) Hẹn gặp lại các bạn ở bài viết sau.\n","description":"Cấu trúc điều kiện và lặp trong Julia","id":14,"section":"posts","tags":["julia"],"title":"Julia Dojo: cấu trúc điều khiển trong Julia","uri":"https://ndgnuh.github.io/julia-dojo/re-nhanh-va-lap-trong-julia/"},{"content":"Chào mừng các bạn trở lại với Julia Dojo. Hôm nay chúng ta sẽ tìm hiểu về một thứ khá cơ bản và thiết yếu trong các ngôn ngữ lập trình, đó là biến số (ok, không hẳn là thiết yếu, nhưng nó làm cuộc sống dễ dàng hơn), đồng thời khám phá một số kiểu dữ liệu cơ bản và thao tác với chúng.\nBiến số, hằng số Đôi khi, trông các bài hướng dẫn về ngôn ngữ lập trình, họ đồng nhất biến số và hằng số theo kiểu \u0026ldquo;hằng số là một biến số mà không thể thay đổi\u0026rdquo;. Điều này không đúng lắm về mặt kĩ thuật (technically correct is the best kind of correct). Tuy nhiên, nếu nó tiện lợi, nghe thuận tai và dễ hiểu hơn với bạn thì\u0026hellip; meh, tùy, whatever floats your boat.  Để khai báo một biến trong Julia, bạn chỉ cần sử dụng cú pháp:\n1 2  tên_biến = \u0026#34;giá trị\u0026#34; こんにちは世界 = \u0026#34;Hello world, google dịch vậy :)\u0026#34;   Điều hay nhất là: hai dòng lệnh trên hoàn toàn hợp lệ trong Julia (copy nó vào REPL và chạy thử đi!). Tên biến số, hằng số trong Julia có thể Là kí tự unicode, và các kí tự tiếng Việt không phải ngoại lệ. Tuy nhiên, mình nghĩ bạn không nên code bằng tiếng Việt có dấu, tiêng Nhật, tiếng Tàu hay tiếng Thái đâu. Cách tốt nhất để dùng tính năng này là:\n1 2 3 4 5 6 7 8  #= Bạn có thể gõ cái này theo các bước: 1. Nhập \u0026#34;\\varepsilon\u0026#34; (var epsilon) 2. Nhấn phím \u0026lt;tab\u0026gt; Tính năng này có trên mọi công cụ hỗ trợ Julia =# ε = 1e-9 # Giờ thì công thức toán trong # code của bạn sẽ gọn và dễ đọc hơn   Cực kì tiện lợi khi bạn code những phần mềm dùng nhiều công thức toán (mà lúc nào chẳng có toán chứ?). Nhân tiện mình giới thiệu luôn, dấu # được dùng để comment trên một dòng code (tất cả những gì sau dấu này sẽ được bỏ qua; còn cặp dấu #= và =# được dùng để comment trên nhiều dòng, mọi thứ giữa hai thằng này sẽ bị bỏ qua khi chạy code.\nCòn đề khai báo hằng số, bạn chỉ cần nhét thêm chữ const vào đầu dòng như sau:\n1  const hằng_số = true   Bất kì biến số, hằng nào bạn định nghĩa như trên trong REPL đều được coi là biến toàn cục. Nếu bạn viết một phần mềm sản xuất, hãy dùng ít biến toàn cục nhất có thể (vì lí do hiệu năng, lí do bảo dưỡng, v.v\u0026hellip; bạn không dùng càng tốt). Nhưng hằng số toàn cục vẫn ok nhé, thực chất Julia chỉ cho phép khai báo hằng số toàn cục thôi. Bạn có thể dùng từ khóa local để khai báo nội bộ và từ khóa global để khai báo toàn cục.\n1 2 3  local x = 1 global y = 2 local const z = \u0026#34;lỗi\u0026#34;   Nếu bạn khai báo biến local trưc tiếp trên REPL, nó sẽ biến mất ngay lập tức và bạn không dùng được nó. Vậy biến nội bộ có hiệu lực ở đâu, hồi sau sẽ rõ :) Giờ chúng ta chuyển sang nói qua về kiểu dữ liệu.\nKiểu dữ liệu Khi bạn gán một biến trong Julia, bộ dịch sẽ tự phát hiện kiểu và gắn kiểu dữ liệu của nó cho biến. Điều tương tự cũng xảy ra với hằng số. Bạn có thể lấy kiểu dữ liệu của một biến hay hằng bằng hàm typeof:\n1 2 3 4 5 6  x = 1.0 typeof(x) # Trả về một kiểu Float typeof(π) # Trả về Irrational{:π} # đây là một hằng số # viết bằng cách \\pi \u0026lt;tab\u0026gt; # có thể dùng chữ pi cũng được   Nhìn mấy cái kiểu dữ liệu có vẻ lằng nhằng, nhưng chúng ta đang ở Level 1, đừng bận tâm về nó vội. Mình chỉ giới thiệu qua một số kiểu dữ liệu hay dùng ở đây thôi.\nCác kiểu số Một ít int\n1  n = 3   Một ít float\n1 2  x = 2.0 y = 4.0   Một ít hữu tỉ\n1  p = 1//2   Một ít hư ảo\n1  z = 1 + 2im # hoặc 1 + 2 * im   Một ít phép toán\n1 2 3 4 5 6 7 8 9 10 11 12 13  đối = -z cộng = n + x cộng += z trừ = n - z nhân = z * p chia = n / x # lấy n chia x chia_ngược = n \\ x # lấy x chia cho n chia_hữu_tỉ = z // (3 - 4im) lũy_thừa = x^n lấy_căn = sqrt(4) lấy_căn_phức = sqrt(complex(-1)) # sqrt(-1) sẽ lỗi, vì kiểu của -1 là Real giá_trị_tuyệt_đối = abs(-3.4) module_phức = abs(z)   Một ít hàm toán học\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # Các hàm liên quan đến logarith exp(x) # e^x, e là hằng số Euler log(x) # loga cơ số e log10(x) # loga cơ số 10 log2(x) # loga cơ số 2 log1p(x) # loga cơ số e của (1 + x) log(y, x) # loga cơ số y của x # Các hàm liên quan tới lượng giác # Ngoài sin ra còn có cos, tan, cot sin(x) # lượng giác, dùng radian, tương tự có cos, tan, cot sind(x) # như sin, nhưng dùng đơn vị độ sinh(x) # hàm hyperbolic asin(x) # lượng giác ngược asind(x) # như asin, đơn vị độ asinh(x) # hàm hyperbolic ngược deg2rad(x) # chuyển từ độ sang radian rad2deg(x) # chuyển từ radian sang độ   Một ít phép so sánh\n1 2 3 4 5 6 7 8 9 10 11 12  bé_hơn = (x \u0026lt; y) lớn_hơn = (x \u0026gt; y) bằng = (x == y) khác = (x != y) khác = (x ≠ y) # \\ne\u0026lt;tab\u0026gt; xấp_xỉ = isapprox(x, y) xấp_xỉ = (x ≈ y) # \\approx\u0026lt;tab\u0026gt; không_xấp_xỉ = (x ≉ y) # \\napprox\u0026lt;tab\u0026gt; lớn_hơn_hoặc_bằng = x \u0026gt;= y lớn_hơn_hoặc_bằng = x ≥ y # \\ge\u0026lt;tab\u0026gt; (Greater than or Equal) bé_hơn_hoặc_bằng = x \u0026lt;= y bé_hơn_hoặc_bằng = x ≤ y # \\le\u0026lt;tab\u0026gt; (Less than or Equal)   Kiểu Bool Julia dùng true và false cho các giá trị thuộc kiểu Bool\n1 2 3 4 5 6 7  a = true b = false phủ_định = !a và_logic = a \u0026amp;\u0026amp; b hoặc_logic = a || b xor_logic = xor(a, b) xor_logc = a ⊻ b # \\xor\u0026lt;tab\u0026gt;   Kí tự và xâu kí tự Trong Julia, kí tự được bao quanh bởi dấu nháy đơn, còn xâu kí tự được bao quanh bởi dấu nháy kép. Bạn có thể dùng 3 dấu nháy kép để viết các xâu kí tự phức tạp, gồm nhiều dòng.\n1 2 3 4 5 6 7 8  kí_tự = \u0026#39;a\u0026#39; xâu = \u0026#34;hello world\u0026#34; xâu_phức_tạp = \u0026#34;\u0026#34;\u0026#34; \u0026#34;Trăm năm trong cõi người ta, Thúy Kiều là mẹ, con là Thúy Vân\u0026#34; Câu thơ cho thấy thằng nào ngồi viết cái này rất dốt văn... \u0026#34;\u0026#34;\u0026#34;   Julia hỗ trợ \u0026ldquo;nội suy\u0026rdquo; xâu kí tự (string interpolation, không mình biết dịch đúng không nữa). Dùng dấu $ là bạn có thể \u0026ldquo;nhúng\u0026rdquo; một biến vào trong xâu kí tự. Nếu bạn muốn dưa một biểu thức vào, hãy dùng $(biểu_thức).\n1 2 3 4  x = rand(-3:3) println(\u0026#34;một số ngẫu nhiên trong khoảng -3 tới 3: $x\u0026#34;) # hoặc println(\u0026#34;một số ngẫu nhiên trong khoảng -3 tới 3: $(rand(-3:3))\u0026#34;)   Một số hành động với kí tự và xâu kí tự:\n1 2 3 4 5 6 7 8  clipboard(\u0026#34;copy toàn bộ xâu kí tự này, dùng cái này max tiện\u0026#34;) collect(\u0026#34;xâu kí tự\u0026#34;) # chuyển xâu kí tự thành một mảng các kí tự Int(\u0026#39;c\u0026#39;) # Chuyển kí tự sang mã Unicode Char(97) # Chuyển mã kí tự thành kí tự length(\u0026#34;độ dài xâu\u0026#34;) \u0026#34;nối\u0026#34; * \u0026#34;xâu\u0026#34; * \u0026#34;kí tự\u0026#34; \u0026#34;nhân lên 3 lần \u0026#34; ^ 3 \u0026#34;abc\u0026#34; \u0026lt; \u0026#34;abd\u0026#34; # so sánh theo thứ tự từ điển, dựa vào mã kí tự   Mảng, ma trận Phần hay nhất để dành cuối cùng :) Julia hộ trợ tính toán ma trận rất ngon. Ngon thế nào thì từ từ mới biết hết, đặc biệt các bạn dùng Matlab có thể sẽ thấy nó quen thuộc. Phần này đáng có một bài viết riêng, vì vậy trong bài này mình chỉ giới thiệu thôi.\nTrong Julia, số chiều của ma trận được phân biệt rất rõ ràng. Khi khai báo một vector, chúng ta dùng dấu , hoặc ; để ngăn cách các phần tử:\n1 2  A = [1, 2, 3] B = rand(3) # vector ngẫu nhiên   Đoạn code trên sẽ tạo ra A và B là vector cột. Đối với ma trận, chúng ta dùng dấu cách ngăn cách các phần tử cùng hàng, và dấu ; để ngăn cách giữa các dòng\n1 2 3  M = [1, 2, 3; 4, 5, 6; 7, 8, 9] # lỗi, không dùng được dấu \u0026#34;,\u0026#34; đâu M = [1 2 3; 4 5 6; 7 8 9] N = rand(3, 3) # ma trận ngẫu nhiên   Để lấy chỉ số của vector, ma trận, chúng ta dùng cú pháp ma_trận[chỉ_số]. Julia lưu ma trận theo cột, chúng ta có thể dùng chỉ số 1 chiều hoặc 2 chiều để lấy ra phần tử của ma trận.\n1 2 3 4 5 6 7  M[2, 3] # hàng 2 cột 3, trả ra 6 M[4] # phần tử thứ 4, nhưng duyệt theo từng hàng, trả ra 2 M[end] # phân tử cuối cùng M[1:2, end] # hàng 1 tới hàng 2, cột cuối cùng M[end, [1, 3]] # cột 1 và 3, hàng cuối cùng M[[1, 2], [2, 3]] # đoán xem? :) M[:, end] # cột cuối   Trong Julia, việc gán ma trận sẽ không tạo bản copy của ma trận đó, trừ khi bạn lấy một phần của ma trận:\n1 2 3 4 5 6  L = M L[1] = 2 # M cũng bị thay đổi L = M[[1, 2], :] L[1] = 3 # M không bị đổi L = copy(M) # copy lại M, tạo ma trận mới L[1] = 3 # M không bị đổi   Các phép toán với vector, ma trận được thực hiện rất tự nhiên (theo quy tắc toán học):\n1 2 3 4 5 6 7 8 9 10 11  A * B # báo lỗi, hai vector có chiều 1 × 3 không nhân với nhau được A * B\u0026#39; # nhưng nếu B chuyển vị thành vector hàng thì ok :) M * N # hai ma trận (3, 3) nhân với nhau M * A # nhân ma trận (3, 3) với vector (3, 1) A + B # cộng vector M + N # cộng ma trận A + B\u0026#39; # lỗi, cộng vector ma trận phải cùng chiều A .+ B\u0026#39; # nhưng cộng từng phần tử lại là chuyện khác :) A .* B\u0026#39; # nhân phần tử cũng vậy luôn M ^ 5 # ma trận vuông có thể lấy lũy thừa M .^ 5 # lũy thừa từng phần tử   Lưu ý rằng, đối với trường hợp số thực, chúng ta có thể dùng A' để chuyển vị. Với ma trận số phức hãy dùng transpose. Để biết chi tiết hãy xem thêm:\n transpose: https://en.wikipedia.org/wiki/Transpose adjoint (dấu nháy): https://en.wikipedia.org/wiki/Conjugate_transpose  (sorry vì màu link khó nhìn, mình sẽ gửi issue lên người bảo trì theme này)\n Kết luận Ok, phần giới thiệu tới đây mình nghĩ đủ rồi. Vậy các là các bạn đã biết cách khai báo biến, cộng trừ nhân chia và những trò hay ho mà trên trường giáo viên sẽ bắt chúng ta ngồi tính sấp mặt. Hẹn gặp các bạn trong bài viết sau.\nBonus: nếu đang học đại học, giờ bạn có thể dùng Julia như một cái máy tính cá nhân (nhưng vạn năng hơn một tí)\n1 2  # Giải hệ phương trình A⋅X = B trong một nốt nhạc A^-1 * B   ","description":"Biến số, hằng số, kiểu dữ liệu và một số thao tác đơn giản với chúng trong Julia","id":15,"section":"posts","tags":["julia"],"title":"Julia Dojo: biến số, kiểu dữ liệu, phép toán","uri":"https://ndgnuh.github.io/julia-dojo/bien-so-va-kieu-du-lieu-trong-julia/"},{"content":"Chào mừng các bạn quay trở lại với series Julia Dojo. Hôm nay chúng ta sẽ học cách viết một chương trình trong Julia và làm thế nào để chạy nó.\nDân gian ta có câu:\n Lời chào cao hơn mâm cỗ\n\u0026ndash; Dân Gian Ta (mình cũng không biết đây là thằng nào)\n Lời chào rất quan trọng, trong lĩnh vực lập trình điều này không phải ngoại lệ. Do đó, hôm nay chúng ta sẽ viết chương trình \u0026ldquo;chào thế giới\u0026rdquo;, dân-gian-ta còn gọi là \u0026ldquo;hello world\u0026rdquo;.\nChương trình đầu tiên của bạn Hello world là chương trình rất quen thuộc nếu bạn đã học lập trình trước đây. Nó sẽ cho bạn cái nhìn đầu tiên về cấu trúc ngữ pháp của một ngôn ngữ lập trình. Đầu tiên, hãy mở một trình sửa văn bản, tạo một file tên hello-world.jl.\nTrước đây, đuôi file .j được sử dụng cho ngôn ngữ Julia. Sau này, họ đổi thành .jl, cá nhân mình thấy thích cái đuôi file này hơn.\nKhi tạo file xong, hãy điền nội dung sau vào file:\n1  println(\u0026#34;hello world\u0026#34;)   Xong, bạn hãy mở một terminal tại vị trí bạn lưu file trên, sau đó chạy lệnh.\n1  julia hello-world.jl   Dòng chữ \u0026ldquo;hello world\u0026rdquo; sẽ được in ra màn hình. Vậy là bạn đã viết và chạy thành công chương trình hello world của mình với Julia.\nRất nhiều cách để nói \u0026ldquo;hello world\u0026rdquo; Chúng ta sẽ chỉnh sửa chương trình hello world một chút. Ở trên mình dùng hàm println để in ra chuỗi hello world. Giờ mình sẽ giới thiệu một vài cách khác:\n1 2 3 4 5 6  println(\u0026#34;hello world\u0026#34;) print(\u0026#34;hello world\u0026#34;); println() @show \u0026#34;hello world\u0026#34; @info \u0026#34;hello world\u0026#34; @warn \u0026#34;hello world\u0026#34; @error \u0026#34;hello world\u0026#34;   Chạy file trên, chúng ta sẽ thu được output:\nhello world hello world \u0026quot;hello world\u0026quot; = \u0026quot;hello world\u0026quot; [ Info: hello world ┌ Warning: hello world └ @ Main /tmp/hello-world.jl:6 ┌ Error: hello world └ @ Main /tmp/hello-world.jl:7  Dòng đầu là kết quả của println, hàm này sẽ in ra tham số của nó, sau đó in kí tự ngắt dòng. Dòng thứ hai là kết quả của print, hàm này giống println nhưng không in kí tự ngắt dòng, do đó mình phải thêm một hàm println() trống ở phía sau. Các bạn để ý thêm. Ở dòng số 2 file hello-world.jl, mình có dấu ;. Đấu này không cần thiết khi bạn viết mỗi lệnh trên một dòng. Tuy nhiên nếu bạn cần viết hai lệnh trên cùng dòng thì sẽ cần tới nó để ngắt giữa hai lệnh. Ở dòng 3, macro @show in ra một điều \u0026ldquo;hiển nhiên\u0026rdquo;: \u0026quot;hello world\u0026quot; = \u0026quot;hello world\u0026quot;. Thực ra, cái này dùng để show ra giá trị của một biến hay hằng số, ở đây chúng ta truyền cho nó một hằng số nên nó in ra củ chuối như vậy\u0026hellip; Macro là gì ư? Tạm thời bạn đừng quan tâm, hãy tạm hiểu nó có dấu @ và làm một cái gì đó cho bạn. Ở dòng 4, chúng ta có @info. Macro này có tính ghi chú, nó chỉ nhận đầu vào là chuỗi kí tự thôi. @info được dùng để đưa ra bản ghi chép (log) cho chương trình của bạn. Ở dòng 5, chúng ta có @warn. Thằng này giống thằng @info, nhưng nó nói với giọng \u0026ldquo;bố đang cảnh báo mày đấy\u0026rdquo;. Tuy hổ báo nhưng nó sẽ không đừng việc thực thi chương trình của bạn. @warn thường được dùng khi một người viết gói chương trình muốn deprecate (tạm dịch là cho lỗi thời, mình không biết dịch như nào cho hay) một tính năng nào đó và cảnh báo người dùng không nên dùng nó. Cuối cùng, chúng ta có @error. Thằng này nó sẽ cảnh báo và cho chương trình của bạn bay màu luôn. @error được dùng rất nhiều. Bạn sẽ gặp nó khi gọi một hàm không tồn tại chẳng hạn.  Chế độ tương tác Bạn có thấy viết hẳn một file, chỉ dành cho một dòng code mà in ra hello world có hơi thừa? Nếu vậy hãy mở terminal ra, chạy câu lệnh sau:\n1  julia   Chế độ tương tác Julia (hay Julia REPL) sẽ chào đón bạn với một cái logo ascii (không có mèo đâu, đấy là hình nền của mình :P)\nchế độ tương tác Julia   Bạn có thể chạy \u0026ldquo;hello world\u0026rdquo; bằng cách nhập câu lệnh trên vào và nhấn Enter:\nhello world trong một dòng   Thậm chí bạn có thể gõ ?println và xem thông tin về những thứ mình vừa viết ở trên.\nchế độ help   Goodbye, world Ok, vậy là bạn đã biết những cách đơn giản nhất viết và chạy chương trình Julia (và cũng là chương trình đơn giản nhất luôn). Chúng ta sẽ lần lượt tìm hiểu những phương thức khác trong các bài tiếp theo. Riêng với chế độ tương tác, mình có thể làm một bài nữa, nói về những tính năng của nó. Hẹn gặp lại các bạn trong những bài viết sau :)\n","description":"Viết chương trình đầu tiên của bạn trong Julia","id":16,"section":"posts","tags":["julia"],"title":"Julia Dojo: Hello world","uri":"https://ndgnuh.github.io/julia-dojo/hello-world/"},{"content":"Chào mừng các bạn đến với bài viết đầu tiên của series \u0026ldquo;Julia Dojo\u0026rdquo;. Trong bài viết này mình sẽ hướng dẫn các bạn cách cài đặt Julia.\nĐể cài Julia, chúng ta có 2 cách:\n Cài đặt từ bản phân phối chính thức: cách này được khuyến cáo vì nó sẽ không gây lỗi lặt vặt, tuy nhiên quá trình cài đặt sẽ hơi dài một chút. Cài đặt từ bản phân phối của cộng đồng: cách này rất đơn giản, đặc biệt với những bạn dùng Linux. Tuy nhiên cách này có thể gây lỗi vặt (thực ra mình mới chỉ thấy một lỗi trên ArchLinux, chưa thấy có người gửi issue nào khác)  Mình sẽ hướng dẫn các bạn cả hai cách. Việc cài đặt có thể sử dụng tới terminal (dòng lệnh, hiểu nôm na là vậy), vậy có kiến thức cơ bản về việc sử dụng terminal và shell có thể sẽ hữu dụng và giúp quá trình cài đặt dễ dàng hơn. Nếu bạn không biết những thứ này cũng không nên lo quá.\nCài đặt bản phân phối từ cộng đồng Vì cách này ngắn và đơn giản hơn, mình sẽ hướng dẫn trước. Để thực hiện cách cài đặt này, bạn cần có package manager. Cái này trên *Nix thì có chắc chắn có sẵn, còn trên MacOS và Windows có lẽ bạn sẽ phải cài thêm. Khi xong xuôi, bạn chỉ cần mở terminal và ehạy lệnh tương ứng với hệ điều hành của mình:\n  Windows - Chocolately  Cài đặt:\n1  choco install julia --confirm   Cập nhật:\n1  choco upgrade julia --confirm        MacOs - HomeBrew  HomeBrew trên Mac 1  brew cask install julia        Fedora/Red hat/Cent OS và các distro tương tự  Với Fedora bản 19 hoặc hơn:\n1 2  sudo dnf copr enable nalimilan/julia sudo yum install julia   Nếu bạn dùng Cent OS bản 7 hoặc hơn:\n1 2  sudo yum-config-manager –add-repo https://copr.fedorainfracloud.org/coprs/nalimilan/julia/repo/epel-7/nalimilan-julia-epel-7.repo sudo yum install julia   Nếu dnf và yum-config-manager không khả dụng trên hệ thống của bạn, hãy tải file .repo tương ứng ở link phía trên và copy vào /etc/yum.repos, sau đó chạy câu lệnh thứ 2.\nĐể cập nhật Julia:\n1  yum upgrade julia        Debian/Ubuntu và các distro tương tự  Cài đặt:\n1 2  sudo apt update sudo apt install julia   Cập nhật:\n1 2  sudo apt update sudo apt upgrade        Archlinux và các distro tương tự  Cài đặt:\n1 2 3 4  sudo pacman -S julia # bản không chính thức # những bản này cần `yay` để cài tự động sudo yay -S julia-bin # tương ứng với bản chính thức từ trang chủ yay -S julia-git # tương ứng vởi bản build từ git   Cập nhật:\n1 2 3  sudo pacman -Syu # hoặc yay -Syu      Cài đặt từ bản phân phối chính thức Việc cài đặt sẽ chia thành ba bước. Đầu tiên, bạn cần truy cập trang tải về của Julia để lấy bản phân phối chính thức. Mình sẽ hướng dẫn chi tiết quá trình cài đặt. Bước tiếp theo là giải nế và cài đặt. Cuối cùng, chúng ta sẽ cài đặt biến môi trường để có thể truy cập vào Julia mọi lúc mọi nơi.\nTải Julia Trang download Julia   Julia cung cấp một số lựa chọn:\n Current stable release: phiên bản ổn định. Bản Release Candidate: phiên bản ứng cứ viên phát hành, có thể hiểu là \u0026ldquo;gần\u0026rdquo; ổn định.. Long-term support: Phiên bản hỗ trợ lâu dài, bạn có thể hiểu đây là phiên bạn \u0026ldquo;cực kì ổn định\u0026rdquo;. Bản Nightly: Bản thử nghiệm, dành cho những thanh niên thích thử nghiệm.  Sau khi đã quyết định sẽ sử dụng phiên bản nào, hãy tải về bản cài đặt phù hợp với hệ điều hành của bạn. Ví dụ nếu mình dùng Windows 64 bit hãy tải file Windows (.exe) ở cột 64-bit (trong ảnh).\nGiải nén và cài đặt   Windows  Sau khi tải Julia như trên, chúng ta sẽ có một file .exe. Mở file exe này lên. Việc cài đặt tương đối đơn giản, chỉ cần next, next và next.\nLưu ý rằng, quá trình cài đặt có một bước chọn đường dẫn giải nén. Hãy lưu lại đường dẫn này để sử dụng ở bước sau.\n    MacOS  Sau khi tải Julia như trên, chúng ta sẽ có một file .dmg. Mở file .dmg ấy, bên trong có file Julia-\u0026lt;phiên-bản\u0026gt;.app. Kéo thả file này vào thư mục Application trên desktop của bạn và bạn đã hoàn thành bước này.     Linux, BSD, *Nix  Sau khi tải Julia như trên, chúng ta sẽ có một file .tar.gz. Hãy copy file này vào vị trí cài đặt tương ứng, sau đó giải nén file này ra bằng lệnh:\n1  tar -xvf đường/dẫn/tới/\u0026lt;file-của-bạn\u0026gt;.tar.gz   Một vài file, thư mục mới sẽ xuất hiện, vậy là bạn đã hoàn thành bước này.\n  Thêm đường dẫn đến Julia vào biến môi trường Để có thể gọi Julia từ mọi nơi, bạn cần thêm đường dẫn tới file thực thi Julia vào biến $PATH. Tuy cả ba nhóm hệ điều hành trên đều dùng biến môi trường này, cách cài đặt sẽ khác nhau một chút.\n  Windows 10   Nhấn tổ hợp phím Windows + R, gõ sysdm.cpl và nhấn Enter Một cửa sổ hiện lên, hãy chọn thẻ Advanced, chọn Environment Variables. Thêm một cửa sổ nữa hiện lên, trong phần System variables, chọn Path và click vào nút Edit Một cửa sổ hiện ra, nhấn New. Một cửa sổ mới hiện ra với một hộp văn bản Lấy đường dẫn cài đặt ở bước 2 ra, thêm \\bin vào đuôi và copy vô cái hộp văn bản đó. Ví dụ mình cài Julia vào E:\\julia, mình sẽ ghi E:\\julia\\bin. Ấn Ok, tắt hết các hộp thoại, giờ bạn đã cài xong Julia.      Windows khác   Nhấn tổ hợp phím Windows + R, gõ sysdm.cpl và nhấn Enter Một cửa sổ hiện lên, hãy chọn thẻ Advanced, chọn Environment Variables. Thêm một cửa sổ nữa hiện lên, trong phần System variables, chọn Path và click vào nút Edit Sau khi nhấn Edit, sẽ có một cửa sổ với 2 hộp văn bản xuất hiện. Click vào hộp văn bản thứ 2 (Variable value:) và di chuyển đến cuối dòng, nếu cuối dòng không có dấu ; hãy thêm dấu ; vào. Lấy đường dẫn cài đặt ở bước 2 ra, thêm \\bin vào đuôi và copy thêm vào cuối của hộp văn bản thứ 2. Ví dụ mình cài Julia vào E:\\julia, mình sẽ ghi thêm E:\\julia\\bin vào cuối. Nhắc lại rất kĩ là ghi thêm nhé, ông nào paste đè lên cái cũ xong hỏng máy tôi không chịu trách nhiệm đâu. Ấn Ok, tắt hết các hộp thoại, giờ bạn đã cài xong Julia.      MacOS   Chạy open -a TextEdit ~/.bash_profile trên Terminal. Nếu bạn dùng zsh thì thay .bash_profile bằng .zshrc (nếu bạn không biết bạn đang dùng cái gì thì đừng để ý đoạn zsh này). Lệnh trên sẽ mở file ~/.bash_profile để bạn chỉnh sửa. Thêm dòng export PATH=\u0026quot;/Applications/Julia-.app/Contents/Resources/julia/bin:${PATH}\u0026quot; vào cuối và save lại.      Linux, BSD, *Nix  Bạn có 3 lựa chọn như dưới đây, sau khi thực hiện một trong ba bạn sẽ có thể sử dụng Julia.\n Thêm thư mục Julia vào biến $PATH bằng cách thêm dòng lệnh mình ghi ở dưới vào trong file ~/.bashrc và ~/.bash_profile. Thay hai file trên với ~/.zshrc nếu bạn dùng zsh. Thay những file trên với /etc/profile, /etc/bash.bashrc hoặc /etc/zsh nếu bạn muốn cài đặt trên toàn hệ thống.  1  export PATH=\u0026#34;$PATH:/đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin\u0026#34;    Chạy lệnh echo $PATH xem biến $PATH của bạn có những thư mục nào, ví dụ mình sẽ chọn /usr/bin. Sau đó, hãy tạo liên kết tới Julia trong thư mục đó bằng lệnh sudo ln -s /đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin/julia /usr/bin/ (mình dùng sudo vì cần quyền ghi vào /usr/bin, nếu người dùng của bạn ghi được vào thư mục trên $PATH thì không cần sudo) Cách cục súc: bạn sẽ chạy /đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin/julia mỗi lần bạn dùng đến nó.    Lưu ý thêm cho những bạn dùng Windows   Nếu bạn dùng Windows 7   bản update này sẽ giúp trình quản lý gói của Julia hoạt động. Xuống phần Method 2 và click vào link Microsoft Update Catalog. Windows Management Framework 3.0 hoặc hơn để cài Powershell. Vào trang web trên, kéo xuống dưới cái bảng và click vào phiên bản bạn muốn download.    Nhìn chung, nếu bạn dùng Windows, mình khuyên các bạn nên tìm một terminal khác ngoài cmd và cái đi kèm với Powershell. Một số gợi ý cho các bạn:\n Terminal của Visual Studio Code Git bash  Tổng kết Các bạn có thể cài đặt Julia theo cách mình muốn. Bản cài chính thức cài đặt sẽ dài dòng hơn một chút nhưng đảm bảo hơn, bản cài do cộng đồng phân phối sẽ tiện lợi hơn với một tỉ lệ rất rất nhỏ xảy ra bug. Để kiểm tra việc cài đặt Julia có thành công hay không, hãy mở Terminal và chạy lệnh julia.\nNếu lệnh chạy thành công, chúng ta sẽ thấy màn hình Julia chào đón mình   ","description":"Hướng dẫn tải và cài đặt Julia trên máy tính của bạn","id":17,"section":"posts","tags":["julia"],"title":"Julia Dojo: cài đặt Julia","uri":"https://ndgnuh.github.io/julia-dojo/cai-dat-julia/"},{"content":"Julia là gì? Tại sao lại học nó? Julia là một ngôn ngữ lập trình bậc cao dễ sử dụng, nhanh và mạnh mẽ. Một số đặc trưng của Julia cũng như lí do bạn sẽ muốn dùng nó (hoặc không):\n Julia là phần mềm tự do \u0026amp; mã nguồn mở (giấy phép MIT) Kiểu dữ liệu người dùng định nghĩa nhanh và gọn giống như các kiểu built-in Không cần chủ động vector hóa code vì hiệu năng, code chưa vector hóa cũng nhanh Green threading Hệ thống kiểu dữ liệu tự nhiên, mạnh mẽ Chuyển đổi và thăng cập một cách \u0026ldquo;thanh nhã\u0026rdquo; giữa các kiểu dữ liệu Hỗ trợ rất tốt Unicode, không giới hạn ở UTF-8. Gọi trực tiếp code C, không cần wrapper hay API Có thể thực hiện tốt các khả năng của shell hệ thống, quản lí các tiến trình khác Macro, metaprogramming Julia miễn phí và mã nguồn mở (giấy phép MIT) Multiple dispatch (cái này có thể khiến bạn cảm giác lạ lạ, nhưng nó đỉnh lắm) Julia hứa hẹn sẽ giải quyết vấn đề hai ngôn ngữ  Khoan, nhiều \u0026ldquo;điểm tốt\u0026rdquo; quá, nghe vô lý. Thằng Python bậc cao nhưng nó chậm như rùa, mọi thư viện đều phải binding và viết với C. Thằng C thì nhanh, nhưng mà để viết được nó thì không phải ông nào cũng làm được. Thằng Matlab thì nhanh và dễ viết thật, nhưng bạn ơi, tiền đâu mà dùng Matlab, ngồi crack thôi chứ còn gì. Hơn nữa, Matlab nếu bạn dùng cho mục đích cá nhân thì crack được, chứ một tổ chức hay cơ quan thì họ sẽ bảo rằng:\n Ở đây chúng tôi không làm vậy\n\u0026ndash; Họ không dùng Matlab ở Wakanda\n Ok, mình vẫn chưa giải thích tại sao có nhiều \u0026ldquo;điểm tốt\u0026rdquo; như vậy. Julia đạt được những điều như trên vì 2 lí do:\n Julia dùng Just Intime Compiler (JIT) Việc biên dịch của Julia cực kì phức tạp, khiến cho mã Julia khi dịch xong có tốc độ so sánh được với C hoặc Fortran  Micro benchmark theo thời gian chạy một số ngôn ngữ, thời gian chạy của C được lấy làm mốc. Các ngôn ngữ khác được so sánh tương đối.   Đương nhiên, Julia cũng có khiếm khuyết, không có cái gì hoàn hảo cả. Và cộng đồng cũng rất cố gắng để cải thiện, xử lý chúng.\n Cộng đồng Julia nhỏ một cách tương đối so với những \u0026ldquo;ông lớn\u0026rdquo; như Python, đặc biệt là cộng đồng người Việt. Mình cho rằng đây là vấn đề thời gian, và vấn đề này cũng là lí do mình ở đây, viết cái đống này cho các bạn :). Mảng trong Julia đánh chỉ số từ 1. Có thể bạn đang nghĩ rằng sẽ dừng đọc và drop cái ngôn ngữ của nợ này ngay tại đây, hãy khoan đã. Theo mình thấy, vấn đề chỉ số này không ảnh hưởng nhiều lắm. Việc đánh chỉ số từ 0 được ông Dijikstra đưa ra và áp dụng trong kha khá ngôn ngữ lập trình, nhưng vẫn có những người dám phản dmg ông và đi theo trường phái khác. Cá nhân mình không có thành kiến gì với cả hai trường phái đâu, mình chỉ muốn nói cả hai đều có thể dùng được. Lí do duy nhất mình đưa cái này vào khuyết điểm vì có thể nó sẽ \u0026ldquo;dọa\u0026rdquo; những người mới.   Tôi không biết bao nhiêu người trong số các ông đã đích thân gặp Dijikstra, nhưng các ông chắc đều biết rằng - sự kiêu ngạo trong tính toán khoa học được đo bằng nano-Dijikstra.\n\u0026ndash; Alan Kay (mình không biết ông này nhưng mà câu nói của ổng làm mình thấy khoái)\n Lần đầu chạy code sẽ lâu hơn một chút. Ví dụ khi mình tạo random 100000 số kiểu double, lần đầu chạy rand(Float64, 100000) sẽ mất khoảng 0.06, những lần tiêp theo thời gian sẽ giảm đi còn 0.002 (nhanh gấp khoảng 30 lần). Có lẽ đây là vấn đề lớn nhất trong Julia. Nếu bạn hiểu JIT là cái gì, bạn sẽ thấy đặc điểm này gần như không thể tránh được. Tuy nhiên, với những người định \u0026ldquo;dùng thử\u0026rdquo; Julia, họ sẽ trải nghiệm thời gian compile và tưởng nó là runtime, sau đó sẽ nghĩ rằng \u0026ldquo;cái này không nhanh như quảng cáo\u0026rdquo;. Điều này ảnh hưởng rất nhiều tới khuyết điểm số 1. Hiện tại, cộng đồng Julia đang rất ưu tiên giải quyết vấn đề này, họ đã tìm cách giảm thời gian compile đáng kể, đồng thời có cách để compile hoàn toàn mã nguồn Julia dưới dạng thư viện liên kết động. Scala là cái tên được ghép từ \u0026ldquo;scalable\u0026rdquo; và \u0026ldquo;language\u0026rdquo;. Swift mang nghĩa chuyển động trơn tru và tốc độ cao. Ruby là một viên đá quý. C++ là C tăng lên 1 level. C là kế tiếp của B. Matlab là viết tắt của Matrix Laboratory, thậm chí trong một ngôn ngữ nào đó, nó có nghĩa là sự thông thái\u0026hellip; Vậy Julia cái tên Julia thì sao, nó có ý nghĩa gì?   Đây là câu hỏi ưa thích của mọi người. Thực ra chả có lí do gì đâu, nghe cái tên nó hay hay.\n\u0026ndash; Stefan Karpinski =))\n Huyên thuyên về Julia đủ rồi. Rất tiếc nếu mình không thuyết phục được bạn. Tuy nhiên, nếu bạn quyết định thử Julia và cho nó một cơ hội, hãy chuyển qua phần tiếp theo và bước vào Julia Dojo.\nJulia Dojo Vậy là bạn quyết định cho Julia một cơ hội, mình sẽ cảm ơn các bạn bằng một series hướng dẫn \u0026amp; thảo luận cơ bản, mang tên \u0026ldquo;Julia Dojo\u0026rdquo;. Series này sẽ tổng hợp từ rất một vài nhiều nguồn kiến thức, nhưng chủ yếu mình sẽ lấy từ 3 nguồn:\n Tài liệu chính thức Julia Con (một hội thảo được tổ chức hàng năm) Hiểu biết cá nhân  Tài liệu chính thức và Julia Con, mọi người có thể xem một cách miễn phí trên mạng nếu nếu không ngại tiếng Anh.\nÝ tưởng chính của Julia Dojo là: chúng ta sẽ train từng level một. Với mỗi level chúng ta sẽ đi sâu vào trong hệ thống của Julia hơn và thấy các thứ liên kết với nhau như thế nào. Trang này sẽ là nơi mình update các level của Dojo cùng với nội dung trong đó mỗi khi có bài mới.\nCó những bài viết mình đánh đấu là \u0026ldquo;tùy chọn\u0026rdquo; hoặc \u0026ldquo;nên xem\u0026rdquo;, bạn không nhất thiết phải đọc vì nó không phải một \u0026ldquo;cơ bản\u0026rdquo; của Julia. Mình có để intro ở đầu mỗi bài viết, nếu bạn thấy không hứng thú hoặc phần đó bạn đã biết rồi, bạn có thể skip.\nLayout phía dưới có những phần dự định, có thể khi mình viết bài thực sự mình sẽ thêm bớt hoặc chuyển chỗ một vài thứ trong đó.\n Tất cả bài viết có thể được tìm thấy tại đây\n  Tải và cài đặt\n  Hello\n  Biến số \u0026amp; Kiểu dữ liệu\n  Cấu trúc điều khiển\n  Hàm\n  IJulia, jupyter notebook\n  Quản lý gói\n  Làm việc với file\n  Từ điển và tập hợp\n  Nói thêm về kiểu dữ liệu\n  Multiple Dispatch\n  Macro và meta programming\n  Về các module, gói Vì có rất nhiều module của Julia mang tính chuyên ngành cao, mà trình độ của mình có giới hạn nên mình sẽ không cover hết được (mấy cái mô hình hóa sinh thì chịu rồi, mình dốt hóa). Do đó, nếu các bạn muốn hướng dẫn, giới thiệu một gói nào đó. Các bạn có thể:\n Gửi một đường dẫn cho mình tới blog của các bạn, mình sẽ gắn nó vào đây Gửi cho mình bài viết của các bạn kèm với một số thông về bạn, mình sẽ ghi credit đầy đủ cho các bạn, trừ khi bạn không muốn (nhưng mình vẫn sẽ ghi rõ bài viết do độc giả đóng góp) Dịch trang tài liệu chính thức của gói đó và đóng góp cho họ  Tạm kết Fun fact: \u0026ldquo;Julia\u0026rdquo; nghe rất giống tên của một phụ nữ trong nhiều nền văn hóa, do đó, dù quy chuẩn của cộng đồng cho rằng Julia không dựa trên tên của ai và ngôn ngữ này không được nhân hóa dưới bất kì hình thức nào, một cơ số người khi nói về ngôn ngữ này vẫn vô thức dùng đại từ \u0026ldquo;cô ấy\u0026rdquo;, trong đó có cả mình :))  Ok, mình nghĩ đến đây là đủ cho bài giới thiệu. Chắc các bạn cũng đoán ra được rằng, mình đang muốn mở rộng cộng đồng người dùng Julia, cụ thể hơn là ở Việt Nam. Một lần nữa, nếu bạn quyết định cho Julia một cơ hội, mình xin cảm ơn. Mình sẽ cố viết post chất lượng và giải đáp thắc mắc của các bạn. Nếu thấy có thiếu sót, đừng ngại gửi lại phản hồi cho mình.\n","description":"","id":18,"section":"posts","tags":["julia"],"title":"Julia Dojo: giới thiệu","uri":"https://ndgnuh.github.io/julia-dojo/"},{"content":"whoami? Xin chào mọi người, mình là Hùng, một open source enthusiast, và là một sinh viên.\nWhat am I doing here? Blog này dự kiến sẽ dùng để chia sẻ kiến thức và bàn chuyện trên trời dưới đất. Cụ thể hơn, mình sẽ chia sẻ hiểu biết của mình (chủ yếu) về Linux, lập trình và có thể là một ít toán nữa.\nHiện tại mình blog chưa được implement tính năng bình luận, tạm thời các bạn đọc nếu có thắc mắc, ý kiến đóng góp hay ném gạch chịu khó gửi một email hay để lại một issue trên Github cho mình.\n Email: ndgnuh@protonmail.com Repo github cho trang này: https://github.com/ndgnuh/ndgnuh.github.io  Blog viết bởi một sinh viên, do tác giả còn rất nhiều thứ phải học nên khả năng cao sẽ gặp sai sót. Nếu bạn đọc phát hiện ra lỗi gì, về kĩ thuật, nội dung, câu cú hay lỗi chính tả ₍•⌣•₎ của trang cứ thoải mái đóng góp ý kiến nhé.  ","description":"","id":19,"section":"","tags":null,"title":"Giới thiệu","uri":"https://ndgnuh.github.io/about/"}]