[
{
	"uri": "https://ndgnuh.github.io/",
	"title": "#Rant",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ndgnuh.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ndgnuh.github.io/categories/h%C6%B0%E1%BB%9Bng-d%E1%BA%ABn/",
	"title": "hướng dẫn",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ndgnuh.github.io/tags/julia/",
	"title": "julia",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ndgnuh.github.io/series/julia-dojo/",
	"title": "Julia Dojo",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ndgnuh.github.io/julia-dojo/re-nhanh-va-lap-trong-julia/",
	"title": "Julia Dojo: cấu trúc điều khiển",
	"tags": ["julia"],
	"categories": [],
	"series": ["Julia Dojo"],
	"description": "Cấu trúc điều kiện và lặp trong Julia",
	"content": "Chào mừng các bạn trở lại với Julia Dojo. Chúng ta đã tìm hiểu về cách khai báo biến và làm việc với một số kiểu dữ liệu trong bài viết biến số, kiểu dữ liệu, phép toán. Nhưng một chương trình chỉ có gán, gọi hàm và phép toán không thì không đủ, do đó, chúng ta ta có các cấu trúc điều khiển.\nĐến phần này, chúng ta sẽ phải biết cách nhận biết một khối lệnh trong Julia. Trong các ngôn ngữ như C hoặc Java, chúng ta dùng một cặp { } để đánh dấu các dòng lệnh. Ở đây chúng tôi không làm vậy.\nLỗi: meme được dùng đi dùng lại quá nhiều Thay vào đó, mỗi từ khóa end sẽ được kết hợp với các từ khóa lặp, khai báo hàm, rẽ nhánh\u0026hellip; ở đầu của một khối lệnh. Một cặp \u0026ldquo;từ khóa mở đầu - end\u0026rdquo; sẽ đánh dấu một khối lệnh trong Julia.\nMình là người có điều kiện If\u0026hellip; Hãy thử tượng tượng phải lập trình nhưng không được dùng các cấu trúc rẽ nhánh xem. Bạn sẽ làm ra một chương trình mà, hoặc không thể sử dụng được, hoặc chứa một đống các loại đa hình để thay cho cấu trúc rẽ nhánh (cũng không lí tưởng lắm!). Vậy nên, tội gì không sử dụng if - else cho cuộc sống dễ dàng.\n1 2 3 4 5 6 7 8  x = rand(-1:1) if x == 1 println(x) elseif x == 0 println(x + 1) else println(x + 2) end   Chúc mừng, bạn đã viết thành công chương trình in ra số 1 (dùng if - else - end). Trong cấu trúc rẽ nhánh, các từ khóa elseif, else là không bắt buộc, nếu bạn không có nhiều trường hợp thì không phải viết chúng.\nNếu các bạn đang tự hỏi Julia có cấu trúc switch hay không, mình trả lời luôn là không, lí do là\u0026hellip; không cần thiết. Thực chất cấu trúc switch có thể được thay thế bằng if và một đống elseif, mỗi điều kiện chính là một case, và else chính là default.\nToán tử ba ngôi Trong Julia, mọi cấu trúc if đều trả về một giá trị nào đó. Bạn hoàn toàn có thể viết như sau:\n1 2 3 4 5 6  @show a = rand(0:1) # a nhận giá trị 0 hoặc 1, ngẫu nhiên b = if a == 0 0 else 1 end; println(\u0026#34;b=$b\u0026#34;)   Đoạn chương trình trên\u0026hellip; in ra số 0 và gắn b bằng a rồi in ra b. Giá trị của if trả về chính là câu lệnh cuối cùng mà nó chạy. nhưng nếu thích bạn có thể viết từ khóa return để \u0026ldquo;trang trí\u0026rdquo;.\n1 2 3 4 5  b = if a == 0 return 0 else return 1 end   Nhưng mà thực sự, đừng làm như vậy :) Chúng ta có toán tử ba ngôi cho những việc như thế này.\n1 2  a = rand(0:1) b = (a == 1) ? 1 : 0   Vẫn là chương trình random a rồi gán b bằng a, nhưng gọn hơn rất nhiều (mình không nói là cách gọn nhất\u0026hellip;). Dấu ngoặc bao quanh điều kiện là không cần thiết, nhưng mình viết vậy vì nó dễ nhìn.\nNếu dùng @show lên toán tử ba ngôi, chúng ta sẽ thấy nó chỉ là một khối if được đơn giản hóa.\n1 2 3 4 5 6 7  julia\u0026gt; @show (x == 1) ? 1 : 0 if x == 1 1 else 0 end = 1 1   Phạm vi của biến trong if Những biến được khai báo trong khối if sẽ tồn tại ở cả bên ngoài khối. Ví dụ trong đoạn code dưới đây:\n1 2 3 4 5 6  if rand(Bool) x = 1 else x = 10 end @show x   Nếu biến x chưa tồn tại, nó sẽ được khai báo. Nếu nó đã tồn tại, giá trị của nó sẽ được thay đổi. Việc thêm từ khóa local sẽ không có tác dụng gì. Nói cách khác, khối if có cùng phạm vi biến (scope) với khối lệnh chứa nó\nLặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp\u0026hellip; Vòng lặp for Thử tưởng tượng lập trình mà không có vòng lặp xem (thực ra các bạn có thể dùng đệ quy thay cho vòng lặp, nhưng mình thấy lặp vẵn dễ sống hơn!). Julia cung cấp cho chúng ta hai loại vòng lặp. Đầu tiên là vòng lặp for để lặp với số lần xác định trước:\n1 2 3  for i = 1:10 println(i) end   Bạn cũng có thể dùng lặp với từng phần tử của một tập hợp hay một mảng nào đó.\n1 2 3 4  arr = [1, 2, 3] for x in arr println(x) end   Chúng ta cũng có thể lặp qua một xâu kí tự:\n1 2 3 4  s = \u0026#34;xinchào\u0026#34; for i = 1:length(s) println(s[i]) end   Khi chạy đoạn code trên, chúng ta sẽ thu được\u0026hellip; lỗi.\n1 2 3 4 5 6  ERROR: StringIndexError(\u0026#34;xin chào\u0026#34;, 8) Stacktrace: [1] string_index_err(::String, ::Int64) at ./strings/string.jl:12 [2] getindex_continued(::String, ::Int64, ::UInt32) at ./strings/string.jl:220 [3] getindex(::String, ::Int64) at ./strings/string.jl:213 [4] top-level scope at ./REPL[4]:2   Điều này xảy ra vì Julia hỗ trợ unicode, do đó không phải string nào cũng là ascii (bạn có thể kiểm tra bằng hàm isascii). Những kí tự không nằm trong bảng ascii sẽ chiếm một số lượng index không xác định. Vậy muốn lặp qua một xâu kí tự an toàn thì làm như thế nào?\n1 2 3  for i in eachindex(s) println(s[i]) end   Hàm eachindex sẽ sinh ra một bộ chỉ số của xâu s và bạn có thể lặp qua từng kí tự của s một cách an toàn. Hơn nữa, eachindex nhìn đẹp hơn 1:length(s). Nếu bạn không cần chỉ số mà chỉ cần kí tự, bạn có thể lặp như sau:\n1 2 3  for c in s println(c) end   Không chỉ với string, eachindex hoạt động với tất cả các kiễu dữ liệu có thể lặp được (nói sau nhé), bao gồm cả mảng, ma trận. Nếu mình không nhầm, dùng nó cũng có lợi về hiệu năng hơn vì Julia sẽ không phải kiểm tra việc đánh chỉ số có đúng hay không.\nBạn có thể dùng nhiều vòng lặp lồng nhau như các ngôn ngữ lập trình khác:\n1 2 3 4 5 6 7  for i = 1:2 for j = 3:4 for k = 5:6 @show (i, j, k) end end end   Trong trường hợp vòng lặp bên ngoài không có nhiệm vụ gì ngoài gọi vòng lặp con như trên, code của chúng ta sẽ trông như cái tam giác trống, nhìn hơi tù. Julia cung cấp cho chúng ta cách chồng các vòng lặp lên nhau.\n1 2 3  for i=1:2, j=3:4, k=5:6 @show (i, j, k) end   Đoạn code này sẽ in ra cùng một kết quả như trên, nhưng lại gọn gàng và dễ nhìn hơn. Dù sao, nếu bạn phải dùng tới ba bốn vòng lặp, logic trong code của bạn có thể đã trở nên phức tạp và đó là dấu hiệu của việc bạn nên viết hàm.\nVòng lặp while Cấu trúc lặp while thực ra mạnh mẽ hơn lặp for rất nhiều, nó có thể dùng để lặp với số lần lặp không xác định. Vòng lặp while không có nhiều thứ cần đặc biệt lưu ý giống như for, các bạn có thể dùng nó với cú pháp như sau:\n1 2 3 4 5  điều_kiện = true # biểu thức điều kiện while điều_kiện # làm gì đó # với dữ liệu end   Phạm vi biến của cấu trúc lặp Vòng lặp trong julia có phạm vi biến riêng. Điều đó có nghĩa, các vòng lặp sẽ không thay đổi các biến toàn cục một các tùy tiện.\n1 2 3 4 5 6  # phạm vi toàn cục (global scope) x = 10 for i = 1:10 x = i # biến i vẫn truy cập được end @show x # x vẫn là 10   Tuy nhiên, khi vòng lặp được lồng trong một phạm vi nội bộ (một vòng lặp khác, một hàm), chúng có thể cập nhật biến trong phạm vi đó:\n1 2 3 4 5 6 7  for i = 1:2 x = i for j = 3:4 x = x * j end @show x # biến x sẽ thay đổi end   Nếu bạn muốn thay đổi biến toàn cục, hãy dùng từ khóa global:\n1 2 3 4 5  x = 10 for i = 1:5 global x *= i end @show x # x = 1200   Thoát lặp, nhảy lặp Nếu bạn đang lặp mà muốn dừng giữa chừng, bạn có thể dùng break để thoát hoàn toàn khỏi vòng lặp.\n1 2 3 4 5 6 7  đếm = 1 while true global đếm += 1 if đếm == 4 break end end   Nếu vì lí do nào đó, bạn muốn nhảy cóc một vòng lặp, bạn có thể dùng từ khóa continue.\n1 2 3 4 5 6 7  for i = 1:4 if i == 3 continue else @show i end end   Với những đoạn rẽ nhánh đơn giản như trên, chúng ta có thể dùng kết hợp với toán tử ba ngôi cho gọn:\n1 2 3  for i = 1:4 i == 3 ? continue : @show i end   Tạm kết Sau khi biết được các cấu trúc điều khiển cơ bản. Hãy nhớ rằng nếu bạn lồng quá nhiều cấu trúc điều khiển với nhau, bạn có thể đang cần tách logic trong code ra thành một hàm. Viết hàm thế nào, hồi sau sẽ rõ :) Hẹn gặp lại các bạn ở bài viết sau.\n"
},
{
	"uri": "https://ndgnuh.github.io/categories/l%E1%BA%ADp-tr%C3%ACnh/",
	"title": "lập trình",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ndgnuh.github.io/posts/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ndgnuh.github.io/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ndgnuh.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ndgnuh.github.io/julia-dojo/bien-so-va-kieu-du-lieu-trong-julia/",
	"title": "Julia Dojo: biến số, kiểu dữ liệu, phép toán",
	"tags": ["julia"],
	"categories": [],
	"series": ["Julia Dojo"],
	"description": "Biến số, hằng số, kiểu dữ liệu và một số thao tác đơn giản với chúng trong Julia",
	"content": "Chào mừng các bạn trở lại với Julia Dojo. Hôm nay chúng ta sẽ tìm hiểu về một thứ khá cơ bản và thiết yếu trong các ngôn ngữ lập trình, đó là biến số (ok, không hẳn là thiết yếu, nhưng nó làm cuộc sống dễ dàng hơn), đồng thời khám phá một số kiểu dữ liệu cơ bản và thao tác với chúng.\nBiến số, hằng số Đôi khi, trông các bài hướng dẫn về ngôn ngữ lập trình, họ đồng nhất biến số và hằng số theo kiểu \u0026ldquo;hằng số là một biến số mà không thể thay đổi\u0026rdquo;. Điều này không đúng lắm về mặt kĩ thuật (technically correct is the best kind of correct). Tuy nhiên, nếu nó tiện lợi, nghe thuận tai và dễ hiểu hơn với bạn thì\u0026hellip; meh, tùy, whatever floats your boat. Để khai báo một biến trong Julia, bạn chỉ cần sử dụng cú pháp:\n1 2  tên_biến = \u0026#34;giátrị\u0026#34; こんにちは世界 = \u0026#34;Helloworld,googledịchvậy:)\u0026#34;   Điều hay nhất là: hai dòng lệnh trên hoàn toàn hợp lệ trong Julia (copy nó vào REPL và chạy thử đi!). Tên biến số, hằng số trong Julia có thể Là kí tự unicode, và các kí tự tiếng Việt không phải ngoại lệ. Tuy nhiên, mình nghĩ bạn không nên code bằng tiếng Việt có dấu, tiêng Nhật, tiếng Tàu hay tiếng Thái đâu. Cách tốt nhất để dùng tính năng này là:\n1 2 3 4 5 6 7 8  #=Bạncóthểgõcáinàytheocácbước:1.Nhập\u0026#34;\\varepsilon\u0026#34;(varepsilon)2.Nhấnphím\u0026lt;tab\u0026gt;TínhnăngnàycótrênmọicôngcụhỗtrợJulia=# ε = 1e-9 # Giờ thì công thức toán trong # code của bạn sẽ gọn và dễ đọc hơn   Cực kì tiện lợi khi bạn code những phần mềm dùng nhiều công thức toán (mà lúc nào chẳng có toán chứ?). Nhân tiện mình giới thiệu luôn, dấu # được dùng để comment trên một dòng code (tất cả những gì sau dấu này sẽ được bỏ qua; còn cặp dấu #= và =# được dùng để comment trên nhiều dòng, mọi thứ giữa hai thằng này sẽ bị bỏ qua khi chạy code.\nCòn đề khai báo hằng số, bạn chỉ cần nhét thêm chữ const vào đầu dòng như sau:\n1  const hằng_số = true   Bất kì biến số, hằng nào bạn định nghĩa như trên trong REPL đều được coi là biến toàn cục. Nếu bạn viết một phần mềm sản xuất, hãy dùng ít biến toàn cục nhất có thể (vì lí do hiệu năng, lí do bảo dưỡng, v.v\u0026hellip; bạn không dùng càng tốt). Nhưng hằng số toàn cục vẫn ok nhé, thực chất Julia chỉ cho phép khai báo hằng số toàn cục thôi. Bạn có thể dùng từ khóa local để khai báo nội bộ và từ khóa global để khai báo toàn cục.\n1 2 3  local x = 1 global y = 2 local const z = \u0026#34;lỗi\u0026#34;   Nếu bạn khai báo biến local trưc tiếp trên REPL, nó sẽ biến mất ngay lập tức và bạn không dùng được nó. Vậy biến nội bộ có hiệu lực ở đâu, hồi sau sẽ rõ :) Giờ chúng ta chuyển sang nói qua về kiểu dữ liệu.\nKiểu dữ liệu Khi bạn gán một biến trong Julia, bộ dịch sẽ tự phát hiện kiểu và gắn kiểu dữ liệu của nó cho biến. Điều tương tự cũng xảy ra với hằng số. Bạn có thể lấy kiểu dữ liệu của một biến hay hằng bằng hàm typeof:\n1 2 3 4 5 6  x = 1.0 typeof(x) # Trả về một kiểu Float typeof(π) # Trả về Irrational{:π} # đây là một hằng số # viết bằng cách \\pi \u0026lt;tab\u0026gt; # có thể dùng chữ pi cũng được   Nhìn mấy cái kiểu dữ liệu có vẻ lằng nhằng, nhưng chúng ta đang ở Level 1, đừng bận tâm về nó vội. Mình chỉ giới thiệu qua một số kiểu dữ liệu hay dùng ở đây thôi.\nCác kiểu số Một ít int\n1  n = 3   Một ít float\n1 2  x = 2.0 y = 4.0   Một ít hữu tỉ\n1  p = 1//2   Một ít hư ảo\n1  z = 1 + 2im # hoặc 1 + 2 * im   Một ít phép toán\n1 2 3 4 5 6 7 8 9 10 11 12 13  đối = -z cộng = n + x cộng += z trừ = n - z nhân = z * p chia = n / x # lấy n chia x chia_ngược = n \\ x # lấy x chia cho n chia_hữu_tỉ = z // (3 - 4im) lũy_thừa = x^n lấy_căn = sqrt(4) lấy_căn_phức = sqrt(complex(-1)) # sqrt(-1) sẽ lỗi, vì kiểu của -1 là Real giá_trị_tuyệt_đối = abs(-3.4) module_phức = abs(z)   Một ít hàm toán học\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # Các hàm liên quan đến logarith exp(x) # e^x, e là hằng số Euler log(x) # loga cơ số e log10(x) # loga cơ số 10 log2(x) # loga cơ số 2 log1p(x) # loga cơ số e của (1 + x) log(y, x) # loga cơ số y của x # Các hàm liên quan tới lượng giác # Ngoài sin ra còn có cos, tan, cot sin(x) # lượng giác, dùng radian, tương tự có cos, tan, cot sind(x) # như sin, nhưng dùng đơn vị độ sinh(x) # hàm hyperbolic asin(x) # lượng giác ngược asind(x) # như asin, đơn vị độ asinh(x) # hàm hyperbolic ngược deg2rad(x) # chuyển từ độ sang radian rad2deg(x) # chuyển từ radian sang độ   Một ít phép so sánh\n1 2 3 4 5 6 7 8 9 10 11 12  bé_hơn = (x \u0026lt; y) lớn_hơn = (x \u0026gt; y) bằng = (x == y) khác = (x != y) khác = (x ≠ y) # \\ne\u0026lt;tab\u0026gt; xấp_xỉ = isapprox(x, y) xấp_xỉ = (x ≈ y) # \\approx\u0026lt;tab\u0026gt; không_xấp_xỉ = (x ≉ y) # \\napprox\u0026lt;tab\u0026gt; lớn_hơn_hoặc_bằng = x \u0026gt;= y lớn_hơn_hoặc_bằng = x ≥ y # \\ge\u0026lt;tab\u0026gt; (Greater than or Equal) bé_hơn_hoặc_bằng = x \u0026lt;= y bé_hơn_hoặc_bằng = x ≤ y # \\le\u0026lt;tab\u0026gt; (Less than or Equal)   Kiểu Bool Julia dùng true và false cho các giá trị thuộc kiểu Bool\n1 2 3 4 5 6 7  a = true b = false phủ_định = !a và_logic = a \u0026amp;\u0026amp; b hoặc_logic = a || b xor_logic = xor(a, b) xor_logc = a ⊻ b # \\xor\u0026lt;tab\u0026gt;   Kí tự và xâu kí tự Trong Julia, kí tự được bao quanh bởi dấu nháy đơn, còn xâu kí tự được bao quanh bởi dấu nháy kép. Bạn có thể dùng 3 dấu nháy kép để viết các xâu kí tự phức tạp, gồm nhiều dòng.\n1 2 3 4 5 6 7 8  kí_tự = \u0026#39;a\u0026#39; xâu = \u0026#34;helloworld\u0026#34; xâu_phức_tạp = \u0026#34;\u0026#34;\u0026#34;\u0026#34;Trămnămtrongcõingườita,ThúyKiềulàmẹ,conlàThúyVân\u0026#34;Câuthơchothấythằngnàongồiviếtcáinàyrấtdốtvăn...\u0026#34;\u0026#34;\u0026#34;   Julia hỗ trợ \u0026ldquo;nội suy\u0026rdquo; xâu kí tự (string interpolation, không mình biết dịch đúng không nữa). Dùng dấu $ là bạn có thể \u0026ldquo;nhúng\u0026rdquo; một biến vào trong xâu kí tự. Nếu bạn muốn dưa một biểu thức vào, hãy dùng $(biểu_thức).\n1 2 3 4  x = rand(-3:3) println(\u0026#34;mộtsốngẫunhiêntrongkhoảng-3tới3:$x\u0026#34;) # hoặc println(\u0026#34;mộtsốngẫunhiêntrongkhoảng-3tới3:$(rand(-3:3))\u0026#34;)   Một số hành động với kí tự và xâu kí tự:\n1 2 3 4 5 6 7 8  clipboard(\u0026#34;copytoànbộxâukítựnày,dùngcáinàymaxtiện\u0026#34;) collect(\u0026#34;xâukítự\u0026#34;) # chuyển xâu kí tự thành một mảng các kí tự Int(\u0026#39;c\u0026#39;) # Chuyển kí tự sang mã Unicode Char(97) # Chuyển mã kí tự thành kí tự length(\u0026#34;độdàixâu\u0026#34;) \u0026#34;nối\u0026#34; * \u0026#34;xâu\u0026#34; * \u0026#34;kítự\u0026#34; \u0026#34;nhânlên3lần\u0026#34; ^ 3 \u0026#34;abc\u0026#34; \u0026lt; \u0026#34;abd\u0026#34; # so sánh theo thứ tự từ điển, dựa vào mã kí tự   Mảng, ma trận Phần hay nhất để dành cuối cùng :) Julia hộ trợ tính toán ma trận rất ngon. Ngon thế nào thì từ từ mới biết hết, đặc biệt các bạn dùng Matlab có thể sẽ thấy nó quen thuộc. Phần này đáng có một bài viết riêng, vì vậy trong bài này mình chỉ giới thiệu thôi.\nTrong Julia, số chiều của ma trận được phân biệt rất rõ ràng. Khi khai báo một vector, chúng ta dùng dấu , hoặc ; để ngăn cách các phần tử:\n1 2  A = [1, 2, 3] B = rand(3) # vector ngẫu nhiên   Đoạn code trên sẽ tạo ra A và B là vector cột. Đối với ma trận, chúng ta dùng dấu cách ngăn cách các phần tử cùng hàng, và dấu ; để ngăn cách giữa các dòng\n1 2 3  M = [1, 2, 3; 4, 5, 6; 7, 8, 9] # lỗi, không dùng được dấu \u0026#34;,\u0026#34; đâu M = [1 2 3; 4 5 6; 7 8 9] N = rand(3, 3) # ma trận ngẫu nhiên   Để lấy chỉ số của vector, ma trận, chúng ta dùng cú pháp ma_trận[chỉ_số]. Julia lưu ma trận theo cột, chúng ta có thể dùng chỉ số 1 chiều hoặc 2 chiều để lấy ra phần tử của ma trận.\n1 2 3 4 5 6 7  M[2, 3] # hàng 2 cột 3, trả ra 6 M[4] # phần tử thứ 4, nhưng duyệt theo từng hàng, trả ra 2 M[end] # phân tử cuối cùng M[1:2, end] # hàng 1 tới hàng 2, cột cuối cùng M[end, [1, 3]] # cột 1 và 3, hàng cuối cùng M[[1, 2], [2, 3]] # đoán xem? :) M[:, end] # cột cuối   Trong Julia, việc gán ma trận sẽ không tạo bản copy của ma trận đó, trừ khi bạn lấy một phần của ma trận:\n1 2 3 4 5 6  L = M L[1] = 2 # M cũng bị thay đổi L = M[[1, 2], :] L[1] = 3 # M không bị đổi L = copy(M) # copy lại M, tạo ma trận mới L[1] = 3 # M không bị đổi   Các phép toán với vector, ma trận được thực hiện rất tự nhiên (theo quy tắc toán học):\n1 2 3 4 5 6 7 8 9 10 11  A * B # báo lỗi, hai vector có chiều 1 × 3 không nhân với nhau được A * B\u0026#39; # nhưng nếu B chuyển vị thành vector hàng thì ok :) M * N # hai ma trận (3, 3) nhân với nhau M * A # nhân ma trận (3, 3) với vector (3, 1) A + B # cộng vector M + N # cộng ma trận A + B\u0026#39; # lỗi, cộng vector ma trận phải cùng chiều A .+ B\u0026#39; # nhưng cộng từng phần tử lại là chuyện khác :) A .* B\u0026#39; # nhân phần tử cũng vậy luôn M ^ 5 # ma trận vuông có thể lấy lũy thừa M .^ 5 # lũy thừa từng phần tử   Lưu ý rằng, đối với trường hợp số thực, chúng ta có thể dùng A' để chuyển vị. Với ma trận số phức hãy dùng transpose. Để biết chi tiết hãy xem thêm:\n transpose: https://en.wikipedia.org/wiki/Transpose adjoint (dấu nháy): https://en.wikipedia.org/wiki/Conjugate_transpose  (sorry vì màu link khó nhìn, mình sẽ gửi issue lên người bảo trì theme này)\n Kết luận Ok, phần giới thiệu tới đây mình nghĩ đủ rồi. Vậy các là các bạn đã biết cách khai báo biến, cộng trừ nhân chia và những trò hay ho mà trên trường giáo viên sẽ bắt chúng ta ngồi tính sấp mặt. Hẹn gặp các bạn trong bài viết sau.\nBonus: nếu đang học đại học, giờ bạn có thể dùng Julia như một cái máy tính cá nhân (nhưng vạn năng hơn một tí)\n1 2  # Giải hệ phương trình A⋅X = B trong một nốt nhạc A^-1 * B   "
},
{
	"uri": "https://ndgnuh.github.io/julia-dojo/hello-world/",
	"title": "Julia Dojo: hello world",
	"tags": ["julia"],
	"categories": [],
	"series": ["Julia Dojo"],
	"description": "Viết chương trình đầu tiên của bạn trong Julia",
	"content": "Chào mừng các bạn quay trở lại với series Julia Dojo. Hôm nay chúng ta sẽ học cách viết một chương trình trong Julia và làm thế nào để chạy nó.\nDân gian ta có câu:\n Lời chào cao hơn mâm cỗ\n\u0026ndash; Dân Gian Ta (mình cũng không biết đây là thằng nào)\n Lời chào rất quan trọng, trong lĩnh vực lập trình điều này không phải ngoại lệ. Do đó, hôm nay chúng ta sẽ viết chương trình \u0026ldquo;chào thế giới\u0026rdquo;, dân-gian-ta còn gọi là \u0026ldquo;hello world\u0026rdquo;.\nChương trình đầu tiên của bạn Hello world là chương trình rất quen thuộc nếu bạn đã học lập trình trước đây. Nó sẽ cho bạn cái nhìn đầu tiên về cấu trúc ngữ pháp của một ngôn ngữ lập trình. Đầu tiên, hãy mở một trình sửa văn bản, tạo một file tên hello-world.jl.\nTrước đây, đuôi file .j được sử dụng cho ngôn ngữ Julia. Sau này, họ đổi thành .jl, cá nhân mình thấy thích cái đuôi file này hơn.\nKhi tạo file xong, hãy điền nội dung sau vào file:\n1  println(\u0026#34;helloworld\u0026#34;)   Xong, bạn hãy mở một terminal tại vị trí bạn lưu file trên, sau đó chạy lệnh.\n1  julia hello-world.jl   Dòng chữ \u0026ldquo;hello world\u0026rdquo; sẽ được in ra màn hình. Vậy là bạn đã viết và chạy thành công chương trình hello world của mình với Julia.\nRất nhiều cách để nói \u0026ldquo;hello world\u0026rdquo; Chúng ta sẽ chỉnh sửa chương trình hello world một chút. Ở trên mình dùng hàm println để in ra chuỗi hello world. Giờ mình sẽ giới thiệu một vài cách khác:\n1 2 3 4 5 6  println(\u0026#34;helloworld\u0026#34;) print(\u0026#34;helloworld\u0026#34;); println() @show \u0026#34;helloworld\u0026#34; @info \u0026#34;helloworld\u0026#34; @warn \u0026#34;helloworld\u0026#34; @error \u0026#34;helloworld\u0026#34;   Chạy file trên, chúng ta sẽ thu được output:\nhello world hello world \u0026quot;hello world\u0026quot; = \u0026quot;hello world\u0026quot; [ Info: hello world ┌ Warning: hello world └ @ Main /tmp/hello-world.jl:6 ┌ Error: hello world └ @ Main /tmp/hello-world.jl:7  Dòng đầu là kết quả của println, hàm này sẽ in ra tham số của nó, sau đó in kí tự ngắt dòng. Dòng thứ hai là kết quả của print, hàm này giống println nhưng không in kí tự ngắt dòng, do đó mình phải thêm một hàm println() trống ở phía sau. Các bạn để ý thêm. Ở dòng số 2 file hello-world.jl, mình có dấu ;. Đấu này không cần thiết khi bạn viết mỗi lệnh trên một dòng. Tuy nhiên nếu bạn cần viết hai lệnh trên cùng dòng thì sẽ cần tới nó để ngắt giữa hai lệnh. Ở dòng 3, macro @show in ra một điều \u0026ldquo;hiển nhiên\u0026rdquo;: \u0026quot;hello world\u0026quot; = \u0026quot;hello world\u0026quot;. Thực ra, cái này dùng để show ra giá trị của một biến hay hằng số, ở đây chúng ta truyền cho nó một hằng số nên nó in ra củ chuối như vậy\u0026hellip; Macro là gì ư? Tạm thời bạn đừng quan tâm, hãy tạm hiểu nó có dấu @ và làm một cái gì đó cho bạn. Ở dòng 4, chúng ta có @info. Macro này có tính ghi chú, nó chỉ nhận đầu vào là chuỗi kí tự thôi. @info được dùng để đưa ra bản ghi chép (log) cho chương trình của bạn. Ở dòng 5, chúng ta có @warn. Thằng này giống thằng @info, nhưng nó nói với giọng \u0026ldquo;bố đang cảnh báo mày đấy\u0026rdquo;. Tuy hổ báo nhưng nó sẽ không đừng việc thực thi chương trình của bạn. @warn thường được dùng khi một người viết gói chương trình muốn deprecate (tạm dịch là cho lỗi thời, mình không biết dịch như nào cho hay) một tính năng nào đó và cảnh báo người dùng không nên dùng nó. Cuối cùng, chúng ta có @error. Thằng này nó sẽ cảnh báo và cho chương trình của bạn bay màu luôn. @error được dùng rất nhiều. Bạn sẽ gặp nó khi gọi một hàm không tồn tại chẳng hạn.  Chế độ tương tác Bạn có thấy viết hẳn một file, chỉ dành cho một dòng code mà in ra hello world có hơi thừa? Nếu vậy hãy mở terminal ra, chạy câu lệnh sau:\n1  julia   Chế độ tương tác Julia (hay Julia REPL) sẽ chào đón bạn với một cái logo ascii (không có mèo đâu, đấy là hình nền của mình :P)\n chế độ tương tác Julia   Bạn có thể chạy \u0026ldquo;hello world\u0026rdquo; bằng cách nhập câu lệnh trên vào và nhấn Enter:\n hello world trong một dòng   Thậm chí bạn có thể gõ ?println và xem thông tin về những thứ mình vừa viết ở trên.\n chế độ help   Goodbye, world Ok, vậy là bạn đã biết những cách đơn giản nhất viết và chạy chương trình Julia (và cũng là chương trình đơn giản nhất luôn). Chúng ta sẽ lần lượt tìm hiểu những phương thức khác trong các bài tiếp theo. Riêng với chế độ tương tác, mình có thể làm một bài nữa, nói về những tính năng của nó. Hẹn gặp lại các bạn trong những bài viết sau :)\n"
},
{
	"uri": "https://ndgnuh.github.io/julia-dojo/cai-dat-julia/",
	"title": "Julia Dojo: cài đặt Julia",
	"tags": ["julia"],
	"categories": [],
	"series": ["Julia Dojo"],
	"description": "Hướng dẫn tải và cài đặt Julia trên máy tính của bạn",
	"content": "Chào mừng các bạn đến với bài viết đầu tiên của series \u0026ldquo;Julia từ con số không\u0026rdquo;. Trong bài viết này mình sẽ hướng dẫn các bạn cách cài đặt Julia.\nĐể cài Julia, chúng ta có 2 cách:\n Cài đặt từ bản phân phối chính thức: cách này được khuyến cáo vì nó sẽ không gây lỗi lặt vặt, tuy nhiên quá trình cài đặt sẽ hơi dài một chút. Cài đặt từ bản phân phối của cộng đồng: cách này rất đơn giản, đặc biệt với những bạn dùng Linux. Tuy nhiên cách này có thể gây lỗi vặt (thực ra mình mới chỉ thấy một lỗi trên ArchLinux, chưa thấy có người gửi issue nào khác)  Mình sẽ hướng dẫn các bạn cả hai cách. Việc cài đặt có thể sử dụng tới terminal (dòng lệnh, hiểu nôm na là vậy), vậy có kiến thức cơ bản về việc sử dụng terminal và shell có thể sẽ hữu dụng và giúp quá trình cài đặt dễ dàng hơn. Nếu bạn không biết những thứ này cũng không nên lo quá.\nCài đặt bản phân phối từ cộng đồng Vì cách này ngắn và đơn giản hơn, mình sẽ hướng dẫn trước. Để thực hiện cách cài đặt này, bạn cần có package manager. Cái này trên *Nix thì có chắc chắn có sẵn, còn trên MacOS và Windows có lẽ bạn sẽ phải cài thêm. Khi xong xuôi, bạn chỉ cần mở terminal và ehạy lệnh tương ứng với hệ điều hành của mình:\n  Windows - Chocolately  Cài đặt:\n1  choco install julia --confirm   Cập nhật:\n1  choco upgrade julia --confirm        MacOs - HomeBrew  HomeBrew trên Mac 1  brew cask install julia        Fedora/Red hat/Cent OS và các distro tương tự  Với Fedora bản 19 hoặc hơn:\n1 2  sudo dnf copr enable nalimilan/julia sudo yum install julia   Nếu bạn dùng Cent OS bản 7 hoặc hơn:\n1 2  sudo yum-config-manager –add-repo https://copr.fedorainfracloud.org/coprs/nalimilan/julia/repo/epel-7/nalimilan-julia-epel-7.repo sudo yum install julia   Nếu dnf và yum-config-manager không khả dụng trên hệ thống của bạn, hãy tải file .repo tương ứng ở link phía trên và copy vào /etc/yum.repos, sau đó chạy câu lệnh thứ 2.\nĐể cập nhật Julia:\n1  yum upgrade julia        Debian/Ubuntu và các distro tương tự  Cài đặt:\n1 2  sudo apt update sudo apt install julia   Cập nhật:\n1 2  sudo apt update sudo apt upgrade        Archlinux và các distro tương tự  Cài đặt:\n1 2 3 4  sudo pacman -S julia # bản không chính thức # những bản này cần `yay` để cài tự động sudo yay -S julia-bin # tương ứng với bản chính thức từ trang chủ yay -S julia-git # tương ứng vởi bản build từ git   Cập nhật:\n1 2 3  sudo pacman -Syu # hoặc yay -Syu      Cài đặt từ bản phân phối chính thức Việc cài đặt sẽ chia thành ba bước. Đầu tiên, bạn cần truy cập trang tải về của Julia để lấy bản phân phối chính thức. Mình sẽ hướng dẫn chi tiết quá trình cài đặt. Bước tiếp theo là giải nế và cài đặt. Cuối cùng, chúng ta sẽ cài đặt biến môi trường để có thể truy cập vào Julia mọi lúc mọi nơi.\nTải Julia  Trang download Julia   Julia cung cấp một số lựa chọn:\n Current stable release: phiên bản ổn định. Bản Release Candidate: phiên bản ứng cứ viên phát hành, có thể hiểu là \u0026ldquo;gần\u0026rdquo; ổn định.. Long-term support: Phiên bản hỗ trợ lâu dài, bạn có thể hiểu đây là phiên bạn \u0026ldquo;cực kì ổn định\u0026rdquo;. Bản Nightly: Bản thử nghiệm, dành cho những thanh niên thích thử nghiệm.  Sau khi đã quyết định sẽ sử dụng phiên bản nào, hãy tải về bản cài đặt phù hợp với hệ điều hành của bạn. Ví dụ nếu mình dùng Windows 64 bit hãy tải file Windows (.exe) ở cột 64-bit (trong ảnh).\nGiải nén và cài đặt   Windows  Sau khi tải Julia như trên, chúng ta sẽ có một file .exe. Mở file exe này lên. Việc cài đặt tương đối đơn giản, chỉ cần next, next và next.\nLưu ý rằng, quá trình cài đặt có một bước chọn đường dẫn giải nén. Hãy lưu lại đường dẫn này để sử dụng ở bước sau.\n    MacOS  Sau khi tải Julia như trên, chúng ta sẽ có một file .dmg. Mở file .dmg ấy, bên trong có file Julia-\u0026lt;phiên-bản\u0026gt;.app. Kéo thả file này vào thư mục Application trên desktop của bạn và bạn đã hoàn thành bước này.     Linux, BSD, *Nix  Sau khi tải Julia như trên, chúng ta sẽ có một file .tar.gz. Hãy copy file này vào vị trí cài đặt tương ứng, sau đó giải nén file này ra bằng lệnh:\n1  tar -xvf đường/dẫn/tới/\u0026lt;file-của-bạn\u0026gt;.tar.gz   Một vài file, thư mục mới sẽ xuất hiện, vậy là bạn đã hoàn thành bước này.\n  Thêm đường dẫn đến Julia vào biến môi trường Để có thể gọi Julia từ mọi nơi, bạn cần thêm đường dẫn tới file thực thi Julia vào biến $PATH. Tuy cả ba nhóm hệ điều hành trên đều dùng biến môi trường này, cách cài đặt sẽ khác nhau một chút.\n  Windows 10   Nhấn tổ hợp phím Windows + R, gõ sysdm.cpl và nhấn Enter Một cửa sổ hiện lên, hãy chọn thẻ Advanced, chọn Environment Variables. Thêm một cửa sổ nữa hiện lên, trong phần System variables, chọn Path và click vào nút Edit Một cửa sổ hiện ra, nhấn New. Một cửa sổ mới hiện ra với một hộp văn bản Lấy đường dẫn cài đặt ở bước 2 ra, thêm \\bin vào đuôi và copy vô cái hộp văn bản đó. Ví dụ mình cài Julia vào E:\\julia, mình sẽ ghi E:\\julia\\bin. Ấn Ok, tắt hết các hộp thoại, giờ bạn đã cài xong Julia.      Windows khác   Nhấn tổ hợp phím Windows + R, gõ sysdm.cpl và nhấn Enter Một cửa sổ hiện lên, hãy chọn thẻ Advanced, chọn Environment Variables. Thêm một cửa sổ nữa hiện lên, trong phần System variables, chọn Path và click vào nút Edit Sau khi nhấn Edit, sẽ có một cửa sổ với 2 hộp văn bản xuất hiện. Click vào hộp văn bản thứ 2 (Variable value:) và di chuyển đến cuối dòng, nếu cuối dòng không có dấu ; hãy thêm dấu ; vào. Lấy đường dẫn cài đặt ở bước 2 ra, thêm \\bin vào đuôi và copy thêm vào cuối của hộp văn bản thứ 2. Ví dụ mình cài Julia vào E:\\julia, mình sẽ ghi thêm E:\\julia\\bin vào cuối. Nhắc lại rất kĩ là ghi thêm nhé, ông nào paste đè lên cái cũ xong hỏng máy tôi không chịu trách nhiệm đâu. Ấn Ok, tắt hết các hộp thoại, giờ bạn đã cài xong Julia.      MacOS   Chạy open -a TextEdit ~/.bash_profile trên Terminal. Nếu bạn dùng zsh thì thay .bash_profile bằng .zshrc (nếu bạn không biết bạn đang dùng cái gì thì đừng để ý đoạn zsh này). Lệnh trên sẽ mở file ~/.bash_profile để bạn chỉnh sửa. Thêm dòng export PATH=\u0026quot;/Applications/Julia-.app/Contents/Resources/julia/bin:${PATH}\u0026quot; vào cuối và save lại.      Linux, BSD, *Nix  Bạn có 3 lựa chọn như dưới đây, sau khi thực hiện một trong ba bạn sẽ có thể sử dụng Julia.\n Thêm thư mục Julia vào biến $PATH bằng cách thêm dòng lệnh mình ghi ở dưới vào trong file ~/.bashrc và ~/.bash_profile. Thay hai file trên với ~/.zshrc nếu bạn dùng zsh. Thay những file trên với /etc/profile, /etc/bash.bashrc hoặc /etc/zsh nếu bạn muốn cài đặt trên toàn hệ thống.  1  export PATH=\u0026#34;$PATH:/đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin\u0026#34;    Chạy lệnh echo $PATH xem biến $PATH của bạn có những thư mục nào, ví dụ mình sẽ chọn /usr/bin. Sau đó, hãy tạo liên kết tới Julia trong thư mục đó bằng lệnh sudo ln -s /đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin/julia /usr/bin/ (mình dùng sudo vì cần quyền ghi vào /usr/bin, nếu người dùng của bạn ghi được vào thư mục trên $PATH thì không cần sudo) Cách cục súc: bạn sẽ chạy /đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin/julia mỗi lần bạn dùng đến nó.    Lưu ý thêm cho những bạn dùng Windows   Nếu bạn dùng Windows 7   bản update này sẽ giúp trình quản lý gói của Julia hoạt động. Xuống phần Method 2 và click vào link Microsoft Update Catalog. Windows Management Framework 3.0 hoặc hơn để cài Powershell. Vào trang web trên, kéo xuống dưới cái bảng và click vào phiên bản bạn muốn download.    Nhìn chung, nếu bạn dùng Windows, mình khuyên các bạn nên tìm một terminal khác ngoài cmd và cái đi kèm với Powershell. Một số gợi ý cho các bạn:\n Terminal của Visual Studio Code Git bash  Tổng kết Các bạn có thể cài đặt Julia theo cách mình muốn. Bản cài chính thức cài đặt sẽ dài dòng hơn một chút nhưng đảm bảo hơn, bản cài do cộng đồng phân phối sẽ tiện lợi hơn với một tỉ lệ rất rất nhỏ xảy ra bug. Để kiểm tra việc cài đặt Julia có thành công hay không, hãy mở Terminal và chạy lệnh julia.\n Nếu lệnh chạy thành công, chúng ta sẽ thấy màn hình Julia chào đón mình  \n"
},
{
	"uri": "https://ndgnuh.github.io/julia-dojo/",
	"title": "Julia Dojo: giới thiệu",
	"tags": ["julia"],
	"categories": [],
	"series": ["Julia Dojo"],
	"description": "",
	"content": "Julia? Julia là một ngôn ngữ lập trình bậc cao dễ sử dụng, nhanh và mạnh mẽ. Một số đặc trưng của Julia cũng như lí do bạn sẽ muốn dùng nó (hoặc không):\n Julia là một ngôn ngữ lập trình hàm Kiểu động (dynamic typing) Julia được biên dịch (compile), tuy nhiên cũng có chế độ thông dịch (intepreter) nếu bạn muốn Julia nhanh Cú pháp rất dễ chịu, những bạn nào quen dùng python hoặc matlab sẽ thấy quen thuộc Cực kì mạnh, thư viện tiêu chuẩn hỗ trợ rất tốt việc tính toán toán học và xử lý song song. Multiple dispatch (cái này có thể khiến bạn cảm giác lạ lạ, nhưng nó đỉnh lắm) Julia miễn phí và mã nguồn mở (giấy phép MIT) Julia hứa hẹn sẽ giải quyết vấn đề hai ngôn ngữ  Khoan, nhiều \u0026ldquo;điểm tốt\u0026rdquo; quá, nghe vô lý. Thằng Python bậc cao nhưng nó chậm như rùa, mọi thư viện đều phải binding và viết với C. Thằng C thì nhanh, nhưng mà để viết được nó thì không phải ông nào cũng làm được. Thằng Matlab thì nhanh và dễ viết thật, nhưng bạn ơi, tiền đâu mà dùng Matlab, ngồi crack thôi chứ còn gì. Hơn nữa, Matlab nếu bạn dùng cho mục đích cá nhân thì crack được, chứ một tổ chức hay cơ quan thì họ sẽ bảo rằng:\n Ở đây chúng tôi không làm vậy\n\u0026ndash; Họ không dùng Matlab ở Wakanda\n Ok, mình vẫn chưa giải thích tại sao có nhiều \u0026ldquo;điểm tốt\u0026rdquo; như vậy. Julia đạt được những điều như trên vì 2 lí do:\n Julia dùng Just Intime Compiler (JIT) Việc biên dịch của Julia cực kì phức tạp, khiến cho mã Julia khi dịch xong có tốc độ so sánh được với C hoặc Fortran   Micro benchmark theo thời gian chạy một số ngôn ngữ, thời gian chạy của C được lấy làm mốc. Các ngôn ngữ khác được so sánh tương đối.   Đương nhiên, Julia cũng có khiếm khuyết, không có cái gì hoàn hảo cả. Và cộng đồng cũng rất cố gắng để cải thiện, xử lý chúng.\n Cộng đồng Julia nhỏ một cách tương đối so với những \u0026ldquo;ông lớn\u0026rdquo; như Python, đặc biệt là cộng đồng người Việt. Mình cho rằng đây là vấn đề thời gian, và vấn đề này cũng là lí do mình ở đây, viết cái đống này cho các bạn :). Mảng trong Julia đánh chỉ số từ 1. Có thể bạn đang nghĩ rằng sẽ dừng đọc và drop cái ngôn ngữ của nợ này ngay tại đây, hãy khoan đã. Theo mình thấy, vấn đề chỉ số này không ảnh hưởng nhiều lắm. Việc đánh chỉ số từ 0 được ông Dijikstra đưa ra và áp dụng trong kha khá ngôn ngữ lập trình, nhưng vẫn có những người dám phản dmg ông và đi theo trường phái khác. Cá nhân mình không có thành kiến gì với cả hai trường phái đâu, mình chỉ muốn nói cả hai đều có thể dùng được. Lí do duy nhất mình đưa cái này vào khuyết điểm vì có thể nó sẽ \u0026ldquo;dọa\u0026rdquo; những người mới.   Tôi không biết bao nhiêu người trong số các ông đã đích thân gặp Dijikstra, nhưng các ông chắc đều biết rằng - sự kiêu ngạo trong tính toán khoa học được đo bằng nano-Dijikstra.\n\u0026ndash; Alan Kay (mình không biết ông này nhưng mà câu nói của ổng làm mình thấy khoái)\n Lần đầu chạy code sẽ lâu hơn một chút. Ví dụ khi mình tạo random 100000 số kiểu double, lần đầu chạy rand(Float64, 100000) sẽ mất khoảng 0.06, những lần tiêp theo thời gian sẽ giảm đi còn 0.002 (nhanh gấp khoảng 30 lần). Có lẽ đây là vấn đề lớn nhất trong Julia. Nếu bạn hiểu JIT là cái gì, bạn sẽ thấy đặc điểm này gần như không thể tránh được. Tuy nhiên, với những người định \u0026ldquo;dùng thử\u0026rdquo; Julia, họ sẽ trải nghiệm thời gian compile và tưởng nó là runtime, sau đó sẽ nghĩ rằng \u0026ldquo;cái này không nhanh như quảng cáo\u0026rdquo;. Điều này ảnh hưởng rất nhiều tới khuyết điểm số 1. Hiện tại, cộng đồng Julia đang rất ưu tiên giải quyết vấn đề này, họ đã tìm cách giảm thời gian compile đáng kể, đồng thời có cách để compile hoàn toàn mã nguồn Julia dưới dạng thư viện liên kết động. Scala là cái tên được ghép từ \u0026ldquo;scalable\u0026rdquo; và \u0026ldquo;language\u0026rdquo;. Swift mang nghĩa chuyển động trơn tru và tốc độ cao. Ruby là một viên đá quý. C++ là C tăng lên 1 level. C là kế tiếp của B. Matlab là viết tắt của Matrix Laboratory, thậm chí trong một ngôn ngữ nào đó, nó có nghĩa là sự thông thái\u0026hellip; Vậy Julia cái tên Julia thì sao, nó có ý nghĩa gì?   Đây là câu hỏi ưa thích của mọi người. Thực ra chả có lí do gì đâu, nghe cái tên nó hay hay.\n\u0026ndash; Stefan Karpinski =))\n Huyên thuyên về Julia đủ rồi. Rất tiếc nếu mình không thuyết phục được bạn. Tuy nhiên, nếu bạn quyết định thử Julia và cho nó một cơ hội, hãy chuyển qua phần tiếp theo và bước vào Julia Dojo.\nJulia Dojo Vậy là bạn quyết định cho Julia một cơ hội, mình sẽ cảm ơn các bạn bằng một series hướng dẫn \u0026amp; thảo luận, mang tên \u0026ldquo;Julia Dojo\u0026rdquo;. Series này sẽ tổng hợp từ rất nhiều nguồn kiến thức, nhưng chủ yếu mình sẽ lấy từ 3 nguồn:\n Tài liệu chính thức Julia Con (một hội thảo được tổ chức hàng năm) Hiểu biết của mình  Với tài liệu chính thức và Julia Con, bạn có thể xem một cách miễn phí trên mạng nếu nếu không ngại tiếng Anh; còn cái nguồn thứ ba, bạn có thể xem nếu bạn quen mình ngoài đời thực và có khả năng ngoại cảm.\nÝ tưởng chính của Julia Dojo là: chúng ta sẽ train từng level một. Với mỗi level chúng ta sẽ đi sâu vào trong hệ thống của Julia hơn và thấy các thứ liên kết với nhau như thế nào. Trang này sẽ là nơi mình update các level của Dojo cùng với nội dung trong đó mỗi khi có bài mới.\nCó những bài viết mình đánh đấu là \u0026ldquo;tùy chọn\u0026rdquo; hoặc \u0026ldquo;nên xem\u0026rdquo;, bạn không nhất thiết phải đọc vì nó không phải một \u0026ldquo;cơ bản\u0026rdquo; của Julia. Mình có để intro ở đầu mỗi bài viết, nếu bạn thấy không hứng thú hoặc phần đó bạn đã biết rồi, bạn có thể skip.\nLayout phía dưới có những phần dự định, có thể khi mình viết bài thực sự mình sẽ thêm bớt hoặc chuyển chỗ một vài thứ trong đó.\n Level 1: nhập môn Những thứ cơ bản nhất\n Tải và cài đặt Julia Hello, world Khai báo biến, kiểu dữ liệu, phép toán Cấu trúc điều khiển Sắp tới: hàm Cộng đồng Julia  Level 2: làm chủ vũ khí (dự định) Công cụ lập trình mà bạn có thể sẽ thích.\n Làm việc với trình quản lí gói [nên đọc] Jupyter notebook [nên đọc] VSCode [tùy chọn] Atom: Juno / Julia pro [tùy chọn] Vim Emacs (chưa chắc)  Level 3: vài đường cơ bản (dự định) Giống Level 1, nhưng kĩ hơn một tí, và giới thiệu các gói mình nghĩ là hay.\n Làm việc với file Tuple, từ điển, tập hợp Struct Chuỗi kí tự, biểu thức chính quy và biểu tượng Đại số tuyến tính Mảng, ma trận Thống kê Vẽ đồ thị DataFrame Gọi các ngôn ngữ khác Đa luồng, đa tiến trình Xử lý ngoại lệ Broadcast  Level 4: thiên biến vạn hóa (dự định) Đa hình và những thứ liên quan tới nó\n Nói thêm về hệ thống kiểu dữ liệu Các loại giao diện Multiple dispatch  Level 5: sáng tạo chiêu thức (dự định) Sẽ có một ngày bạn phải tự viết chương trình của riêng mình\n Tạo một project Unit testing Viết tài liệu  Ngoại truyện???  Một số kĩ thuật để code nhanh hơn Tính toán song song Meta programming   Về các module, gói Vì có rất nhiều module của Julia mang tính chuyên ngành cao, mà trình độ của mình có giới hạn nên mình sẽ không cover hết được(mấy cái mô hình hóa sinh thì chịu rồi, mình dốt hóa). Do đó, nếu các bạn muốn hướng dẫn, giới thiệu một gói nào đó. Các bạn có thể:\n Gửi một đường dẫn cho mình tới blog của các bạn, mình sẽ gắn nó vào đây Gửi cho mình bài viết của các bạn kèm với một số thông về bạn, mình sẽ ghi credit đầy đủ cho các bạn, trừ khi bạn không muốn (nhưng mình vẫn sẽ ghi rõ bài viết do độc giả đóng góp) Dịch trang tài liệu chính thức của gói đó và đóng góp cho họ Không làm gì cả =))  Tạm kết Fun fact: \u0026ldquo;Julia\u0026rdquo; nghe rất giống tên của một phụ nữ trong nhiều nền văn hóa, do đó, dù quy chuẩn của cộng đồng cho rằng Julia không dựa trên tên của ai và ngôn ngữ này không được nhân hóa dưới bất kì hình thức nào, một cơ số người khi nói về ngôn ngữ này vẫn vô thức dùng đại từ \u0026ldquo;cô ấy\u0026rdquo;, trong đó có cả mình :)) Ok, mình nghĩ đến đây là đủ cho bài giới thiệu. Chắc các bạn cũng đoán ra được rằng, mình đang muốn mở rộng cộng đồng người dùng Julia, cụ thể hơn là ở Việt Nam. Một lần nữa, nếu bạn quyết định cho Julia một cơ hội, mình xin cảm ơn. Mình sẽ cố viết post chất lượng và giải đáp thắc mắc của các bạn. Nếu thấy có thiếu sót, đừng ngại gửi lại phản hồi cho mình.\n"
},
{
	"uri": "https://ndgnuh.github.io/about/",
	"title": "Giới thiệu",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "whoami? Xin chào mọi người, mình là Hùng, một open source enthusiast, và là một sinh viên.\nWhat am I doing here? Blog này dự kiến sẽ dùng để chia sẻ kiến thức và bàn chuyện trên trời dưới đất. Cụ thể hơn, mình sẽ chia sẻ hiểu biết của mình (chủ yếu) về Linux, lập trình và có thể là một ít toán nữa.\nHiện tại mình blog chưa được implement tính năng bình luận, tạm thời các bạn đọc nếu có thắc mắc, ý kiến đóng góp hay ném gạch chịu khó gửi một email hay để lại một issue trên Github cho mình.\n Email: ndgnuh@protonmail.com Repo github cho trang này: https://github.com/ndgnuh/ndgnuh.github.io  Blog viết bởi một sinh viên, do tác giả còn rất nhiều thứ phải học nên khả năng cao sẽ gặp sai sót. Nếu bạn đọc phát hiện ra lỗi gì, về kĩ thuật, nội dung, câu cú hay lỗi chính tả ₍•⌣•₎ của trang cứ thoải mái đóng góp ý kiến nhé. "
},
{
	"uri": "https://ndgnuh.github.io/year-all-rights-reserved/",
	"title": "©{Year}, All Rights Reserved",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]