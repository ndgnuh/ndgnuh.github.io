[{"content":"Chào các bạn trở lại với Julia Dojo, trong bài viết này, mình sẽ hướng dẫn về một số các kiểu dữ liệu dưới dạng tập hợp, Dict (từ điển), Set (tập hợp)\nTừ điển Trong Julia có rất nhiều kiểu từ điển, nhưng hai kiểu mình thấy hay gặp nhất là Dict và ImmutableDict. Từ điển sẽ tạo một bảng băm để ta \u0026ldquo;chiếu\u0026rdquo; các giá trị, cú pháp để làm việc với từ điển Dict như sau:\n1 2 3 4 5 6 7 8  d = Dict( 1 =\u0026gt; \u0026#34;số một\u0026#34;, 2 =\u0026gt; \u0026#34;số hai\u0026#34;, 10 =\u0026gt; \u0026#34;số mười\u0026#34;) d[1] # lấy ra giá trị d[3] = \u0026#34;abc\u0026#34; # thêm một giá trị vào từ điển keys(d) # lấy ra các khóa values(d) # lấy ra các giá trị   Kiểu từ điển có hai tham số kiểu: Dict{K, V}, trong đó K là kiểu của khóa, V là kiểu của giá trị trỏ bởi khóa đó. Bạn có thể định kiểu một cách tường minh cho từ điển:\n1 2 3  d = Dict{String, Number}() d[\u0026#34;thực\u0026#34;] = 1.0 d[\u0026#34;ảo\u0026#34;] = 1+2im   Ngoài ra, các bạn có thể \u0026ldquo;thu thập các giá trị của từ điển để tạo thành một mảng gồm các cặp (Pair), hoặc lặp qua một từ điểm trong một vòng lặp:\n1 2 3 4  collect(d) # thu thập for (k,v) in d println(\u0026#34;khóa $k: giá trị $v\u0026#34;) end   Đối với ImmutableDict cách làm việc hơi khác một chút so với Dict. Immutable nghĩa là bạn sẽ không thể chỉnh sửa nó được, do đó chúng ta không thể:\n thêm khóa xóa một khóa  ImmutableDict được cài đặt như một danh sách liên kết, vậy nên nó sử dụng nó sẽ hiệu quả hơn khi bạn cần thêm liên tục. Nghe nghịch lý vì chúng ta không thể thay đổi được ImmutableDict, nhưng thực chất nó sẽ tạo một từ điển mới mỗi lần ta thêm khóa:\n1 2 3  ImmutableDict = Base.ImmutableDict # không nằm sẵn trong global scope d = ImmutableDict(:a =\u0026gt; 1) # trả về một từ điển mới, với 1 khóa d = ImmutableDict(d, :b =\u0026gt; 1) # trả về một từ điển mới, vởi 2 khóa   Ngoài những điều trên ra, bạn vẫn có thể thực hiện các thao tác giống như Dict một cách bình thường\nTập hợp Tập hợp là kiểu được cài đặt giống với định nghĩa toán học tương ứng. Đây là kiểu dữ liệu khá đơn giản nên mình chỉ giới thiệu cú pháp sử dụng thôi:\n1 2 3 4 5 6 7 8 9 10 11  s1 = Set([1, 2, 3]) s2 = Set([3, 3, 4, 5, 6]) # sẽ tự bỏ phần tử trùng s1 ∪ s1 # hợp, viết bằng cách \\cup\u0026lt;tab\u0026gt; s1 ∩ s2 # giao, viết bằng cách \\cap\u0026lt;tab\u0026gt; setdiff(s1, s2) # hiệu tập hợp s1 \\ s2 for x in s1 @show x end # lặp qua tập hợp filter(x -\u0026gt; x \u0026lt; 3, s1) # lọc phần tử filter(s1) do # cũng là lọc phần tử x \u0026lt; 3 end collect(s1) # đưa thành mảng   Tạm kết Ok, bài này mình sẽ kết thúc ở đây. Qua bài này chúng ta đã biết cách thao tác với từ điển và tập hợp. Ngoài ra, bạn có thể tham khảo thêm các kiểu từ điển khác như IdDict hay WeakKeyDict tại tài liệu chính thức của Julia. Hẹn gặp lại các bạn torng những bài viết sau.\n","description":"","id":0,"section":"posts","tags":["julia"],"title":"Julia Dojo: từ điển \u0026 tập hợp","uri":"https://ndgnuh.github.io/julia-dojo/tu-dien-va-tap-hop-trong-julia/"},{"content":"Chào mừng mọi người quay trở lại Julia Dojo. Trong level trước mình đã cover kha khá những cú pháp cơ bản trong Julia. Nhưng mọi người có nhận ra rằng, mình chưa nói về cách để nhập dữ liệu?\nNếu bạn được học C trên trường (nếu không học cũng không sao), chắc hẳn bạn đã được dạy cách nhập tay một dữ liệu bằng hàm scanf. Trong Julia, bạn cũng có thể làm điều tương tự với hàm readline. Nhưng, nếu chúng ta cần đưa vào xử lí những dữ liệu cồng kềnh (không nhất thiết lớn), việc nhập từ tay trở nên không thực dụng. Khi ấy, chúng ta sẽ phải làm việc với file.\nLưu và nạp dữ liệu Đóng mở file Để mở một file trong Julia, chúng ta dùng hàm open. Hàm này sẽ trả về một con trỏ file\n1 2  io = open(\u0026#34;đương dẫn tới file\u0026#34;) io = open(\u0026#34;đương dẫn tới file\u0026#34;, \u0026#34;mode\u0026#34;)     Các giá trị của mode   \u0026quot;r\u0026quot;: đọc \u0026quot;w\u0026quot;: ghi, tạo mới, cắt bớt \u0026quot;a\u0026quot;: ghi, tạo mới, ghi thêm \u0026quot;r+\u0026quot;: đọc, ghi \u0026quot;w+\u0026quot;: đọc, ghi, tạo, cắt bớt \u0026quot;a+\u0026quot;: đọc, ghi, tạo, ghi thêm  Đừng lo lắng quá về các chế độ mở file. Theo mình, trong đa số trường hợp, bạn không cần quan tâm lắm về cái này.    Sau khi làm việc với file xong, đừng quên đóng nó lại:\n1  close(io)   Ngoài ra, bạn có thể dùng cú pháp do:\n1 2 3 4  open(\u0026#34;đường dẫn file\u0026#34;, mode) do # làm gì đó với file # file sẽ được tự động đóng end   Nhưng làm việc với file kiểu gì?\nFile văn bản Sau khi mở một file văn bản, bạn có thể tiến hành đọc từ file đó bằng hàm read hoặc readline để đọc từng dòng.\n1 2 3 4 5 6 7 8  read(io) # đọc đến hết dưới dạng kí tự read(io, String) # đọc đến hết dưới dạng xâu read(io, Char) # đọc kí tự tiếp theo while !eof(io) # đọc 1 dòng # keep = true thì giữ kí tự xuống dòng @show readline(io; keep = false) end   Lưu ý rằng, việc đọc file sẽ đẩy con trỏ file của bạn. Nếu bạn không biết con trỏ file là gì, hãy hiểu đơn giản rằng: nó đánh dấu vị trí bạn bắt đầu đọc. Để quay lại vị trí ban đầu, chúng ta dùng các hàm seek:\n1 2 3  seekstart(io) # quay con trỏ file lên đầu seek(io, i) # quay con trỏ file đến vị trí i seekend(io) # đưa con trỏ file xuống vị trí cuối (eof)   Việc đọc file không phải do Julia xử lí, vị trí của con trỏ file cũng không giống với đánh chỉ số trong Julia. Nói cách khác, vị trí đầu tiên của con trỏ file là 0, không phải 1.  Để ghi một file, chúng ta phải mở file theo những chế đọc cho phép ghi (xem bảng trên). Sau đó:\n1  write(io, \u0026#34;Hello world\u0026#34;);   Việc ghi vào file không thực sự ghi vào ổ đĩa nơi chứa file, nó chỉ lưu vào một vùng đệm thôi. Việc ghi vào ổ đĩa sẽ xảy ra khi bạn đóng file.\nHãy cẩn thận, nếu dùng chế độ w hoặc w+, file của bạn sẽ bị xóa sạch để ghi lại từ đầu.  Ngoài ra, trong một số trường hợp, bạn muốn đọc toàn bộ file hoặc ghi đè toàn bộ file, chúng ta có thể không cần mở, đóng file mà dùng trực tiếp read với write luôn:\n1 2  read(\u0026#34;tên file\u0026#34;, String) write(\u0026#34;tên file\u0026#34;, \u0026#34;Hello world\u0026#34;)   Ma trận Trong Julia thì có muôn vàn cách để đọc, ghi ma trận ra ổ cứng. Bạn có thể dùng file văn bản (CSV chẳng hạn), file Excel, file của Matlab, file của Python và thậm chí cả những định dạng riêng của Julia nữa.\nCách đơn giản nhất để lưu ma trận là một file văn bản. Julia cũng cấp một module tiêu chuẩn tên là DelimitedFiles, dùng để đọc và ghi những file dữ liệu được ngăn cách, chẳng hạn như file mat.csv dưới đây:\n1 2  3, 3.3, 1.0 0.8, 1.9, 3.2   Chúng ta dùng DelimitedFiles để đọc file trên thành ma trận một cách dễ dàng:\n1 2 3 4 5  using DelimitedFiles # đọc file mat.csv thành ma trận # sử dụng dấu \u0026#39;,\u0026#39; để ngăn cách # ép kiểu phần tử ma trận ra vào thành Float32 readdlm(\u0026#34;mat.csv\u0026#34;, \u0026#39;,\u0026#39;, Float32)   Để ghi một ma trận ra file thay vì dùng \u0026ldquo;read\u0026rdquo;, chúng ta dùng \u0026ldquo;write\u0026rdquo;:\n1 2 3 4 5 6  # Ma trận tạo ngẫu nhiên số phức cỡ 3 × 3 A = rand(ComplexF32, 3, 3) # Ghi ma trận A ra file mat.txt # dùng dấu \u0026#39;,\u0026#39; để ngăn cách # mặt định là kí tự \\t writedlm(\u0026#34;mat.txt\u0026#34;, A, \u0026#39;,\u0026#39;)   Sử dụng tên file sẽ ghi đè hoàn toàn file cũ. Nếu bạn muốn viết tiếp vào file hiện có, bạn có thể dùng lệnh open như ở trên với mode \u0026quot;a\u0026quot;, sau đó thay tên file trong những hàm trên bằng con trỏ file.  Ưu điểm của cách này là nó rất dễ, nhưng:\n cách này không lưu lại kiểu dữ liệu của ma trận (chẳng hạn mình có một ma trận nhưng ma trận này không chứa số) chậm: ví dụ chỉ lấy ma trận vuông kích cỡ 3 nên điều này không thể hiện rõ lắm.  Vậy chúng ta dùng cách nào để lưu? Cách đơn giản thứ 2 là dùng file .npy (file ma trận của Numpy). Để làm điều này chúng ta cần có gói Pycall. PyCall cung cấp giao diện giá đơn giản để chúng ta thao tác với Numpy.\n1 2 3 4 5 6 7 8  # lôi thằng numpy ra using PyCall numpy = pyimport(numpy) # tạo ma trận random M = rand(10000, 10000) # ghi và đọc file ma trận numpy.save(\u0026#34;mat.npy\u0026#34;, M) numpy.read(\u0026#34;mat.npy\u0026#34;)   Việc đọc/ghi file ma trận với ma trận M như trên sẽ chỉ mất khoảng 1 giây. Còn với DelimitedFiles chúng ta sẽ mất kha khá thơi gian. Nếu bạn cần đọc file .csv hãy dùng gói CSV.jl hoặc DataFrames.jl.\nNgoài ra, chúng ta có thể dùng file ma trận của Matlab với gói MAT.jl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  using MAT # mở file dữ liệu matlab io = matopen(\u0026#34;data.mat\u0026#34;) # tạo ma trận random, lưu vào file matlab M = rand(10000, 10000) # lưu biến Julia M vào thành biến matlab matM write(io, \u0026#34;matM\u0026#34;, M) # hoặc matwrite(\u0026#34;data.mat\u0026#34;, Dict(\u0026#34;matM\u0026#34; =\u0026gt; M); compress = true) # đọc 1 biến từ file Matlab names(io) # lấy ra những tên biến Matlab M = read(io, \u0026#34;matM\u0026#34;) # đọc biến matM trong file # đọc tất cả biến Matlab vars = matread(\u0026#34;data.mat\u0026#34;) # trả về một từ điển   Lưu trữ vạn năng Ở trên mình có nói chúng ta có thể lưu ma trận theo \u0026ldquo;định dạng riêng của Julia\u0026rdquo;. Thực ra có một vài, không chỉ một định dạng, trong đó khá nổi bật là hai định dạng của JuliaDB và JLD2.\nCả hai định dạng file trên đều rất nhanh và tiện lợi để dùng. Không những lưu được số, chữ hay những kiểu dữ liệu nguyên thủy, hai anh này còn lưu được gần như tất cả các loại dữ liệu trong Julia, kể cả dữ liệu người dùng định nghĩa.\nJuliaDB thiên về lưu trữ cơ sở dữ liệu nhiều hơn (lưu các bảng dữ liệu), mình sẽ không nói thêm. Các bạn tự tìm hiểu nhé!  JLD2 cung cấp hai macro để tiện lưu, nạp dữ liệu:\n1 2 3 4 5  hello = \u0026#34;world\u0026#34; foo = :bar # lưu dữ liệu @save \u0026#34;data.jld2\u0026#34; hello foo @load \u0026#34;data.jld2\u0026#34; hello foo   Cách trên không tiện lắm vì chúng ta không đổi được tên của các biến được lưu hay nạp, đồng thời chúng ta cũng không thể ghi thêm hay gì khác. Thay vào đó, chúng ta có thể mở file .jld2 và tạo con trỏ file như những loại file khác.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # lưu dữ liệu # tạo file mới để ghi vào jldopen(\u0026#34;data.jld2\u0026#34;, \u0026#34;w\u0026#34;) do file # lưu giá trị \u0026#34;warudo\u0026#34; với nhãn \u0026#34;hello\u0026#34; trong file file[\u0026#34;hello\u0026#34;] = \u0026#34;warudo\u0026#34; # hoặc write(file, \u0026#34;Hello\u0026#34;, \u0026#34;warudo\u0026#34;) end # nạp dữ liệu za = jldopen(\u0026#34;data.jld2\u0026#34;) do file # in ra tên các \u0026#34;biến\u0026#34; có trong file @show keys(file) # nạp lại giá trị của nhãn \u0026#34;hello\u0026#34; read(file, \u0026#34;Hello\u0026#34;) # hoặc file[\u0026#34;hello\u0026#34;] end @show za   Ngoài ra, có một gói mang tên FileIO.jl, gói này cung cấp giao diện để mở và làm việc kha khá nhiều loại file. JLD2 cũng được hỗ trợ:\n1 2 3  using FileIO save(\u0026#34;data.jld2\u0026#34;, Dict(\u0026#34;hello\u0026#34; =\u0026gt; :friend)) goodbye = load(\u0026#34;data.jld2\u0026#34;, \u0026#34;hello\u0026#34;)   Lưu ý rằng FileIO không trực tiếp mở file mà phải sử dụng một gói khác hỗ trợ. Bạn vẫn cần JLD2 để làm việc với file .jld2.\nĐiều hay nhất của JLD2 và FileIO là, khi bạn lưu, thông tin về kiểu dữ liệu của bạn cũng sẽ được lưu. Khi nạp lại để sử dụng, chúng ta không cần xử lí thêm về kiểu.\nKiểu file dữ liệu khác Ngoài ra chúng ta còn có những kiểu dữ liệu phức hợp khác được lưu dưới dạng file. Mình sẽ chỉ nêu tên gói, các bạn sẽ tự tìm hiểu nhé:\n   Kiểu dữ liệu Các gói liên quan     npy, pickle PyCall.jl   XML EzXML.jl, XMLDict.jl, LightXML   Excel ExcelFiles.jl, ExcelReaders.jl   JSON JSON.jl   BSON BSON.jl   HDF5 HDF5.jl   Một số file âm thanh LibSndFile.jl, MP3.jl, WAV.jl   File ảnh Images.jl   Arrow, Feather Feather.jl, Arrow.jl    Làm việc với hệ thống file Các hệ điều hành thường sử dụng các hệ thống file các nhau. Cụ thể hơn, chúng ta thường phải quan tâm về cách tương tác vì chúng ta là người dùng. May thay, Julia cung cấp một giao diện chung để tương tác với hệ thống file khác nhau, giúp chúng ta tập trung vào những việc khác. Mình sẽ giới thiệu một số hàm mình nghĩ rằng hữu dụng.\nĐường dẫn tới thư mục hiện tại.\n1  pwd()   Đường dẫn tới thư mục/file tạm thời tương ứng với mỗi hệ điều hành.\n1 2  tempdir() tempname()   Chuyển tới một thư mục.\n1  cd(\u0026#34;đường dẫn\u0026#34;)   Ghép các đường dẫn, hàm này dùng để xử lý sự khác biệt giữa hệ thống file của Windows và *Nix.\n1 2 3  joinpath(\u0026#34;dir\u0026#34;, \u0026#34;subdir\u0026#34;, \u0026#34;file\u0026#34;) # trả về \u0026#34;dir/subdir/file\u0026#34; trên *Nix (Linux, BSD...) # trả về \u0026#34;dir\\subdir\\file\u0026#34; trên Windows   Tạo thư mục, mkdir sẽ tạo thư mục nếu tìm thấy các thư mục cha, còn mkpath sẽ tạo thư mục cha nếu không tìm thấy.\n1 2  mkdir(\u0026#34;đường dẫn\u0026#34;) mkpath(\u0026#34;đường dẫn\u0026#34;)   Đọc thư mục:\n1 2 3 4 5 6 7 8 9 10 11 12 13  # lấy ra tất cả tên file readdir(\u0026#34;đường dẫn tới thư mục\u0026#34;) # lấy ra từng tên file một for (root, dirs, files) in walkdir(\u0026#34;.\u0026#34;) println(\u0026#34;Đường dẫn tới các thư mục $root\u0026#34;) for dir in dirs println(joinpath(root, dir)) end println(\u0026#34;Các đường dẫn tới file trong $root\u0026#34;) for file in files println(joinpath(root, file)) end end   Copy (cp), di chuyển (mv), xóa (rm) file:\n1 2 3  cp(\u0026#34;đường dẫn\u0026#34;, \u0026#34;đường dẫn mới\u0026#34;) mv(\u0026#34;đường dẫn cũ\u0026#34;, \u0026#34;đường dẫn mới\u0026#34;) rm(\u0026#34;đường dẫn\u0026#34;)   Kiểm tra xem một đường dẫn có ứng với một file/thư mục/đường dẫn hay không:\n1 2 3  isfile(\u0026#34;xâu\u0026#34;) isdir(\u0026#34;xâu\u0026#34;) ispath(\u0026#34;xâu\u0026#34;)   Thư mục của người dùng:\n1  homedir()   Lấy ra đường dẫn thư mục, tên file từ dường dẫn:\n1 2 3  dirname(\u0026#34;/home/hung/\u0026#34;) # trả về \u0026#34;/home/hung\u0026#34; dirname(\u0026#34;/home/hung\u0026#34;) # trả về \u0026#34;/home\u0026#34; basename(\u0026#34;/tmp/something.jl\u0026#34;) # trả về \u0026#34;something.jl\u0026#34;   Tạm kết Lúc đầu viết mình cũng không nghĩ bài sẽ dài như thế này. Tổng kết lại, chúng ta đã tìm hiểu về:\n Cách đọc, ghi file Lưu trữ tùy ý các kiểu dữ liệu của Julia Tương tác với hệ thống file thông qua Julia  Lưu ý thêm, nếu bạn sử dụng con trỏ file, đừng quên đóng file sau khi làm việc xong. Ngoài ra, với cú pháp do, con trỏ file được cho là local và file sẽ đóng ngay khi khối do chạy xong.\nTham khảo:\n https://docs.julialang.org/en/v1/base/file/# https://docs.julialang.org/en/v1/base/io-network/ https://docs.julialang.org/en/v1/stdlib/DelimitedFiles https://github.com/JuliaIO/FileIO.jl https://github.com/JuliaIO/JLD2.jl https://github.com/JuliaIO/  ","description":"","id":1,"section":"posts","tags":["julia"],"title":"Julia Dojo: làm việc với file","uri":"https://ndgnuh.github.io/julia-dojo/lam-viec-voi-file-trong-julia/"},{"content":"Chào mừng mọi người đến với Julia Dojo.\nLà con người, không phải ai trong số chúng ta cũng có khả năng cân tất cả các việc cùng một lúc, đặc biệt với đống kiến thức tích lũy qua cả trăm năm của nhân loại. Hiển nhiên rằng, một người không thể lập trình mọi thứ từ con số không. Vì vậy, chúng ta có cộng đồng người dùng, có các gói bổ trợ cho một ngôn ngữ lập trình. Trong bài viết ngày hôm nay, chúng ta sẽ tìm hiểu về cách quản lí và sử dụng các gói như vậy trong Julia.\nQuản lí một gói Julia cung cấp tính năng quản lí gói một cách mặc định trong Julia REPL. Để kích hoạt trình quản lí gói, chúng ta nhấn phím ] ở trên một dòng trống.\nGiao diện quản lí gói, đầu dòng chuyển thành `pkg\u0026gt;`   Mọi đoạn code sau đây được sử dụng trong chế độ quản lí gói của Julia  Để cài gói trong Julia, chúng ta sử dụng cú pháp add gói. Chúng ta có thể cài một hoặc nhiều gói, hoặc dùng link github để cài.\nadd DataFrame IJulia add https://github.com/tlienart/Franklin.jl Lưu ý rằng link github sẽ tải bản mới nhất hiện có, bao gồm cả các tính năng thử nghiệm. Sau khi cài đặt một thời gian, chúng ta sẽ cần update gói\nupdate IJulia update Lệnh update sẽ update toàn bộ gói trong khi update TênGói chỉ update một gói được định sẵn thôi.\nKiểm tra những gói được cài đặt:\nst st TênGói Nếu có gói không dùng, chúng ta xóa bỏ nó bằng cách\nrm TênGóiKhôngDùng Khi cài hoặc update gói, những gói phụ thược sẽ được cài đặt theo, khi xóa gói chúng sẽ được tự xóa đi, nên các bạn không cần lo về gói phụ thuộc.\nSử dụng một gói Cách sử dụng một gói trong Julia rất đơn giản. Một gói thông thường sẽ có nhiều module, trong đó có một module chính mang tên của gói đó (ví dụ như gói IJulia.jl sẽ có module IJulia). Chúng ta có hai từ khóa import và using (sử dụng trong chế độ bình thường)\n1 2  import TênModule using TênModule   Sử dụng import sẽ chỉ nhập tên của gói vào phạm vi toàn cục, trong khi using sẽ nhập toàn bộ những hằng số, biến số hoặc hàm mà gói đó xuất ra.\n1 2  import Module1 using Module2   Giả sử Module1 có hàm_a, Module2 có hàm_b. Trong ví dụ trên, nếu chúng ta muốn gọi hai hàm:\n1 2  Module2.hàm_a() hàm_b() # hàm_b được cho ra phạm vi toàn cục   Ngoài ra chúng ta có thể chỉ using một số thành phần của gói:\n1 2  using LinearAlgebra: svd # chỉ hàm svd sẽ được nhập ?svd # xem hàm svd   Môi trường của gói Trình quản lí gói của Julia quản lí theo môi trường, nhìn lại ảnh phía trên, chúng ta sẽ thấy có phần (v1.3) ở trước chữ pkg\u0026gt;:\nmôi trường mặc định, Julia 1.3   Phần v1.3 cho biết môi trường đang hiện hoạt của Julia. Hãy hiểu một cách đơn giản:\n Julia có nhiều môi trường khác nhau Trong môi trường sẽ có những gói được cài khác nhau Môi trường thực chất chỉ là một thư mục, thư mục này chứa một file, file này là danh mục các gói đã được cài Nếu môi trường không có gói nào thì sẽ không dùng được gói đó, dù nó đã được cài (using gây lỗi) Khi làm việc sẽ có một môi trường được kích hoạt (môi trường hiện hành) Bạn có thể chuyển giữa các môi trường  Khi cài một gói mà đã được cài ở môi trường khác, Julia chỉ thêm gói đó vào trong danh mục gói của môi trường hiện hành, chứ không tải hay cài lại. Điều này giúp tránh sự trùng lặp khi cài gói.\nTương tự, việc xóa gói đôi lúc chỉ xóa gói đó khỏi chỉ mục chứ không thực sự xóa nó khỏi ổ đĩa.\nNếu bạn muốn xóa những gói không cài trong môi trường nào, dùng lệnh gc.\n Môi trường mặc định của Julia là môi trường có chứa tên phiên bản, đây sẽ là môi trường bạn sử dụng nhiều nhất cho việc nghiên cứu hay nháp. Nếu bạn đổi sang môi trường khác, bạn sẽ thấy phần trong ngoặc cũng thay đổi.\nĐể chuyển vào một môi trường, ta dùng lệnh activate (trong chế độ quán lí gói).\nactivate /đường/dẫn/tới/thư/mục Để chuyển về môi trường mặc định, chúng ta sử dụng lệnh activate mà không truyền tham số vào.\nMột số gói/module trong Julia Mình chỉ giới thiệu một số thôi, chỗ này không phải tất cả nhé!\nMột số module đi kèm trong Julia, không cần cài đặt (standard library):\n   Tên Chức năng     Dates Làm việc với thời gian   Distributed Hỗ trợ tính toán song song   LibGit2 Binding của một thư viện C để làm việc với Git   Libdl Làm việc với thư viện liên kết động   LinearAlgebra Đại số tuyến tính, svd, lu, trị riêng \u0026hellip;   SparseArray Ma trận thưa thớt   SharedArrays Dữ liệu được lưu trên vùng nhớ chung   Sockets Làm việc với Unix sockets   Statistics Công cụ thống kê   Test Unit testing   Profile Profile code    Một số gói do cộng đồng viết:\n   Tên gói Chức năng     IJulia Dùng Julia với Jupyter notebook   DataFrames Bảng dữ liệu   Distributions Các loại phân phối xác suất   DataStructures Các loại cấu trúc dữ liệu   DifferentialEquations Giải các pt vi phân   JuMP Công cụ tối ưu   Plots Vẽ đồ thị (nhiều backend)   HTTP, Genie, Mux Công cụ làm Web App, Web API   CUDAnative Công cụ cho CUDA   PyCall Gọi python từ Julia   TensorFlow Wrapper cho TensorFlow   ScikitLearn Cài đặt lại hoàn toàn ScikitLearn trong Julia    Tạm kết Trong bài viết này, chúng ta đã tìm hiểu về:\n Cách cài đặt, update, xem và xóa gói Julia Cách sử dụng các module trong Julia Làm việc với môi trường của gói Một số module và gói trong Julia  Trong bài viết sau, chúng ta sẽ học cách sử dụng Julia với Jupyter notebook hoặc Jupyter lab. Hẹn gặp lại các bạn.\nTham khảo thêm:\n Quản lí gói: https://docs.julialang.org/en/v1.0/stdlib/Pkg/ Thư viện tiêu chuẩn: https://docs.julialang.org/en/v1/stdlib/Base64/ Tìm kiếm gói Julia: https://pkg.julialang.org/docs/  ","description":"Hướng dẫn cài đặt và sử dụng các gói trong Julia","id":2,"section":"posts","tags":["julia"],"title":"Julia Dojo: quản lí gói trong Julia","uri":"https://ndgnuh.github.io/julia-dojo/cai-dat-va-su-dung-goi-julia/"},{"content":"Chào mừng mọi người quay trở lại Julia Dojo. Trong bài trước chúng ta đã học về trình quản lí gói và cách để sử dụng các gói. Hôm nay, chúng ta sẽ thực hành cài đặt và sử dụng gói đầu tiên, cũng chính là gói mà hỗ trợ chúng ta làm việc với Jupyter Notebook.\nCó thể bạn chưa biết, tên của project Jupyter thực ra được tạo thành từ ba ngôn ngữ: Julia, Python và R. Dù không phải viết tắt trực tiếp của ba ngôn ngữ nhưng cái tên này đã cho thấy rất rõ ràng định hướng của project.  Cấu hình \u0026amp; cài đặt Trước khi cấu hình Julia để làm việc với Jupyter, chúng ta cần có Python hoặc Jupyter notebook/lab cài đặt sẵn trong máy (Python là phụ thuộc của Jupyter). Sau đó chúng ta tiến hành cài gói Julia. Mình sẽ không hướng dẫn cài đặt Python ở đây, rất nhiều hướng dẫn khác đã tồn tại trên mạng.\nSau khi thỏa mãn mọi điều kiện, bạn mở REPL và cài đặt gói IJulia.\n1  ]add IJulia   Nếu các bạn không quen với Jupyter (thường được biết đến với Jupyter Notebook), mình sẽ giải thích một cách ngắn gọn: Jupyter là một giao diện hơi giống REPL trên nền web dành cho các ngôn ngữ lập trình. Jupyter khác REPL ở chỗ, nó lưu lại lệnh và ghi chú của bạn. Để Jupyter hoạt động được, chúng ta cần có một thứ gọi là \u0026ldquo;nhân\u0026rdquo; của ngôn ngữ lập trình. Quy trình làm việc như sau:\n Jupyter nhận input của bạn Jupyter sẽ gửi code đến nhân Nhiệm vụ của nhân là chạy đoạn code đó, sau đó gửi output tới Jupyter Jupyter hiện output cho bạn  Gói IJulia chính là \u0026ldquo;nhân\u0026rdquo; dành cho ngôn ngữ Julia. Sau khi cài gói xong, chúng ta cần chạy lần đầu để Julia cài đặt nhân và cấu hình Jupyter để sử dụng nó. Bạn không cần lo về việc cài Jupyter, khi chạy IJulia lần đầu, Julia sẽ cài đặt Jupyter cho chúng ta nếu cần.\n1 2 3  using IJulia notebook() # để dùng Jupyter Notebook jupyterlab() # để dùng Jupyter Lab   Sử dụng Chúng ta có thể sử dụng Julia với Jupyter theo cách ở trên, tuy nhiên, Jupyter sẽ dùng thư mục mà chúng ta dùng đang mở (thư mục mà chúng ta dùng để chạy Julia). Sau khi cấu hình với lần chạy đầu tiên của IJulia, chúng ta sẽ không cần mở REPL lên để dùng notebook nữa. Thay vào đó, chúng ta hãy mở một terminal tại thư mục bạn muốn. Ví dụ, mình dùng notebook:\n1 2 3 4  cd notebook jupyter notebook # hoặc bạn muốn dùng jupyter lab jupyter lab   Mình chỉ hướng dẫn notebook thôi, lab bạn tự tìm hiểu nhé. Sau khi chạy lệnh trên, một cửa sổ trình duyệt sẽ hiện lên:\nGiao diện Jupyter Notebook   Để tạo một notebook, hãy ấn vào nút New ở góc phải màn hình. Sau đó một danh sách các nhân đã cài sẽ hiện lên, ở đây mình có hơi nhiều :)\nMenu tạo notebook mới   Click vào Julia x.y.z để tạo một notebook sử dụng Julia, một cửa sổ khác sẽ hiện lên.\nGiao diện của một notebook   Trong cửa sổ này, chúng ta có thể thêm, sửa, xóa, chạy các ô code hoặc nhấn phím m để chuyển qua viết ghi chú. Phím y dùng để chuyển lại một ô thành code và tổ hợp Ctrl/Shift + Enter dùng để chạy ô code đó.\nChạy code Julia, viết Markdown và LaTeX   Tạm kết Qua bài viết lần này, chúng ta đã biết cách cấu hình Julia để sử dụng với Jupyter Notebook. Những phần còn lại của giao diện notebook mời các bạn tự khám phá thêm, mình xin kết thúc bài viết này ở đây, tạm biệt và hẹn gặp lại các bạn trong những bài viết sau.\nTham khảo:\n https://github.com/JuliaLang/IJulia.jl https://jupyter.org/install  ","description":"Hướng dẫn cấu hình Julia để sử dụng với Jupyter Notebook và Jupyter Lab","id":3,"section":"posts","tags":["julia"],"title":"Julia Dojo: Julia + Project Jupyter","uri":"https://ndgnuh.github.io/julia-dojo/dung-julia-voi-jupyter-notebook-va-jupyter-lab/"},{"content":"Mọi người có thể gửi feedback cho mình thông qua các cách sau:\n Email: ndgnuh@protonmail.com Github (gửi issue hoặc pr): https://github.com/ndgnuh/ndgnuh.github.io Google form: https://forms.gle/EPHRrgPggS1dNEjW9  Nếu bạn muốn gửi feedback nặc danh, không dùng bất kì loại tài khoản nào, hãy dùng google form.  ","description":"","id":4,"section":"","tags":null,"title":"Liên hệ","uri":"https://ndgnuh.github.io/lien-he/"},{"content":"Chào mừng các mọi người quay trở lại với series Julia Dojo. Như mình đã giới thiệu, Julia là một ngôn ngữ lập trình hàm, và ngôn ngữ lập trình hàm thì\u0026hellip; không thể thiếu hàm. Thậm chí, hàm là thực thể \u0026ldquo;hạng nhất\u0026rdquo; của Julia. Trong bài viết này, mình sẽ giới thiệu về cú pháp viết và sử dụng các hàm, cũng như một số trường hợp hay gặp.\nBài viết chủ yếu giới thiệu các cú pháp để làm việc với hàm nên không nói quá chi tiết. Phần đó được dành cho một bài viết khác  Như mình nói ở phần cấu trúc điều khiển, nếu cấu trúc điều khiển của bạn quá phức tạp, bạn có thể sẽ phải viết một hàm. Trong bài viết này mình sẽ nói về việc khai báo, phạm vi biến và gọi hàm.\nKhai báo một hàm Ba kiểu khai báo Việc khai báo một hàm trong Julia có thể được làm theo nhiều cách. Cách 1 là dùng khối function:\n1 2 3 4  function tên_hàm(tham_số) # thân hàm return (giá trị trả về) end   Đoạn code trên là ví dụ đơn giản nhất của một hàm. Từ khóa return không thực sự cần thiết, nếu không có return hàm trên sẽ trả về giá trị của biểu thức cuối cùng được chạy (giống khối if).\nVì Julia là ngôn ngữ động nên hàm trên sẽ chạy với mọi kiểu dữ liệu. Tuy vậy, chúng ta vẫn có thể kiểm soát kiểu dữ liệu của tham số được truyền vào, cũng như kiểu dữ liệu mà hàm trả về.\n1 2 3 4 5  # đây chỉ là ví dụ # đừng viết hàm kiểu này function cộng_một(n::Int)::Int n + 1 # trả về (n + 1) vì đây là biểu thức cuối end   Vì chúng ta chưa tìm hiểu sâu về kiểu dữ liệu nên tạm thời hãy viết những hàm mà chạy với tất cả các kiểu (tức là không định kiểu). Những hàm như vậy được gọi là \u0026ldquo;generic\u0026rdquo; (tổng quát).\nVới những hàm ngắn gọn như vậy, chúng ta có thể dùng hai cú pháp sau:\n1  cộng_một(n) = n + 1   Mình nghĩ họ gọi kiểu hàm trên là hàm \u0026ldquo;inline\u0026rdquo;. Ngoài việc nhìn trông rất thích mắt (nhìn giống với hàm toán học), nếu được cài đặt đúng cách, khi chúng được gọi, thân hàm sẽ được thay thế trực tiếp vào phần code đang gọi nó (tức là code chạy nhanh hơn, không tốn thêm stack).\nTrong Julia, chúng ta có thể khai báo các hàm mà không cần đặt tên cho chúng, chỉ cần bỏ phần tên khỏi hàm:\n1 2 3  function(n) n + 1 end   Những hàm kiểu này thường được dùng làm tham số của một hàm khác. Do dó Julia cung cấp cho chúng ta một cách khai báo tiện gợi hơn:\n1  n -\u0026gt; n + 1   Đương nhiên, nếu muốn chúng ta vẫn có thể gắn tên cho chúng, vì hàm trong Julia có thể được coi là một biến:\n1 2 3 4  cộng_một = n -\u0026gt; n + 1 cộng_một = function(n) n + 1 end   Tuy nhiên, cú pháp với -\u0026gt; thường được sử dụng cho hàm vô danh, những hàm bạn chỉ dùng một lần rồi vứt, không nên dùng để khai báo một hàm có tên như vậy.\nChúng ta cũng có thể khai báo một hàm là toàn cục hay nội bộ với từ khóa local hoặc global\n1 2 3 4 5 6  global function our_func() # thân hàm end local function our_func() # thân hàm end   Tham số mặc định Trong Julia bạn có thể gắn giá trị mặc định cho tham số của hàm:\n1  cộng(n, i = 1) = n + 1   Khi gọi hàm trên, nếu bạn không truyền tham số i thì i sẽ nhận giá trị mặc định là 1\n1  cộng(10) # trả về 11   Tham số có tên Ngoài những tham số được sắp theo thứ tự như trên, hàm trong Julia còn hỗ trợ tham số có tên (keyword arguments). Mặc dù không cần thiết, tham số có tên được ngăn cách với tham số \u0026ldquo;bình thường\u0026rdquo; bằng dấu ; (cả khi gọi và khai báo hàm).\n1 2  cộng(n; m) = n + m cộng(10; m = 20) # trả về 20   Tham số có tên cũng có thể nhận giá trị mặc định. Khi gọi, thứ tự của tham số này không quan trọng, chỉ cần chúng ta định đúng tên:\n1 2 3 4 5  cộng(n; m = 2, p = 3) = n + m + p cộng(10) # trả về 15 cộng(10; p = 8) # trả về 20 cộng(10; z = 100) # lỗi, không có z cộng(10, m = 17) # dùng dấu `,` cũng không sao   Tùy lượng tham số Cuối cùng, chúng ta có một kiểu tham số đặc biệt. Mình nghĩ nó sẽ dễ hiểu hơn với một ví dụ:\n1 2 3 4  trung_bình(args...) = sum(args) / length(args) trung_bình(1, 3, 8) # trả về 4 trung_bình(1, 1, 1, 3) # 1.5 trung_bình(1) # 1   Hàm sum có thể dùng để tính tổng của một mảng, còn length dùng để đếm số phần tử. Như vậy, khi khai báo hàm như trên, những tham số được \u0026ldquo;nhét\u0026rdquo; vào một mảng và cũng ta thao tác trực tiếp trên mảng đó. Điều đó có nghĩa chúng ta có thể truyền một cách tùy, bao nhiêu tham số cũng được.\nGọi hàm Gọi hàm trong Julia rất đơn giản, chúng ta thậm chí đã gọi một số hàm trước đây rồi. Hàm được gọi bằng cú pháp tên_hàm(tham_số; tham_số_có_khóa)\n1  sort([1, -3, 2]; rev = true) # sắp xếp giảm dần   Chúng ta cũng có thể gọi hàm một cách lồng nhau:\n1 2 3  # tạo random mảng 4 phân tử trong khoảng [-9, 9] # sau đó sắp xếp giảm dần sort(rand(-9:9, 4); rev = true)   Tuy nhiên, với những hàm gọi lồng nhau mà không cần tham số nào khác, kiểu như sau:\n1 2 3 4 5  # khai báo f(x) = x + 1 g(x) = 42x # gọi hàm g(f(1))   Julia cung cấp cho chúng ta toán tử rất tiện lợi để tổ hợp hàm:\n1 2  # cách gõ: \\circ\u0026lt;tab\u0026gt; (g ∘ f)(1) # tương dương với g(f(1))   Sự tiện lợi chưa dừng ở đây. Bạn có thể áp dụng một hàm lên một tập hợp giống như lúc làm với toán tử, bằng cách thêm dấu . ở giữa tên hàm và tham số truyền vào:\n1 2 3  M = [1 2 3; 2 3 4; 4 5 6] f(x) = x^2 + 3 f.(M) # lấy mọi phần tử trong ma trận M, mũ 2 rồi cộng 3   Phạm vi biến trong hàm Julia Giống với các vòng lặp, mọi biến trong hàm của Julia đều mặc định có phạm vi là nội bộ. Hàm có thể thay đổi khai báo hoặc thay đổi biến toàn cục, nhưng phải dùng từ khóa global.\nHàm lồng trong hàm Như mình nói phần khai báo hàm, chúng ta có thể thay đổi phạm vi của hàm, vậy các hàm local dùng ở đâu? Đương nhiên là dùng trong các khối khác, dễ hình dung nhất là \u0026ldquo;hàm lồng trong hàm\u0026rdquo;.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function hàm_cha(n) # tính toán function hàm_con(tham_số_con) # thân hàm con end # tính toán while(điều_kiện) # tính toán for i in một_cái_gì_đó # tính toán dùng hàm con vì logic ở đây khá dài hàm_con(tham_số_con) # tính toán end # tính toán end end   Vì những biến được định nghĩa trong hàm mặc định là local - và những hàm trong Julia có thể được coi là một biến, hàm định nghĩa trong hàm mặc định cũng là local. Trong trường hợp trên, hàm_con sẽ không bị \u0026ldquo;rò rỉ\u0026rdquo; ra ngoài phạm vi toàn cục. Chúng ta cũng có thể khai báo hàm local ở trong các khối khác, không nhất thiết phải trong một hàm:\n1 2 3 4 5 6  for i = 1:3 cộng_thêm_i(x) = x + i for j = 2:3 @show cộng_thêm_i(j) end end   Hành vi với tham số truyền vào Trong Julia, đa số các hàm chỉ nhận tham trị và không thay đổi các biến đầu vào. Đương nhiên chúng ta vẫn có những hàm thay đổi tham số của nó. Những hàm này nếu dùng không cẩn thận có thể gây ra những hành vi rất khó đoán, việc phân biệt chúng cũng rất đau đầu trong một số ngôn ngữ.\nMay thay, Julia cung cấp một quy ước để định ra những hàm thay đổi tham số truyền vào của chúng. Những hàm này sẽ có một dấu ! ở sau tên của chúng.\n1 2 3 4 5  arr = [1, -3, 2] sort(arr) # hàm này chỉ trả về mảng đã sắp xếp @show arr sort!(arr) # hàm này sắp xếp luôn mảng arr @show arr   Lưu ý rằng đây chỉ là một quy ước, bạn hoàn toàn có thể viết hàm thay đổi tham số đầu vào mà không có dấu ! trong tên và ngược lại.\nTạm kết Mình xin kết thúc bài giới thiệu về hàm ở đây. Vậy là chúng ta đã kết thúc level 1 của Julia Dojo. Tuy vậy, tất cả những thứ trong level này đều mang tính giới thiệu. Điều đó cũng khá hiển nhiên thôi, một ngôn ngữ vừa nhanh vừa tiện để viết, dù nó đơn giản nhưng bạn cũng không mong nó đơn giản tới mức cục mịch chứ? :)\nĐừng lo, dù phức tạp đi nữa thì Julia khá dễ vọc, không như kiểu hợp ngữ đâu. Mình sẽ cố giải thích cho các bạn những thứ cơ bản, đến khi đủ để các bạn tự tìm hiểu. Nếu các bạn có thắc mắc hoặc thấy thiếu sót đừng ngại liên hệ. Hẹn gặp mọi người trong những level tiếp theo.\n","description":"Giới thiệu về hàm trong Julia","id":5,"section":"posts","tags":["julia"],"title":"Julia Dojo: hàm","uri":"https://ndgnuh.github.io/julia-dojo/ham-trong-julia/"},{"content":"Chào mừng các bạn trở lại với Julia Dojo. Chúng ta đã tìm hiểu về cách khai báo biến và làm việc với một số kiểu dữ liệu trong bài viết biến số, kiểu dữ liệu, phép toán. Nhưng một chương trình chỉ có gán, gọi hàm và phép toán không thì không đủ, do đó, chúng ta ta có các cấu trúc điều khiển.\n  Nội dung chỉnh sửa  29/01/2020:\n- thêm phần lặp for, lặp với bước nhảy không phải 1\n- thêm phần khối lệnh (vốn định đưa sang bài hàm, nhưng thôi)   Khối lệnh Đến phần này, chúng ta sẽ phải biết cách nhận biết một khối lệnh trong Julia. Trong các ngôn ngữ như C hoặc Java, chúng ta dùng một cặp { } để đánh dấu các dòng lệnh. Ở đây chúng tôi không làm vậy.\nLỗi: meme được dùng đi dùng lại quá nhiều  Thay vào đó, mỗi từ khóa end sẽ được kết hợp với các từ khóa lặp, khai báo hàm, rẽ nhánh, v.v\u0026hellip; ở đầu của một khối lệnh. Một cặp \u0026ldquo;từ khóa mở đầu - end\u0026rdquo; sẽ đánh dấu một khối lệnh trong Julia. Khối lệnh đơn giản nhất trong Julia, là\u0026hellip; một khối lệnh theo đúng nghĩa. Nó bắt đầu với từ khóa begin, mình thường dùng khi phép gán của mình có một biểu thức rất dài, nên muốn chia nó thành các biến phụ cho đỡ rối mắt.\n1 2 3 4 5  z = begin local x = 1 local y = 2 # tưởng tượng nó rất dài hộ mình :) x + y end   Khối lệnh sẽ trả ra giá trị ứng với biểu thức ứng cuối cùng của nó (tức x + y trong ví dụ trên). Ngoài ra chúng ta cũng có thể dùng từ khóa return để trả về một giá trị và kết thúc việc thực hiện khối lệnh. Hãy cẩn thận, khối begin có thể thay đổi biến toàn cục mà không báo trước, đó cũng là lí do mình dùng từ khóa local ở trên.\nNếu bạn không thích dùng begin, end chúng ta cũng có thể viết:\n1 2 3 4  z = (local x = 1; local y = 2; x + y) z = (local x = 1; local y = 2; x + y)   Mình là người có điều kiện If\u0026hellip; Hãy thử tượng tượng phải lập trình nhưng không được dùng các cấu trúc rẽ nhánh xem. Bạn sẽ làm ra một chương trình mà, hoặc không thể sử dụng được, hoặc chứa một đống các loại đa hình để thay cho cấu trúc rẽ nhánh (cũng không lí tưởng lắm!). Vậy nên, tội gì không sử dụng if - else cho cuộc sống dễ dàng.\n1 2 3 4 5 6 7 8  x = rand(-1:1) if x == 1 println(x) elseif x == 0 println(x + 1) else println(x + 2) end   Chúc mừng, bạn đã viết thành công chương trình in ra số 1 (dùng if - else - end). Trong cấu trúc rẽ nhánh, các từ khóa elseif, else là không bắt buộc, nếu bạn không có nhiều trường hợp thì không phải viết chúng.\nNếu các bạn đang tự hỏi Julia có cấu trúc switch hay không, mình trả lời luôn là không, lí do là\u0026hellip; không cần thiết. Thực chất cấu trúc switch có thể được thay thế bằng if và một đống elseif, mỗi điều kiện chính là một case, và else chính là default.\nToán tử ba ngôi Trong Julia, mọi cấu trúc if đều trả về một giá trị nào đó. Bạn hoàn toàn có thể viết như sau:\n1 2 3 4 5 6  @show a = rand(0:1) # a nhận giá trị 0 hoặc 1, ngẫu nhiên b = if a == 0 0 else 1 end; println(\u0026#34;b = $b\u0026#34;)   Đoạn chương trình trên\u0026hellip; in ra số 0 và gắn b bằng a rồi in ra b. Giá trị của if trả về chính là câu lệnh cuối cùng mà nó chạy. nhưng nếu thích bạn có thể viết từ khóa return để \u0026ldquo;trang trí\u0026rdquo;.\n1 2 3 4 5  b = if a == 0 return 0 else return 1 end   Nhưng mà thực sự, đừng làm như vậy :) Chúng ta có toán tử ba ngôi cho những việc như thế này.\n1 2  a = rand(0:1) b = (a == 1) ? 1 : 0   Vẫn là chương trình random a rồi gán b bằng a, nhưng gọn hơn rất nhiều (mình không nói là cách gọn nhất\u0026hellip;). Dấu ngoặc bao quanh điều kiện là không cần thiết, nhưng mình viết vậy vì nó dễ nhìn.\nNếu dùng @show lên toán tử ba ngôi, chúng ta sẽ thấy nó chỉ là một khối if được đơn giản hóa.\n1 2 3 4 5 6 7  julia\u0026gt; @show (x == 1) ? 1 : 0 if x == 1 1 else 0 end = 1 1   Phạm vi của biến trong if Những biến được khai báo trong khối if sẽ tồn tại ở cả bên ngoài khối. Ví dụ trong đoạn code dưới đây:\n1 2 3 4 5 6  if rand(Bool) x = 1 else x = 10 end @show x   Nếu biến x chưa tồn tại, nó sẽ được khai báo. Nếu nó đã tồn tại, giá trị của nó sẽ được thay đổi. Việc thêm từ khóa local sẽ không có tác dụng gì. Nói cách khác, khối if có cùng phạm vi biến (scope) với khối lệnh chứa nó\nLặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp\u0026hellip; Thử tưởng tượng lập trình mà không có vòng lặp xem (thực ra các bạn có thể dùng đệ quy thay cho vòng lặp, nhưng mình thấy lặp vẵn dễ sống hơn!). Vòng lặp khác với hai khối trên (ngoài việc nó lặp) ở chỗ: nó không trả về giá trị gì cả, trừ khi bạn ném từ khóa return vào trong vòng lặp.\nJulia cung cấp cho chúng ta hai loại vòng lặp: for và while, hãy cùng tìm hiểu chúng.\nVòng lặp for Đầu tiên chúng ta có vòng lặp for để lặp với số lần xác định trước:\n1 2 3 4 5 6  for i = 1:10 println(i) end for i = 1:2:10 # lặp với bước nhảy 2, mặc định bước nhảy là 1 println(i) end   Bạn cũng có thể dùng lặp với từng phần tử của một tập hợp hay một mảng nào đó.\n1 2 3 4  arr = [1, 2, 3] for x in arr println(x) end   Chúng ta cũng có thể lặp qua một xâu kí tự:\n1 2 3 4  s = \u0026#34;xin chào\u0026#34; for i = 1:length(s) println(s[i]) end   Khi chạy đoạn code trên, chúng ta sẽ thu được\u0026hellip; lỗi.\n1 2 3 4 5 6  ERROR: StringIndexError(\u0026#34;xin chào\u0026#34;, 8) Stacktrace: [1] string_index_err(::String, ::Int64) at ./strings/string.jl:12 [2] getindex_continued(::String, ::Int64, ::UInt32) at ./strings/string.jl:220 [3] getindex(::String, ::Int64) at ./strings/string.jl:213 [4] top-level scope at ./REPL[4]:2   Điều này xảy ra vì Julia hỗ trợ unicode, do đó không phải string nào cũng là ascii (bạn có thể kiểm tra bằng hàm isascii). Những kí tự không nằm trong bảng ascii sẽ chiếm một số lượng index không xác định. Vậy muốn lặp qua một xâu kí tự an toàn thì làm như thế nào?\n1 2 3  for i in eachindex(s) println(s[i]) end   Hàm eachindex sẽ sinh ra một bộ chỉ số của xâu s và bạn có thể lặp qua từng kí tự của s một cách an toàn. Hơn nữa, eachindex nhìn đẹp hơn 1:length(s). Nếu bạn không cần chỉ số mà chỉ cần kí tự, bạn có thể lặp như sau:\n1 2 3  for c in s println(c) end   Không chỉ với string, eachindex hoạt động với tất cả các kiễu dữ liệu có thể lặp được (nói sau nhé), bao gồm cả mảng, ma trận. Nếu mình không nhầm, dùng nó cũng có lợi về hiệu năng hơn vì Julia sẽ không phải kiểm tra việc đánh chỉ số có đúng hay không.\nBạn có thể dùng nhiều vòng lặp lồng nhau như các ngôn ngữ lập trình khác:\n1 2 3 4 5 6 7  for i = 1:2 for j = 3:4 for k = 5:6 @show (i, j, k) end end end   Trong trường hợp vòng lặp bên ngoài không có nhiệm vụ gì ngoài gọi vòng lặp con như trên, code của chúng ta sẽ trông như cái tam giác trống, nhìn hơi tù. Julia cung cấp cho chúng ta cách chồng các vòng lặp lên nhau.\n1 2 3  for i=1:2, j=3:4, k=5:6 @show (i, j, k) end   Đoạn code này sẽ in ra cùng một kết quả như trên, nhưng lại gọn gàng và dễ nhìn hơn. Dù sao, nếu bạn phải dùng tới ba bốn vòng lặp, logic trong code của bạn có thể đã trở nên phức tạp và đó là dấu hiệu của việc bạn nên viết hàm.\nVòng lặp while Cấu trúc lặp while thì mạnh mẽ hơn lặp for rất nhiều, nó có thể dùng để lặp với số lần lặp không xác định (hoặc có, nhưng đó là việc của for). Vòng lặp while không có nhiều thứ cần đặc biệt lưu ý giống như for, các bạn có thể dùng nó với cú pháp như sau:\n1 2 3 4 5  điều_kiện = true # biểu thức điều kiện while điều_kiện # làm gì đó # với dữ liệu end   Phạm vi biến của cấu trúc lặp Vòng lặp trong julia có phạm vi biến riêng. Điều đó có nghĩa, các vòng lặp sẽ không thay đổi các biến toàn cục một các tùy tiện.\n1 2 3 4 5 6  # phạm vi toàn cục (global scope) x = 10 for i = 1:10 x = i # biến i vẫn truy cập được end @show x # x vẫn là 10   Tuy nhiên, khi vòng lặp được lồng trong một phạm vi nội bộ (một vòng lặp khác, một hàm), chúng có thể cập nhật biến trong phạm vi đó:\n1 2 3 4 5 6 7  for i = 1:2 x = i for j = 3:4 x = x * j end @show x # biến x sẽ thay đổi end   Nếu bạn muốn thay đổi biến toàn cục, hãy dùng từ khóa global:\n1 2 3 4 5  x = 10 for i = 1:5 global x *= i end @show x # x = 1200   Thoát lặp, nhảy lặp Nếu bạn đang lặp mà muốn dừng giữa chừng, bạn có thể dùng break để thoát hoàn toàn khỏi vòng lặp.\n1 2 3 4 5 6 7  đếm = 1 while true global đếm += 1 if đếm == 4 break end end   Nếu vì lí do nào đó, bạn muốn nhảy cóc một vòng lặp, bạn có thể dùng từ khóa continue.\n1 2 3 4 5 6 7  for i = 1:4 if i == 3 continue else @show i end end   Với những đoạn rẽ nhánh đơn giản như trên, chúng ta có thể dùng kết hợp với toán tử ba ngôi cho gọn:\n1 2 3  for i = 1:4 i == 3 ? continue : @show i end   Tạm kết Sau khi biết được các cấu trúc điều khiển cơ bản. Hãy nhớ rằng nếu bạn lồng quá nhiều cấu trúc điều khiển với nhau, bạn có thể đang cần tách logic trong code ra thành một hàm. Viết hàm thế nào, hồi sau sẽ rõ :) Hẹn gặp lại các bạn ở bài viết sau.\n","description":"Cấu trúc điều kiện và lặp trong Julia","id":6,"section":"posts","tags":["julia"],"title":"Julia Dojo: cấu trúc điều khiển trong Julia","uri":"https://ndgnuh.github.io/julia-dojo/re-nhanh-va-lap-trong-julia/"},{"content":"Chào mừng các bạn trở lại với Julia Dojo. Hôm nay chúng ta sẽ tìm hiểu về một thứ khá cơ bản và thiết yếu trong các ngôn ngữ lập trình, đó là biến số (ok, không hẳn là thiết yếu, nhưng nó làm cuộc sống dễ dàng hơn), đồng thời khám phá một số kiểu dữ liệu cơ bản và thao tác với chúng.\nBiến số, hằng số Đôi khi, trông các bài hướng dẫn về ngôn ngữ lập trình, họ đồng nhất biến số và hằng số theo kiểu \u0026ldquo;hằng số là một biến số mà không thể thay đổi\u0026rdquo;. Điều này không đúng lắm về mặt kĩ thuật (technically correct is the best kind of correct). Tuy nhiên, nếu nó tiện lợi, nghe thuận tai và dễ hiểu hơn với bạn thì\u0026hellip; meh, tùy, whatever floats your boat.  Để khai báo một biến trong Julia, bạn chỉ cần sử dụng cú pháp:\n1 2  tên_biến = \u0026#34;giá trị\u0026#34; こんにちは世界 = \u0026#34;Hello world, google dịch vậy :)\u0026#34;   Điều hay nhất là: hai dòng lệnh trên hoàn toàn hợp lệ trong Julia (copy nó vào REPL và chạy thử đi!). Tên biến số, hằng số trong Julia có thể Là kí tự unicode, và các kí tự tiếng Việt không phải ngoại lệ. Tuy nhiên, mình nghĩ bạn không nên code bằng tiếng Việt có dấu, tiêng Nhật, tiếng Tàu hay tiếng Thái đâu. Cách tốt nhất để dùng tính năng này là:\n1 2 3 4 5 6 7 8  #= Bạn có thể gõ cái này theo các bước: 1. Nhập \u0026#34;\\varepsilon\u0026#34; (var epsilon) 2. Nhấn phím \u0026lt;tab\u0026gt; Tính năng này có trên mọi công cụ hỗ trợ Julia =# ε = 1e-9 # Giờ thì công thức toán trong # code của bạn sẽ gọn và dễ đọc hơn   Cực kì tiện lợi khi bạn code những phần mềm dùng nhiều công thức toán (mà lúc nào chẳng có toán chứ?). Nhân tiện mình giới thiệu luôn, dấu # được dùng để comment trên một dòng code (tất cả những gì sau dấu này sẽ được bỏ qua; còn cặp dấu #= và =# được dùng để comment trên nhiều dòng, mọi thứ giữa hai thằng này sẽ bị bỏ qua khi chạy code.\nCòn đề khai báo hằng số, bạn chỉ cần nhét thêm chữ const vào đầu dòng như sau:\n1  const hằng_số = true   Bất kì biến số, hằng nào bạn định nghĩa như trên trong REPL đều được coi là biến toàn cục. Nếu bạn viết một phần mềm sản xuất, hãy dùng ít biến toàn cục nhất có thể (vì lí do hiệu năng, lí do bảo dưỡng, v.v\u0026hellip; bạn không dùng càng tốt). Nhưng hằng số toàn cục vẫn ok nhé, thực chất Julia chỉ cho phép khai báo hằng số toàn cục thôi. Bạn có thể dùng từ khóa local để khai báo nội bộ và từ khóa global để khai báo toàn cục.\n1 2 3  local x = 1 global y = 2 local const z = \u0026#34;lỗi\u0026#34;   Nếu bạn khai báo biến local trưc tiếp trên REPL, nó sẽ biến mất ngay lập tức và bạn không dùng được nó. Vậy biến nội bộ có hiệu lực ở đâu, hồi sau sẽ rõ :) Giờ chúng ta chuyển sang nói qua về kiểu dữ liệu.\nKiểu dữ liệu Khi bạn gán một biến trong Julia, bộ dịch sẽ tự phát hiện kiểu và gắn kiểu dữ liệu của nó cho biến. Điều tương tự cũng xảy ra với hằng số. Bạn có thể lấy kiểu dữ liệu của một biến hay hằng bằng hàm typeof:\n1 2 3 4 5 6  x = 1.0 typeof(x) # Trả về một kiểu Float typeof(π) # Trả về Irrational{:π} # đây là một hằng số # viết bằng cách \\pi \u0026lt;tab\u0026gt; # có thể dùng chữ pi cũng được   Nhìn mấy cái kiểu dữ liệu có vẻ lằng nhằng, nhưng chúng ta đang ở Level 1, đừng bận tâm về nó vội. Mình chỉ giới thiệu qua một số kiểu dữ liệu hay dùng ở đây thôi.\nCác kiểu số Một ít int\n1  n = 3   Một ít float\n1 2  x = 2.0 y = 4.0   Một ít hữu tỉ\n1  p = 1//2   Một ít hư ảo\n1  z = 1 + 2im # hoặc 1 + 2 * im   Một ít phép toán\n1 2 3 4 5 6 7 8 9 10 11 12 13  đối = -z cộng = n + x cộng += z trừ = n - z nhân = z * p chia = n / x # lấy n chia x chia_ngược = n \\ x # lấy x chia cho n chia_hữu_tỉ = z // (3 - 4im) lũy_thừa = x^n lấy_căn = sqrt(4) lấy_căn_phức = sqrt(complex(-1)) # sqrt(-1) sẽ lỗi, vì kiểu của -1 là Real giá_trị_tuyệt_đối = abs(-3.4) module_phức = abs(z)   Một ít hàm toán học\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # Các hàm liên quan đến logarith exp(x) # e^x, e là hằng số Euler log(x) # loga cơ số e log10(x) # loga cơ số 10 log2(x) # loga cơ số 2 log1p(x) # loga cơ số e của (1 + x) log(y, x) # loga cơ số y của x # Các hàm liên quan tới lượng giác # Ngoài sin ra còn có cos, tan, cot sin(x) # lượng giác, dùng radian, tương tự có cos, tan, cot sind(x) # như sin, nhưng dùng đơn vị độ sinh(x) # hàm hyperbolic asin(x) # lượng giác ngược asind(x) # như asin, đơn vị độ asinh(x) # hàm hyperbolic ngược deg2rad(x) # chuyển từ độ sang radian rad2deg(x) # chuyển từ radian sang độ   Một ít phép so sánh\n1 2 3 4 5 6 7 8 9 10 11 12  bé_hơn = (x \u0026lt; y) lớn_hơn = (x \u0026gt; y) bằng = (x == y) khác = (x != y) khác = (x ≠ y) # \\ne\u0026lt;tab\u0026gt; xấp_xỉ = isapprox(x, y) xấp_xỉ = (x ≈ y) # \\approx\u0026lt;tab\u0026gt; không_xấp_xỉ = (x ≉ y) # \\napprox\u0026lt;tab\u0026gt; lớn_hơn_hoặc_bằng = x \u0026gt;= y lớn_hơn_hoặc_bằng = x ≥ y # \\ge\u0026lt;tab\u0026gt; (Greater than or Equal) bé_hơn_hoặc_bằng = x \u0026lt;= y bé_hơn_hoặc_bằng = x ≤ y # \\le\u0026lt;tab\u0026gt; (Less than or Equal)   Kiểu Bool Julia dùng true và false cho các giá trị thuộc kiểu Bool\n1 2 3 4 5 6 7  a = true b = false phủ_định = !a và_logic = a \u0026amp;\u0026amp; b hoặc_logic = a || b xor_logic = xor(a, b) xor_logc = a ⊻ b # \\xor\u0026lt;tab\u0026gt;   Kí tự và xâu kí tự Trong Julia, kí tự được bao quanh bởi dấu nháy đơn, còn xâu kí tự được bao quanh bởi dấu nháy kép. Bạn có thể dùng 3 dấu nháy kép để viết các xâu kí tự phức tạp, gồm nhiều dòng.\n1 2 3 4 5 6 7 8  kí_tự = \u0026#39;a\u0026#39; xâu = \u0026#34;hello world\u0026#34; xâu_phức_tạp = \u0026#34;\u0026#34;\u0026#34; \u0026#34;Trăm năm trong cõi người ta, Thúy Kiều là mẹ, con là Thúy Vân\u0026#34; Câu thơ cho thấy thằng nào ngồi viết cái này rất dốt văn... \u0026#34;\u0026#34;\u0026#34;   Julia hỗ trợ \u0026ldquo;nội suy\u0026rdquo; xâu kí tự (string interpolation, không mình biết dịch đúng không nữa). Dùng dấu $ là bạn có thể \u0026ldquo;nhúng\u0026rdquo; một biến vào trong xâu kí tự. Nếu bạn muốn dưa một biểu thức vào, hãy dùng $(biểu_thức).\n1 2 3 4  x = rand(-3:3) println(\u0026#34;một số ngẫu nhiên trong khoảng -3 tới 3: $x\u0026#34;) # hoặc println(\u0026#34;một số ngẫu nhiên trong khoảng -3 tới 3: $(rand(-3:3))\u0026#34;)   Một số hành động với kí tự và xâu kí tự:\n1 2 3 4 5 6 7 8  clipboard(\u0026#34;copy toàn bộ xâu kí tự này, dùng cái này max tiện\u0026#34;) collect(\u0026#34;xâu kí tự\u0026#34;) # chuyển xâu kí tự thành một mảng các kí tự Int(\u0026#39;c\u0026#39;) # Chuyển kí tự sang mã Unicode Char(97) # Chuyển mã kí tự thành kí tự length(\u0026#34;độ dài xâu\u0026#34;) \u0026#34;nối\u0026#34; * \u0026#34;xâu\u0026#34; * \u0026#34;kí tự\u0026#34; \u0026#34;nhân lên 3 lần \u0026#34; ^ 3 \u0026#34;abc\u0026#34; \u0026lt; \u0026#34;abd\u0026#34; # so sánh theo thứ tự từ điển, dựa vào mã kí tự   Mảng, ma trận Phần hay nhất để dành cuối cùng :) Julia hộ trợ tính toán ma trận rất ngon. Ngon thế nào thì từ từ mới biết hết, đặc biệt các bạn dùng Matlab có thể sẽ thấy nó quen thuộc. Phần này đáng có một bài viết riêng, vì vậy trong bài này mình chỉ giới thiệu thôi.\nTrong Julia, số chiều của ma trận được phân biệt rất rõ ràng. Khi khai báo một vector, chúng ta dùng dấu , hoặc ; để ngăn cách các phần tử:\n1 2  A = [1, 2, 3] B = rand(3) # vector ngẫu nhiên   Đoạn code trên sẽ tạo ra A và B là vector cột. Đối với ma trận, chúng ta dùng dấu cách ngăn cách các phần tử cùng hàng, và dấu ; để ngăn cách giữa các dòng\n1 2 3  M = [1, 2, 3; 4, 5, 6; 7, 8, 9] # lỗi, không dùng được dấu \u0026#34;,\u0026#34; đâu M = [1 2 3; 4 5 6; 7 8 9] N = rand(3, 3) # ma trận ngẫu nhiên   Để lấy chỉ số của vector, ma trận, chúng ta dùng cú pháp ma_trận[chỉ_số]. Julia lưu ma trận theo cột, chúng ta có thể dùng chỉ số 1 chiều hoặc 2 chiều để lấy ra phần tử của ma trận.\n1 2 3 4 5 6 7  M[2, 3] # hàng 2 cột 3, trả ra 6 M[4] # phần tử thứ 4, nhưng duyệt theo từng hàng, trả ra 2 M[end] # phân tử cuối cùng M[1:2, end] # hàng 1 tới hàng 2, cột cuối cùng M[end, [1, 3]] # cột 1 và 3, hàng cuối cùng M[[1, 2], [2, 3]] # đoán xem? :) M[:, end] # cột cuối   Trong Julia, việc gán ma trận sẽ không tạo bản copy của ma trận đó, trừ khi bạn lấy một phần của ma trận:\n1 2 3 4 5 6  L = M L[1] = 2 # M cũng bị thay đổi L = M[[1, 2], :] L[1] = 3 # M không bị đổi L = copy(M) # copy lại M, tạo ma trận mới L[1] = 3 # M không bị đổi   Các phép toán với vector, ma trận được thực hiện rất tự nhiên (theo quy tắc toán học):\n1 2 3 4 5 6 7 8 9 10 11  A * B # báo lỗi, hai vector có chiều 1 × 3 không nhân với nhau được A * B\u0026#39; # nhưng nếu B chuyển vị thành vector hàng thì ok :) M * N # hai ma trận (3, 3) nhân với nhau M * A # nhân ma trận (3, 3) với vector (3, 1) A + B # cộng vector M + N # cộng ma trận A + B\u0026#39; # lỗi, cộng vector ma trận phải cùng chiều A .+ B\u0026#39; # nhưng cộng từng phần tử lại là chuyện khác :) A .* B\u0026#39; # nhân phần tử cũng vậy luôn M ^ 5 # ma trận vuông có thể lấy lũy thừa M .^ 5 # lũy thừa từng phần tử   Lưu ý rằng, đối với trường hợp số thực, chúng ta có thể dùng A' để chuyển vị. Với ma trận số phức hãy dùng transpose. Để biết chi tiết hãy xem thêm:\n transpose: https://en.wikipedia.org/wiki/Transpose adjoint (dấu nháy): https://en.wikipedia.org/wiki/Conjugate_transpose  (sorry vì màu link khó nhìn, mình sẽ gửi issue lên người bảo trì theme này)\n Kết luận Ok, phần giới thiệu tới đây mình nghĩ đủ rồi. Vậy các là các bạn đã biết cách khai báo biến, cộng trừ nhân chia và những trò hay ho mà trên trường giáo viên sẽ bắt chúng ta ngồi tính sấp mặt. Hẹn gặp các bạn trong bài viết sau.\nBonus: nếu đang học đại học, giờ bạn có thể dùng Julia như một cái máy tính cá nhân (nhưng vạn năng hơn một tí)\n1 2  # Giải hệ phương trình A⋅X = B trong một nốt nhạc A^-1 * B   ","description":"Biến số, hằng số, kiểu dữ liệu và một số thao tác đơn giản với chúng trong Julia","id":7,"section":"posts","tags":["julia"],"title":"Julia Dojo: biến số, kiểu dữ liệu, phép toán","uri":"https://ndgnuh.github.io/julia-dojo/bien-so-va-kieu-du-lieu-trong-julia/"},{"content":"Chào mừng các bạn quay trở lại với series Julia Dojo. Hôm nay chúng ta sẽ học cách viết một chương trình trong Julia và làm thế nào để chạy nó.\nDân gian ta có câu:\n Lời chào cao hơn mâm cỗ\n\u0026ndash; Dân Gian Ta (mình cũng không biết đây là thằng nào)\n Lời chào rất quan trọng, trong lĩnh vực lập trình điều này không phải ngoại lệ. Do đó, hôm nay chúng ta sẽ viết chương trình \u0026ldquo;chào thế giới\u0026rdquo;, dân-gian-ta còn gọi là \u0026ldquo;hello world\u0026rdquo;.\nChương trình đầu tiên của bạn Hello world là chương trình rất quen thuộc nếu bạn đã học lập trình trước đây. Nó sẽ cho bạn cái nhìn đầu tiên về cấu trúc ngữ pháp của một ngôn ngữ lập trình. Đầu tiên, hãy mở một trình sửa văn bản, tạo một file tên hello-world.jl.\nTrước đây, đuôi file .j được sử dụng cho ngôn ngữ Julia. Sau này, họ đổi thành .jl, cá nhân mình thấy thích cái đuôi file này hơn.\nKhi tạo file xong, hãy điền nội dung sau vào file:\n1  println(\u0026#34;hello world\u0026#34;)   Xong, bạn hãy mở một terminal tại vị trí bạn lưu file trên, sau đó chạy lệnh.\n1  julia hello-world.jl   Dòng chữ \u0026ldquo;hello world\u0026rdquo; sẽ được in ra màn hình. Vậy là bạn đã viết và chạy thành công chương trình hello world của mình với Julia.\nRất nhiều cách để nói \u0026ldquo;hello world\u0026rdquo; Chúng ta sẽ chỉnh sửa chương trình hello world một chút. Ở trên mình dùng hàm println để in ra chuỗi hello world. Giờ mình sẽ giới thiệu một vài cách khác:\n1 2 3 4 5 6  println(\u0026#34;hello world\u0026#34;) print(\u0026#34;hello world\u0026#34;); println() @show \u0026#34;hello world\u0026#34; @info \u0026#34;hello world\u0026#34; @warn \u0026#34;hello world\u0026#34; @error \u0026#34;hello world\u0026#34;   Chạy file trên, chúng ta sẽ thu được output:\nhello world hello world \u0026quot;hello world\u0026quot; = \u0026quot;hello world\u0026quot; [ Info: hello world ┌ Warning: hello world └ @ Main /tmp/hello-world.jl:6 ┌ Error: hello world └ @ Main /tmp/hello-world.jl:7  Dòng đầu là kết quả của println, hàm này sẽ in ra tham số của nó, sau đó in kí tự ngắt dòng. Dòng thứ hai là kết quả của print, hàm này giống println nhưng không in kí tự ngắt dòng, do đó mình phải thêm một hàm println() trống ở phía sau. Các bạn để ý thêm. Ở dòng số 2 file hello-world.jl, mình có dấu ;. Đấu này không cần thiết khi bạn viết mỗi lệnh trên một dòng. Tuy nhiên nếu bạn cần viết hai lệnh trên cùng dòng thì sẽ cần tới nó để ngắt giữa hai lệnh. Ở dòng 3, macro @show in ra một điều \u0026ldquo;hiển nhiên\u0026rdquo;: \u0026quot;hello world\u0026quot; = \u0026quot;hello world\u0026quot;. Thực ra, cái này dùng để show ra giá trị của một biến hay hằng số, ở đây chúng ta truyền cho nó một hằng số nên nó in ra củ chuối như vậy\u0026hellip; Macro là gì ư? Tạm thời bạn đừng quan tâm, hãy tạm hiểu nó có dấu @ và làm một cái gì đó cho bạn. Ở dòng 4, chúng ta có @info. Macro này có tính ghi chú, nó chỉ nhận đầu vào là chuỗi kí tự thôi. @info được dùng để đưa ra bản ghi chép (log) cho chương trình của bạn. Ở dòng 5, chúng ta có @warn. Thằng này giống thằng @info, nhưng nó nói với giọng \u0026ldquo;bố đang cảnh báo mày đấy\u0026rdquo;. Tuy hổ báo nhưng nó sẽ không đừng việc thực thi chương trình của bạn. @warn thường được dùng khi một người viết gói chương trình muốn deprecate (tạm dịch là cho lỗi thời, mình không biết dịch như nào cho hay) một tính năng nào đó và cảnh báo người dùng không nên dùng nó. Cuối cùng, chúng ta có @error. Thằng này nó sẽ cảnh báo và cho chương trình của bạn bay màu luôn. @error được dùng rất nhiều. Bạn sẽ gặp nó khi gọi một hàm không tồn tại chẳng hạn.  Chế độ tương tác Bạn có thấy viết hẳn một file, chỉ dành cho một dòng code mà in ra hello world có hơi thừa? Nếu vậy hãy mở terminal ra, chạy câu lệnh sau:\n1  julia   Chế độ tương tác Julia (hay Julia REPL) sẽ chào đón bạn với một cái logo ascii (không có mèo đâu, đấy là hình nền của mình :P)\nchế độ tương tác Julia   Bạn có thể chạy \u0026ldquo;hello world\u0026rdquo; bằng cách nhập câu lệnh trên vào và nhấn Enter:\nhello world trong một dòng   Thậm chí bạn có thể gõ ?println và xem thông tin về những thứ mình vừa viết ở trên.\nchế độ help   Goodbye, world Ok, vậy là bạn đã biết những cách đơn giản nhất viết và chạy chương trình Julia (và cũng là chương trình đơn giản nhất luôn). Chúng ta sẽ lần lượt tìm hiểu những phương thức khác trong các bài tiếp theo. Riêng với chế độ tương tác, mình có thể làm một bài nữa, nói về những tính năng của nó. Hẹn gặp lại các bạn trong những bài viết sau :)\n","description":"Viết chương trình đầu tiên của bạn trong Julia","id":8,"section":"posts","tags":["julia"],"title":"Julia Dojo: Hello world","uri":"https://ndgnuh.github.io/julia-dojo/hello-world/"},{"content":"Chào mừng các bạn đến với bài viết đầu tiên của series \u0026ldquo;Julia Dojo\u0026rdquo;. Trong bài viết này mình sẽ hướng dẫn các bạn cách cài đặt Julia.\nĐể cài Julia, chúng ta có 2 cách:\n Cài đặt từ bản phân phối chính thức: cách này được khuyến cáo vì nó sẽ không gây lỗi lặt vặt, tuy nhiên quá trình cài đặt sẽ hơi dài một chút. Cài đặt từ bản phân phối của cộng đồng: cách này rất đơn giản, đặc biệt với những bạn dùng Linux. Tuy nhiên cách này có thể gây lỗi vặt (thực ra mình mới chỉ thấy một lỗi trên ArchLinux, chưa thấy có người gửi issue nào khác)  Mình sẽ hướng dẫn các bạn cả hai cách. Việc cài đặt có thể sử dụng tới terminal (dòng lệnh, hiểu nôm na là vậy), vậy có kiến thức cơ bản về việc sử dụng terminal và shell có thể sẽ hữu dụng và giúp quá trình cài đặt dễ dàng hơn. Nếu bạn không biết những thứ này cũng không nên lo quá.\nCài đặt bản phân phối từ cộng đồng Vì cách này ngắn và đơn giản hơn, mình sẽ hướng dẫn trước. Để thực hiện cách cài đặt này, bạn cần có package manager. Cái này trên *Nix thì có chắc chắn có sẵn, còn trên MacOS và Windows có lẽ bạn sẽ phải cài thêm. Khi xong xuôi, bạn chỉ cần mở terminal và ehạy lệnh tương ứng với hệ điều hành của mình:\n  Windows - Chocolately  Cài đặt:\n1  choco install julia --confirm   Cập nhật:\n1  choco upgrade julia --confirm        MacOs - HomeBrew  HomeBrew trên Mac 1  brew cask install julia        Fedora/Red hat/Cent OS và các distro tương tự  Với Fedora bản 19 hoặc hơn:\n1 2  sudo dnf copr enable nalimilan/julia sudo yum install julia   Nếu bạn dùng Cent OS bản 7 hoặc hơn:\n1 2  sudo yum-config-manager –add-repo https://copr.fedorainfracloud.org/coprs/nalimilan/julia/repo/epel-7/nalimilan-julia-epel-7.repo sudo yum install julia   Nếu dnf và yum-config-manager không khả dụng trên hệ thống của bạn, hãy tải file .repo tương ứng ở link phía trên và copy vào /etc/yum.repos, sau đó chạy câu lệnh thứ 2.\nĐể cập nhật Julia:\n1  yum upgrade julia        Debian/Ubuntu và các distro tương tự  Cài đặt:\n1 2  sudo apt update sudo apt install julia   Cập nhật:\n1 2  sudo apt update sudo apt upgrade        Archlinux và các distro tương tự  Cài đặt:\n1 2 3 4  sudo pacman -S julia # bản không chính thức # những bản này cần `yay` để cài tự động sudo yay -S julia-bin # tương ứng với bản chính thức từ trang chủ yay -S julia-git # tương ứng vởi bản build từ git   Cập nhật:\n1 2 3  sudo pacman -Syu # hoặc yay -Syu      Cài đặt từ bản phân phối chính thức Việc cài đặt sẽ chia thành ba bước. Đầu tiên, bạn cần truy cập trang tải về của Julia để lấy bản phân phối chính thức. Mình sẽ hướng dẫn chi tiết quá trình cài đặt. Bước tiếp theo là giải nế và cài đặt. Cuối cùng, chúng ta sẽ cài đặt biến môi trường để có thể truy cập vào Julia mọi lúc mọi nơi.\nTải Julia Trang download Julia   Julia cung cấp một số lựa chọn:\n Current stable release: phiên bản ổn định. Bản Release Candidate: phiên bản ứng cứ viên phát hành, có thể hiểu là \u0026ldquo;gần\u0026rdquo; ổn định.. Long-term support: Phiên bản hỗ trợ lâu dài, bạn có thể hiểu đây là phiên bạn \u0026ldquo;cực kì ổn định\u0026rdquo;. Bản Nightly: Bản thử nghiệm, dành cho những thanh niên thích thử nghiệm.  Sau khi đã quyết định sẽ sử dụng phiên bản nào, hãy tải về bản cài đặt phù hợp với hệ điều hành của bạn. Ví dụ nếu mình dùng Windows 64 bit hãy tải file Windows (.exe) ở cột 64-bit (trong ảnh).\nGiải nén và cài đặt   Windows  Sau khi tải Julia như trên, chúng ta sẽ có một file .exe. Mở file exe này lên. Việc cài đặt tương đối đơn giản, chỉ cần next, next và next.\nLưu ý rằng, quá trình cài đặt có một bước chọn đường dẫn giải nén. Hãy lưu lại đường dẫn này để sử dụng ở bước sau.\n    MacOS  Sau khi tải Julia như trên, chúng ta sẽ có một file .dmg. Mở file .dmg ấy, bên trong có file Julia-\u0026lt;phiên-bản\u0026gt;.app. Kéo thả file này vào thư mục Application trên desktop của bạn và bạn đã hoàn thành bước này.     Linux, BSD, *Nix  Sau khi tải Julia như trên, chúng ta sẽ có một file .tar.gz. Hãy copy file này vào vị trí cài đặt tương ứng, sau đó giải nén file này ra bằng lệnh:\n1  tar -xvf đường/dẫn/tới/\u0026lt;file-của-bạn\u0026gt;.tar.gz   Một vài file, thư mục mới sẽ xuất hiện, vậy là bạn đã hoàn thành bước này.\n  Thêm đường dẫn đến Julia vào biến môi trường Để có thể gọi Julia từ mọi nơi, bạn cần thêm đường dẫn tới file thực thi Julia vào biến $PATH. Tuy cả ba nhóm hệ điều hành trên đều dùng biến môi trường này, cách cài đặt sẽ khác nhau một chút.\n  Windows 10   Nhấn tổ hợp phím Windows + R, gõ sysdm.cpl và nhấn Enter Một cửa sổ hiện lên, hãy chọn thẻ Advanced, chọn Environment Variables. Thêm một cửa sổ nữa hiện lên, trong phần System variables, chọn Path và click vào nút Edit Một cửa sổ hiện ra, nhấn New. Một cửa sổ mới hiện ra với một hộp văn bản Lấy đường dẫn cài đặt ở bước 2 ra, thêm \\bin vào đuôi và copy vô cái hộp văn bản đó. Ví dụ mình cài Julia vào E:\\julia, mình sẽ ghi E:\\julia\\bin. Ấn Ok, tắt hết các hộp thoại, giờ bạn đã cài xong Julia.      Windows khác   Nhấn tổ hợp phím Windows + R, gõ sysdm.cpl và nhấn Enter Một cửa sổ hiện lên, hãy chọn thẻ Advanced, chọn Environment Variables. Thêm một cửa sổ nữa hiện lên, trong phần System variables, chọn Path và click vào nút Edit Sau khi nhấn Edit, sẽ có một cửa sổ với 2 hộp văn bản xuất hiện. Click vào hộp văn bản thứ 2 (Variable value:) và di chuyển đến cuối dòng, nếu cuối dòng không có dấu ; hãy thêm dấu ; vào. Lấy đường dẫn cài đặt ở bước 2 ra, thêm \\bin vào đuôi và copy thêm vào cuối của hộp văn bản thứ 2. Ví dụ mình cài Julia vào E:\\julia, mình sẽ ghi thêm E:\\julia\\bin vào cuối. Nhắc lại rất kĩ là ghi thêm nhé, ông nào paste đè lên cái cũ xong hỏng máy tôi không chịu trách nhiệm đâu. Ấn Ok, tắt hết các hộp thoại, giờ bạn đã cài xong Julia.      MacOS   Chạy open -a TextEdit ~/.bash_profile trên Terminal. Nếu bạn dùng zsh thì thay .bash_profile bằng .zshrc (nếu bạn không biết bạn đang dùng cái gì thì đừng để ý đoạn zsh này). Lệnh trên sẽ mở file ~/.bash_profile để bạn chỉnh sửa. Thêm dòng export PATH=\u0026quot;/Applications/Julia-.app/Contents/Resources/julia/bin:${PATH}\u0026quot; vào cuối và save lại.      Linux, BSD, *Nix  Bạn có 3 lựa chọn như dưới đây, sau khi thực hiện một trong ba bạn sẽ có thể sử dụng Julia.\n Thêm thư mục Julia vào biến $PATH bằng cách thêm dòng lệnh mình ghi ở dưới vào trong file ~/.bashrc và ~/.bash_profile. Thay hai file trên với ~/.zshrc nếu bạn dùng zsh. Thay những file trên với /etc/profile, /etc/bash.bashrc hoặc /etc/zsh nếu bạn muốn cài đặt trên toàn hệ thống.  1  export PATH=\u0026#34;$PATH:/đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin\u0026#34;    Chạy lệnh echo $PATH xem biến $PATH của bạn có những thư mục nào, ví dụ mình sẽ chọn /usr/bin. Sau đó, hãy tạo liên kết tới Julia trong thư mục đó bằng lệnh sudo ln -s /đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin/julia /usr/bin/ (mình dùng sudo vì cần quyền ghi vào /usr/bin, nếu người dùng của bạn ghi được vào thư mục trên $PATH thì không cần sudo) Cách cục súc: bạn sẽ chạy /đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin/julia mỗi lần bạn dùng đến nó.    Lưu ý thêm cho những bạn dùng Windows   Nếu bạn dùng Windows 7   bản update này sẽ giúp trình quản lý gói của Julia hoạt động. Xuống phần Method 2 và click vào link Microsoft Update Catalog. Windows Management Framework 3.0 hoặc hơn để cài Powershell. Vào trang web trên, kéo xuống dưới cái bảng và click vào phiên bản bạn muốn download.    Nhìn chung, nếu bạn dùng Windows, mình khuyên các bạn nên tìm một terminal khác ngoài cmd và cái đi kèm với Powershell. Một số gợi ý cho các bạn:\n Terminal của Visual Studio Code Git bash  Tổng kết Các bạn có thể cài đặt Julia theo cách mình muốn. Bản cài chính thức cài đặt sẽ dài dòng hơn một chút nhưng đảm bảo hơn, bản cài do cộng đồng phân phối sẽ tiện lợi hơn với một tỉ lệ rất rất nhỏ xảy ra bug. Để kiểm tra việc cài đặt Julia có thành công hay không, hãy mở Terminal và chạy lệnh julia.\nNếu lệnh chạy thành công, chúng ta sẽ thấy màn hình Julia chào đón mình   ","description":"Hướng dẫn tải và cài đặt Julia trên máy tính của bạn","id":9,"section":"posts","tags":["julia"],"title":"Julia Dojo: cài đặt Julia","uri":"https://ndgnuh.github.io/julia-dojo/cai-dat-julia/"},{"content":"Julia là gì? Tại sao lại học nó? Julia là một ngôn ngữ lập trình bậc cao dễ sử dụng, nhanh và mạnh mẽ. Một số đặc trưng của Julia cũng như lí do bạn sẽ muốn dùng nó (hoặc không):\n Julia là phần mềm tự do \u0026amp; mã nguồn mở (giấy phép MIT) Kiểu dữ liệu người dùng định nghĩa nhanh và gọn giống như các kiểu built-in Không cần chủ động vector hóa code vì hiệu năng, code chưa vector hóa cũng nhanh Green threading Hệ thống kiểu dữ liệu tự nhiên, mạnh mẽ Chuyển đổi và thăng cập một cách \u0026ldquo;thanh nhã\u0026rdquo; giữa các kiểu dữ liệu Hỗ trợ rất tốt Unicode, không giới hạn ở UTF-8. Gọi trực tiếp code C, không cần wrapper hay API Có thể thực hiện tốt các khả năng của shell hệ thống, quản lí các tiến trình khác Macro, metaprogramming Julia miễn phí và mã nguồn mở (giấy phép MIT) Multiple dispatch (cái này có thể khiến bạn cảm giác lạ lạ, nhưng nó đỉnh lắm) Julia hứa hẹn sẽ giải quyết vấn đề hai ngôn ngữ  Khoan, nhiều \u0026ldquo;điểm tốt\u0026rdquo; quá, nghe vô lý. Thằng Python bậc cao nhưng nó chậm như rùa, mọi thư viện đều phải binding và viết với C. Thằng C thì nhanh, nhưng mà để viết được nó thì không phải ông nào cũng làm được. Thằng Matlab thì nhanh và dễ viết thật, nhưng bạn ơi, tiền đâu mà dùng Matlab, ngồi crack thôi chứ còn gì. Hơn nữa, Matlab nếu bạn dùng cho mục đích cá nhân thì crack được, chứ một tổ chức hay cơ quan thì họ sẽ bảo rằng:\n Ở đây chúng tôi không làm vậy\n\u0026ndash; Họ không dùng Matlab ở Wakanda\n Ok, mình vẫn chưa giải thích tại sao có nhiều \u0026ldquo;điểm tốt\u0026rdquo; như vậy. Julia đạt được những điều như trên vì 2 lí do:\n Julia dùng Just Intime Compiler (JIT) Việc biên dịch của Julia cực kì phức tạp, khiến cho mã Julia khi dịch xong có tốc độ so sánh được với C hoặc Fortran  Micro benchmark theo thời gian chạy một số ngôn ngữ, thời gian chạy của C được lấy làm mốc. Các ngôn ngữ khác được so sánh tương đối.   Đương nhiên, Julia cũng có khiếm khuyết, không có cái gì hoàn hảo cả. Và cộng đồng cũng rất cố gắng để cải thiện, xử lý chúng.\n Cộng đồng Julia nhỏ một cách tương đối so với những \u0026ldquo;ông lớn\u0026rdquo; như Python, đặc biệt là cộng đồng người Việt. Mình cho rằng đây là vấn đề thời gian, và vấn đề này cũng là lí do mình ở đây, viết cái đống này cho các bạn :). Mảng trong Julia đánh chỉ số từ 1. Có thể bạn đang nghĩ rằng sẽ dừng đọc và drop cái ngôn ngữ của nợ này ngay tại đây, hãy khoan đã. Theo mình thấy, vấn đề chỉ số này không ảnh hưởng nhiều lắm. Việc đánh chỉ số từ 0 được ông Dijikstra đưa ra và áp dụng trong kha khá ngôn ngữ lập trình, nhưng vẫn có những người dám phản dmg ông và đi theo trường phái khác. Cá nhân mình không có thành kiến gì với cả hai trường phái đâu, mình chỉ muốn nói cả hai đều có thể dùng được. Lí do duy nhất mình đưa cái này vào khuyết điểm vì có thể nó sẽ \u0026ldquo;dọa\u0026rdquo; những người mới.   Tôi không biết bao nhiêu người trong số các ông đã đích thân gặp Dijikstra, nhưng các ông chắc đều biết rằng - sự kiêu ngạo trong tính toán khoa học được đo bằng nano-Dijikstra.\n\u0026ndash; Alan Kay (mình không biết ông này nhưng mà câu nói của ổng làm mình thấy khoái)\n Lần đầu chạy code sẽ lâu hơn một chút. Ví dụ khi mình tạo random 100000 số kiểu double, lần đầu chạy rand(Float64, 100000) sẽ mất khoảng 0.06, những lần tiêp theo thời gian sẽ giảm đi còn 0.002 (nhanh gấp khoảng 30 lần). Có lẽ đây là vấn đề lớn nhất trong Julia. Nếu bạn hiểu JIT là cái gì, bạn sẽ thấy đặc điểm này gần như không thể tránh được. Tuy nhiên, với những người định \u0026ldquo;dùng thử\u0026rdquo; Julia, họ sẽ trải nghiệm thời gian compile và tưởng nó là runtime, sau đó sẽ nghĩ rằng \u0026ldquo;cái này không nhanh như quảng cáo\u0026rdquo;. Điều này ảnh hưởng rất nhiều tới khuyết điểm số 1. Hiện tại, cộng đồng Julia đang rất ưu tiên giải quyết vấn đề này, họ đã tìm cách giảm thời gian compile đáng kể, đồng thời có cách để compile hoàn toàn mã nguồn Julia dưới dạng thư viện liên kết động. Scala là cái tên được ghép từ \u0026ldquo;scalable\u0026rdquo; và \u0026ldquo;language\u0026rdquo;. Swift mang nghĩa chuyển động trơn tru và tốc độ cao. Ruby là một viên đá quý. C++ là C tăng lên 1 level. C là kế tiếp của B. Matlab là viết tắt của Matrix Laboratory, thậm chí trong một ngôn ngữ nào đó, nó có nghĩa là sự thông thái\u0026hellip; Vậy Julia cái tên Julia thì sao, nó có ý nghĩa gì?   Đây là câu hỏi ưa thích của mọi người. Thực ra chả có lí do gì đâu, nghe cái tên nó hay hay.\n\u0026ndash; Stefan Karpinski =))\n Huyên thuyên về Julia đủ rồi. Rất tiếc nếu mình không thuyết phục được bạn. Tuy nhiên, nếu bạn quyết định thử Julia và cho nó một cơ hội, hãy chuyển qua phần tiếp theo và bước vào Julia Dojo.\nJulia Dojo Vậy là bạn quyết định cho Julia một cơ hội, mình sẽ cảm ơn các bạn bằng một series hướng dẫn \u0026amp; thảo luận, mang tên \u0026ldquo;Julia Dojo\u0026rdquo;. Series này sẽ tổng hợp từ rất nhiều nguồn kiến thức, nhưng chủ yếu mình sẽ lấy từ 3 nguồn:\n Tài liệu chính thức Julia Con (một hội thảo được tổ chức hàng năm) Hiểu biết của mình  Với tài liệu chính thức và Julia Con, bạn có thể xem một cách miễn phí trên mạng nếu nếu không ngại tiếng Anh; còn cái nguồn thứ ba, bạn có thể xem nếu bạn quen mình ngoài đời thực và có khả năng ngoại cảm.\nÝ tưởng chính của Julia Dojo là: chúng ta sẽ train từng level một. Với mỗi level chúng ta sẽ đi sâu vào trong hệ thống của Julia hơn và thấy các thứ liên kết với nhau như thế nào. Trang này sẽ là nơi mình update các level của Dojo cùng với nội dung trong đó mỗi khi có bài mới.\nCó những bài viết mình đánh đấu là \u0026ldquo;tùy chọn\u0026rdquo; hoặc \u0026ldquo;nên xem\u0026rdquo;, bạn không nhất thiết phải đọc vì nó không phải một \u0026ldquo;cơ bản\u0026rdquo; của Julia. Mình có để intro ở đầu mỗi bài viết, nếu bạn thấy không hứng thú hoặc phần đó bạn đã biết rồi, bạn có thể skip.\nLayout phía dưới có những phần dự định, có thể khi mình viết bài thực sự mình sẽ thêm bớt hoặc chuyển chỗ một vài thứ trong đó.\n Level 1: nhập môn Những thứ cơ bản nhất\n Tải và cài đặt Julia Hello, world Làm việc với trình quản lí gói Sử dụng Julia với Project Jupyter Biến số Cấu trúc điều khiển Hàm  Level 2: vài đường cơ bản (dự định) Giống Level 1, nhưng kĩ hơn một tí, và giới thiệu các gói mình nghĩ là hay.\n Làm việc với file Từ điển, tập hợp Struct Chuỗi kí tự, biểu thức chính quy và biểu tượng Đại số tuyến tính Mảng, ma trận Thống kê Vẽ đồ thị DataFrame Gọi các ngôn ngữ khác Đa luồng, đa tiến trình Xử lý ngoại lệ Broadcast  Level 3: thiên biến vạn hóa (dự định) Đa hình và những thứ liên quan tới nó\n Nói thêm về hệ thống kiểu dữ liệu Các loại giao diện Multiple dispatch  Level 5: sáng tạo chiêu thức (dự định) Sẽ có một ngày bạn phải tự viết chương trình của riêng mình\n Tạo một project Unit testing Viết tài liệu  Extra: làm chủ vũ khí (dự định) Công cụ lập trình mà bạn có thể sẽ thích.\n [nên đọc] Jupyter notebook [nên đọc] VSCode [tùy chọn] Atom: Juno / Julia pro [tùy chọn] Vim Emacs (chưa chắc) Một số kĩ thuật để code nhanh hơn Tính toán song song Meta programming  Về các module, gói Vì có rất nhiều module của Julia mang tính chuyên ngành cao, mà trình độ của mình có giới hạn nên mình sẽ không cover hết được(mấy cái mô hình hóa sinh thì chịu rồi, mình dốt hóa). Do đó, nếu các bạn muốn hướng dẫn, giới thiệu một gói nào đó. Các bạn có thể:\n Gửi một đường dẫn cho mình tới blog của các bạn, mình sẽ gắn nó vào đây Gửi cho mình bài viết của các bạn kèm với một số thông về bạn, mình sẽ ghi credit đầy đủ cho các bạn, trừ khi bạn không muốn (nhưng mình vẫn sẽ ghi rõ bài viết do độc giả đóng góp) Dịch trang tài liệu chính thức của gói đó và đóng góp cho họ Không làm gì cả =))  Tạm kết Fun fact: \u0026ldquo;Julia\u0026rdquo; nghe rất giống tên của một phụ nữ trong nhiều nền văn hóa, do đó, dù quy chuẩn của cộng đồng cho rằng Julia không dựa trên tên của ai và ngôn ngữ này không được nhân hóa dưới bất kì hình thức nào, một cơ số người khi nói về ngôn ngữ này vẫn vô thức dùng đại từ \u0026ldquo;cô ấy\u0026rdquo;, trong đó có cả mình :))  Ok, mình nghĩ đến đây là đủ cho bài giới thiệu. Chắc các bạn cũng đoán ra được rằng, mình đang muốn mở rộng cộng đồng người dùng Julia, cụ thể hơn là ở Việt Nam. Một lần nữa, nếu bạn quyết định cho Julia một cơ hội, mình xin cảm ơn. Mình sẽ cố viết post chất lượng và giải đáp thắc mắc của các bạn. Nếu thấy có thiếu sót, đừng ngại gửi lại phản hồi cho mình.\n","description":"","id":10,"section":"posts","tags":["julia"],"title":"Julia Dojo: giới thiệu","uri":"https://ndgnuh.github.io/julia-dojo/"},{"content":"whoami? Xin chào mọi người, mình là Hùng, một open source enthusiast, và là một sinh viên.\nWhat am I doing here? Blog này dự kiến sẽ dùng để chia sẻ kiến thức và bàn chuyện trên trời dưới đất. Cụ thể hơn, mình sẽ chia sẻ hiểu biết của mình (chủ yếu) về Linux, lập trình và có thể là một ít toán nữa.\nHiện tại mình blog chưa được implement tính năng bình luận, tạm thời các bạn đọc nếu có thắc mắc, ý kiến đóng góp hay ném gạch chịu khó gửi một email hay để lại một issue trên Github cho mình.\n Email: ndgnuh@protonmail.com Repo github cho trang này: https://github.com/ndgnuh/ndgnuh.github.io  Blog viết bởi một sinh viên, do tác giả còn rất nhiều thứ phải học nên khả năng cao sẽ gặp sai sót. Nếu bạn đọc phát hiện ra lỗi gì, về kĩ thuật, nội dung, câu cú hay lỗi chính tả ₍•⌣•₎ của trang cứ thoải mái đóng góp ý kiến nhé.  ","description":"","id":11,"section":"","tags":null,"title":"Giới thiệu","uri":"https://ndgnuh.github.io/about/"}]