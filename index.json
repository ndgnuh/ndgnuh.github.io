[{"content":"Chào mừng mọi người đến với Julia Dojo.\nLà con người, không phải ai trong số chúng ta cũng có khả năng cân tất cả các việc cùng một lúc, đặc biệt với đống kiến thức tích lũy qua cả trăm năm của nhân loại. Hiển nhiên rằng, một người không thể lập trình mọi thứ từ con số không. Vì vậy, chúng ta có cộng đồng người dùng, có các gói bổ trợ cho một ngôn ngữ lập trình. Trong bài viết ngày hôm nay, chúng ta sẽ tìm hiểu về cách quản lí và sử dụng các gói như vậy trong Julia.\nQuản lí một gói Julia cung cấp tính năng quản lí gói một cách mặc định trong Julia REPL. Để kích hoạt trình quản lí gói, chúng ta nhấn phím ] ở trên một dòng trống.\n Giao diện quản lí gói, đầu dòng chuyển thành `pkg\u0026gt;`   Mọi đoạn code sau đây được sử dụng trong chế độ quản lí gói của Julia  Để cài gói trong Julia, chúng ta sử dụng cú pháp add gói. Chúng ta có thể cài một hoặc nhiều gói, hoặc dùng link github để cài.\nadd DataFrame IJulia add https://github.com/tlienart/Franklin.jl Lưu ý rằng link github sẽ tải bản mới nhất hiện có, bao gồm cả các tính năng thử nghiệm. Sau khi cài đặt một thời gian, chúng ta sẽ cần update gói\nupdate IJulia update Lệnh update sẽ update toàn bộ gói trong khi update TênGói chỉ update một gói được định sẵn thôi.\nKiểm tra những gói được cài đặt:\nst st TênGói Nếu có gói không dùng, chúng ta xóa bỏ nó bằng cách\nrm TênGóiKhôngDùng Khi cài hoặc update gói, những gói phụ thược sẽ được cài đặt theo, khi xóa gói chúng sẽ được tự xóa đi, nên các bạn không cần lo về gói phụ thuộc.\nSử dụng một gói Cách sử dụng một gói trong Julia rất đơn giản. Một gói thông thường sẽ có nhiều module, trong đó có một module chính mang tên của gói đó (ví dụ như gói IJulia.jl sẽ có module IJulia). Chúng ta có hai từ khóa import và using (sử dụng trong chế độ bình thường)\n1 2  import TênModule using TênModule   Sử dụng import sẽ chỉ nhập tên của gói vào phạm vi toàn cục, trong khi using sẽ nhập toàn bộ những hằng số, biến số hoặc hàm mà gói đó xuất ra.\n1 2  import Module1 using Module2   Giả sử Module1 có hàm_a, Module2 có hàm_b. Trong ví dụ trên, nếu chúng ta muốn gọi hai hàm:\n1 2  Module2.hàm_a() hàm_b() # hàm_b được cho ra phạm vi toàn cục   Ngoài ra chúng ta có thể chỉ using một số thành phần của gói:\n1 2  using LinearAlgebra: svd # chỉ hàm svd sẽ được nhập ?svd # xem hàm svd   Môi trường của gói Trình quản lí gói của Julia quản lí theo môi trường, nhìn lại ảnh phía trên, chúng ta sẽ thấy có phần (v1.3) ở trước chữ pkg\u0026gt;:\n môi trường mặc định, Julia 1.3   Phần v1.3 cho biết môi trường đang hiện hoạt của Julia. Hãy hiểu một cách đơn giản:\n Julia có nhiều môi trường khác nhau Trong môi trường sẽ có những gói được cài khác nhau Môi trường thực chất chỉ là một thư mục, thư mục này chứa một file, file này là danh mục các gói đã được cài Nếu môi trường không có gói nào thì sẽ không dùng được gói đó, dù nó đã được cài (using gây lỗi) Khi làm việc sẽ có một môi trường được kích hoạt (môi trường hiện hành) Bạn có thể chuyển giữa các môi trường  Khi cài một gói mà đã được cài ở môi trường khác, Julia chỉ thêm gói đó vào trong danh mục gói của môi trường hiện hành, chứ không tải hay cài lại. Điều này giúp tránh sự trùng lặp khi cài gói.\nTương tự, việc xóa gói đôi lúc chỉ xóa gói đó khỏi chỉ mục chứ không thực sự xóa nó khỏi ổ đĩa.\nNếu bạn muốn xóa những gói không cài trong môi trường nào, dùng lệnh gc.\n Môi trường mặc định của Julia là môi trường có chứa tên phiên bản, đây sẽ là môi trường bạn sử dụng nhiều nhất cho việc nghiên cứu hay nháp. Nếu bạn đổi sang môi trường khác, bạn sẽ thấy phần trong ngoặc cũng thay đổi.\nĐể chuyển vào một môi trường, ta dùng lệnh activate (trong chế độ quán lí gói).\nactivate /đường/dẫn/tới/thư/mục Để chuyển về môi trường mặc định, chúng ta sử dụng lệnh activate mà không truyền tham số vào.\nMột số gói/module trong Julia Mình chỉ giới thiệu một số thôi, chỗ này không phải tất cả nhé!\nMột số module đi kèm trong Julia, không cần cài đặt (standard library):\n   Tên Chức năng     Dates Làm việc với thời gian   Distributed Hỗ trợ tính toán song song   LibGit2 Binding của một thư viện C để làm việc với Git   Libdl Làm việc với thư viện liên kết động   LinearAlgebra Đại số tuyến tính, svd, lu, trị riêng \u0026hellip;   SparseArray Ma trận thưa thớt   SharedArrays Dữ liệu được lưu trên vùng nhớ chung   Sockets Làm việc với Unix sockets   Statistics Công cụ thống kê   Test Unit testing   Profile Profile code    Một số gói do cộng đồng viết:\n   Tên gói Chức năng     IJulia Dùng Julia với Jupyter notebook   DataFrames Bảng dữ liệu   Distributions Các loại phân phối xác suất   DataStructures Các loại cấu trúc dữ liệu   DifferentialEquations Giải các pt vi phân   JuMP Công cụ tối ưu   Plots Vẽ đồ thị (nhiều backend)   HTTP, Genie, Mux Công cụ làm Web App, Web API   CUDAnative Công cụ cho CUDA   PyCall Gọi python từ Julia   TensorFlow Wrapper cho TensorFlow   ScikitLearn Cài đặt lại hoàn toàn ScikitLearn trong Julia    Tạm kết Trong bài viết này, chúng ta đã tìm hiểu về:\n Cách cài đặt, update, xem và xóa gói Julia Cách sử dụng các module trong Julia Làm việc với môi trường của gói Một số module và gói trong Julia  Trong bài viết sau, chúng ta sẽ học cách sử dụng Julia với Jupyter notebook hoặc Jupyter lab. Hẹn gặp lại các bạn.\nTham khảo thêm:\n Quản lí gói: https://docs.julialang.org/en/v1.0/stdlib/Pkg/ Thư viện tiêu chuẩn: https://docs.julialang.org/en/v1/stdlib/Base64/ Tìm kiếm gói Julia: https://pkg.julialang.org/docs/  ","description":"Hướng dẫn cài đặt và sử dụng các gói trong Julia","id":0,"section":"posts","tags":["julia"],"title":"Julia Dojo: quản lí gói trong Julia","uri":"https://ndgnuh.github.io/julia-dojo/cai-dat-va-su-dung-goi-julia/"},{"content":"Chào mừng mọi người quay trở lại Julia Dojo. Trong bài trước chúng ta đã học về trình quản lí gói và cách để sử dụng các gói. Hôm nay, chúng ta sẽ thực hành cài đặt và sử dụng gói đầu tiên, cũng chính là gói mà hỗ trợ chúng ta làm việc với Jupyter Notebook.\nCó thể bạn chưa biết, tên của project Jupyter thực ra được tạo thành từ ba ngôn ngữ: Julia, Python và R. Dù không phải viết tắt trực tiếp của ba ngôn ngữ nhưng cái tên này đã cho thấy rất rõ ràng định hướng của project.  Cấu hình \u0026amp; cài đặt Trước khi cấu hình Julia để làm việc với Jupyter, chúng ta cần có Python hoặc Jupyter notebook/lab cài đặt sẵn trong máy (Python là phụ thuộc của Jupyter). Sau đó chúng ta tiến hành cài gói Julia. Mình sẽ không hướng dẫn cài đặt Python ở đây, rất nhiều hướng dẫn khác đã tồn tại trên mạng.\nSau khi thỏa mãn mọi điều kiện, bạn mở REPL và cài đặt gói IJulia.\n1  ]add IJulia   Nếu các bạn không quen với Jupyter (thường được biết đến với Jupyter Notebook), mình sẽ giải thích một cách ngắn gọn: Jupyter là một giao diện hơi giống REPL trên nền web dành cho các ngôn ngữ lập trình. Jupyter khác REPL ở chỗ, nó lưu lại lệnh và ghi chú của bạn. Để Jupyter hoạt động được, chúng ta cần có một thứ gọi là \u0026ldquo;nhân\u0026rdquo; của ngôn ngữ lập trình. Quy trình làm việc như sau:\n Jupyter nhận input của bạn Jupyter sẽ gửi code đến nhân Nhiệm vụ của nhân là chạy đoạn code đó, sau đó gửi output tới Jupyter Jupyter hiện output cho bạn  Gói IJulia chính là \u0026ldquo;nhân\u0026rdquo; dành cho ngôn ngữ Julia. Sau khi cài gói xong, chúng ta cần chạy lần đầu để Julia cài đặt nhân và cấu hình Jupyter để sử dụng nó. Bạn không cần lo về việc cài Jupyter, khi chạy IJulia lần đầu, Julia sẽ cài đặt Jupyter cho chúng ta nếu cần.\n1 2 3  using IJulia notebook() # để dùng Jupyter Notebook jupyterlab() # để dùng Jupyter Lab   Sử dụng Chúng ta có thể sử dụng Julia với Jupyter theo cách ở trên, tuy nhiên, Jupyter sẽ dùng thư mục mà chúng ta dùng đang mở (thư mục mà chúng ta dùng để chạy Julia). Sau khi cấu hình với lần chạy đầu tiên của IJulia, chúng ta sẽ không cần mở REPL lên để dùng notebook nữa. Thay vào đó, chúng ta hãy mở một terminal tại thư mục bạn muốn. Ví dụ, mình dùng notebook:\n1 2 3 4  cd notebook jupyter notebook # hoặc bạn muốn dùng jupyter lab jupyter lab   Mình chỉ hướng dẫn notebook thôi, lab bạn tự tìm hiểu nhé. Sau khi chạy lệnh trên, một cửa sổ trình duyệt sẽ hiện lên:\n Giao diện Jupyter Notebook  \nĐể tạo một notebook, hãy ấn vào nút New ở góc phải màn hình. Sau đó một danh sách các nhân đã cài sẽ hiện lên, ở đây mình có hơi nhiều :)\n Menu tạo notebook mới   Click vào Julia x.y.z để tạo một notebook sử dụng Julia, một cửa sổ khác sẽ hiện lên.\n Giao diện của một notebook   Trong cửa sổ này, chúng ta có thể thêm, sửa, xóa, chạy các ô code hoặc nhấn phím m để chuyển qua viết ghi chú. Phím y dùng để chuyển lại một ô thành code và tổ hợp Ctrl/Shift + Enter dùng để chạy ô code đó.\n Chạy code Julia, viết Markdown và LaTeX   Tạm kết Qua bài viết lần này, chúng ta đã biết cách cấu hình Julia để sử dụng với Jupyter Notebook. Những phần còn lại của giao diện notebook mời các bạn tự khám phá thêm, mình xin kết thúc bài viết này ở đây, tạm biệt và hẹn gặp lại các bạn trong những bài viết sau.\nTham khảo:\n https://github.com/JuliaLang/IJulia.jl https://jupyter.org/install  ","description":"Hướng dẫn cấu hình Julia để sử dụng với Jupyter Notebook và Jupyter Lab","id":1,"section":"posts","tags":["julia"],"title":"Julia Dojo: Julia + Project Jupyter","uri":"https://ndgnuh.github.io/julia-dojo/dung-julia-voi-jupyter-notebook-va-jupyter-lab/"},{"content":"Chào mừng các mọi người quay trở lại với series Julia Dojo. Như mình đã giới thiệu, Julia là một ngôn ngữ lập trình hàm, và ngôn ngữ lập trình hàm thì\u0026hellip; không thể thiếu hàm. Thậm chí, hàm là thực thể \u0026ldquo;hạng nhất\u0026rdquo; của Julia. Trong bài viết này, mình sẽ giới thiệu về cú pháp viết và sử dụng các hàm, cũng như một số trường hợp hay gặp.\nBài viết chủ yếu giới thiệu các cú pháp để làm việc với hàm nên không nói quá chi tiết. Phần đó được dành cho một bài viết khác  Như mình nói ở phần cấu trúc điều khiển, nếu cấu trúc điều khiển của bạn quá phức tạp, bạn có thể sẽ phải viết một hàm. Trong bài viết này mình sẽ nói về việc khai báo, phạm vi biến và gọi hàm.\nKhai báo một hàm Ba kiểu khai báo Việc khai báo một hàm trong Julia có thể được làm theo nhiều cách. Cách 1 là dùng khối function:\n1 2 3 4  function tên_hàm(tham_số) # thân hàm return (giá trị trả về) end   Đoạn code trên là ví dụ đơn giản nhất của một hàm. Từ khóa return không thực sự cần thiết, nếu không có return hàm trên sẽ trả về giá trị của biểu thức cuối cùng được chạy (giống khối if).\nVì Julia là ngôn ngữ động nên hàm trên sẽ chạy với mọi kiểu dữ liệu. Tuy vậy, chúng ta vẫn có thể kiểm soát kiểu dữ liệu của tham số được truyền vào, cũng như kiểu dữ liệu mà hàm trả về.\n1 2 3 4 5  # đây chỉ là ví dụ # đừng viết hàm kiểu này function cộng_một(n::Int)::Int n + 1 # trả về (n + 1) vì đây là biểu thức cuối end   Vì chúng ta chưa tìm hiểu sâu về kiểu dữ liệu nên tạm thời hãy viết những hàm mà chạy với tất cả các kiểu (tức là không định kiểu). Những hàm như vậy được gọi là \u0026ldquo;generic\u0026rdquo; (tổng quát).\nVới những hàm ngắn gọn như vậy, chúng ta có thể dùng hai cú pháp sau:\n1  cộng_một(n) = n + 1   Mình nghĩ họ gọi kiểu hàm trên là hàm \u0026ldquo;inline\u0026rdquo;. Ngoài việc nhìn trông rất thích mắt (nhìn giống với hàm toán học), nếu được cài đặt đúng cách, khi chúng được gọi, thân hàm sẽ được thay thế trực tiếp vào phần code đang gọi nó (tức là code chạy nhanh hơn, không tốn thêm stack).\nTrong Julia, chúng ta có thể khai báo các hàm mà không cần đặt tên cho chúng, chỉ cần bỏ phần tên khỏi hàm:\n1 2 3  function(n) n + 1 end   Những hàm kiểu này thường được dùng làm tham số của một hàm khác. Do dó Julia cung cấp cho chúng ta một cách khai báo tiện gợi hơn:\n1  n -\u0026gt; n + 1   Đương nhiên, nếu muốn chúng ta vẫn có thể gắn tên cho chúng, vì hàm trong Julia có thể được coi là một biến:\n1 2 3 4  cộng_một = n -\u0026gt; n + 1 cộng_một = function(n) n + 1 end   Tuy nhiên, cú pháp với -\u0026gt; thường được sử dụng cho hàm vô danh, những hàm bạn chỉ dùng một lần rồi vứt, không nên dùng để khai báo một hàm có tên như vậy.\nChúng ta cũng có thể khai báo một hàm là toàn cục hay nội bộ với từ khóa local hoặc global\n1 2 3 4 5 6  global function our_func() # thân hàm end local function our_func() # thân hàm end   Tham số mặc định Trong Julia bạn có thể gắn giá trị mặc định cho tham số của hàm:\n1  cộng(n, i = 1) = n + 1   Khi gọi hàm trên, nếu bạn không truyền tham số i thì i sẽ nhận giá trị mặc định là 1\n1  cộng(10) # trả về 11   Tham số có tên Ngoài những tham số được sắp theo thứ tự như trên, hàm trong Julia còn hỗ trợ tham số có tên (keyword arguments). Mặc dù không cần thiết, tham số có tên được ngăn cách với tham số \u0026ldquo;bình thường\u0026rdquo; bằng dấu ; (cả khi gọi và khai báo hàm).\n1 2  cộng(n; m) = n + m cộng(10; m = 20) # trả về 20   Tham số có tên cũng có thể nhận giá trị mặc định. Khi gọi, thứ tự của tham số này không quan trọng, chỉ cần chúng ta định đúng tên:\n1 2 3 4 5  cộng(n; m = 2, p = 3) = n + m + p cộng(10) # trả về 15 cộng(10; p = 8) # trả về 20 cộng(10; z = 100) # lỗi, không có z cộng(10, m = 17) # dùng dấu `,` cũng không sao   Tùy lượng tham số Cuối cùng, chúng ta có một kiểu tham số đặc biệt. Mình nghĩ nó sẽ dễ hiểu hơn với một ví dụ:\n1 2 3 4  trung_bình(args...) = sum(args) / length(args) trung_bình(1, 3, 8) # trả về 4 trung_bình(1, 1, 1, 3) # 1.5 trung_bình(1) # 1   Hàm sum có thể dùng để tính tổng của một mảng, còn length dùng để đếm số phần tử. Như vậy, khi khai báo hàm như trên, những tham số được \u0026ldquo;nhét\u0026rdquo; vào một mảng và cũng ta thao tác trực tiếp trên mảng đó. Điều đó có nghĩa chúng ta có thể truyền một cách tùy, bao nhiêu tham số cũng được.\nGọi hàm Gọi hàm trong Julia rất đơn giản, chúng ta thậm chí đã gọi một số hàm trước đây rồi. Hàm được gọi bằng cú pháp tên_hàm(tham_số; tham_số_có_khóa)\n1  sort([1, -3, 2]; rev = true) # sắp xếp giảm dần   Chúng ta cũng có thể gọi hàm một cách lồng nhau:\n1 2 3  # tạo random mảng 4 phân tử trong khoảng [-9, 9] # sau đó sắp xếp giảm dần sort(rand(-9:9, 4); rev = true)   Tuy nhiên, với những hàm gọi lồng nhau mà không cần tham số nào khác, kiểu như sau:\n1 2 3 4 5  # khai báo f(x) = x + 1 g(x) = 42x # gọi hàm g(f(1))   Julia cung cấp cho chúng ta toán tử rất tiện lợi để tổ hợp hàm:\n1 2  # cách gõ: \\circ\u0026lt;tab\u0026gt; (g ∘ f)(1) # tương dương với g(f(1))   Sự tiện lợi chưa dừng ở đây. Bạn có thể áp dụng một hàm lên một tập hợp giống như lúc làm với toán tử, bằng cách thêm dấu . ở giữa tên hàm và tham số truyền vào:\n1 2 3  M = [1 2 3; 2 3 4; 4 5 6] f(x) = x^2 + 3 f.(M) # lấy mọi phần tử trong ma trận M, mũ 2 rồi cộng 3   Phạm vi biến trong hàm Julia Giống với các vòng lặp, mọi biến trong hàm của Julia đều mặc định có phạm vi là nội bộ. Hàm có thể thay đổi khai báo hoặc thay đổi biến toàn cục, nhưng phải dùng từ khóa global.\nHàm lồng trong hàm Như mình nói phần khai báo hàm, chúng ta có thể thay đổi phạm vi của hàm, vậy các hàm local dùng ở đâu? Đương nhiên là dùng trong các khối khác, dễ hình dung nhất là \u0026ldquo;hàm lồng trong hàm\u0026rdquo;.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function hàm_cha(n) # tính toán function hàm_con(tham_số_con) # thân hàm con end # tính toán while(điều_kiện) # tính toán for i in một_cái_gì_đó # tính toán dùng hàm con vì logic ở đây khá dài hàm_con(tham_số_con) # tính toán end # tính toán end end   Vì những biến được định nghĩa trong hàm mặc định là local - và những hàm trong Julia có thể được coi là một biến, hàm định nghĩa trong hàm mặc định cũng là local. Trong trường hợp trên, hàm_con sẽ không bị \u0026ldquo;rò rỉ\u0026rdquo; ra ngoài phạm vi toàn cục. Chúng ta cũng có thể khai báo hàm local ở trong các khối khác, không nhất thiết phải trong một hàm:\n1 2 3 4 5 6  for i = 1:3 cộng_thêm_i(x) = x + i for j = 2:3 @show cộng_thêm_i(j) end end   Hành vi với tham số truyền vào Trong Julia, đa số các hàm chỉ nhận tham trị và không thay đổi các biến đầu vào. Đương nhiên chúng ta vẫn có những hàm thay đổi tham số của nó. Những hàm này nếu dùng không cẩn thận có thể gây ra những hành vi rất khó đoán, việc phân biệt chúng cũng rất đau đầu trong một số ngôn ngữ.\nMay thay, Julia cung cấp một quy ước để định ra những hàm thay đổi tham số truyền vào của chúng. Những hàm này sẽ có một dấu ! ở sau tên của chúng.\n1 2 3 4 5  arr = [1, -3, 2] sort(arr) # hàm này chỉ trả về mảng đã sắp xếp @show arr sort!(arr) # hàm này sắp xếp luôn mảng arr @show arr   Lưu ý rằng đây chỉ là một quy ước, bạn hoàn toàn có thể viết hàm thay đổi tham số đầu vào mà không có dấu ! trong tên và ngược lại.\nTạm kết Mình xin kết thúc bài giới thiệu về hàm ở đây. Vậy là chúng ta đã kết thúc level 1 của Julia Dojo. Tuy vậy, tất cả những thứ trong level này đều mang tính giới thiệu. Điều đó cũng khá hiển nhiên thôi, một ngôn ngữ vừa nhanh vừa tiện để viết, dù nó đơn giản nhưng bạn cũng không mong nó đơn giản tới mức cục mịch chứ? :)\nĐừng lo, dù phức tạp đi nữa thì Julia khá dễ vọc, không như kiểu hợp ngữ đâu. Mình sẽ cố giải thích cho các bạn những thứ cơ bản, đến khi đủ để các bạn tự tìm hiểu. Nếu các bạn có thắc mắc hoặc thấy thiếu sót đừng ngại liên hệ. Hẹn gặp mọi người trong những level tiếp theo.\n","description":"Giới thiệu về hàm trong Julia","id":2,"section":"posts","tags":["julia"],"title":"Julia Dojo: hàm","uri":"https://ndgnuh.github.io/julia-dojo/ham-trong-julia/"},{"content":"Chào mừng các bạn trở lại với Julia Dojo. Chúng ta đã tìm hiểu về cách khai báo biến và làm việc với một số kiểu dữ liệu trong bài viết biến số, kiểu dữ liệu, phép toán. Nhưng một chương trình chỉ có gán, gọi hàm và phép toán không thì không đủ, do đó, chúng ta ta có các cấu trúc điều khiển.\n  Nội dung chỉnh sửa  29/01/2020:\n- thêm phần lặp for, lặp với bước nhảy không phải 1\n- thêm phần khối lệnh (vốn định đưa sang bài hàm, nhưng thôi)   Khối lệnh Đến phần này, chúng ta sẽ phải biết cách nhận biết một khối lệnh trong Julia. Trong các ngôn ngữ như C hoặc Java, chúng ta dùng một cặp { } để đánh dấu các dòng lệnh. Ở đây chúng tôi không làm vậy.\nLỗi: meme được dùng đi dùng lại quá nhiều  Thay vào đó, mỗi từ khóa end sẽ được kết hợp với các từ khóa lặp, khai báo hàm, rẽ nhánh, v.v\u0026hellip; ở đầu của một khối lệnh. Một cặp \u0026ldquo;từ khóa mở đầu - end\u0026rdquo; sẽ đánh dấu một khối lệnh trong Julia. Khối lệnh đơn giản nhất trong Julia, là\u0026hellip; một khối lệnh theo đúng nghĩa. Nó bắt đầu với từ khóa begin, mình thường dùng khi phép gán của mình có một biểu thức rất dài, nên muốn chia nó thành các biến phụ cho đỡ rối mắt.\n1 2 3 4 5  z = begin local x = 1 local y = 2 # tưởng tượng nó rất dài hộ mình :) x + y end   Khối lệnh sẽ trả ra giá trị ứng với biểu thức ứng cuối cùng của nó (tức x + y trong ví dụ trên). Ngoài ra chúng ta cũng có thể dùng từ khóa return để trả về một giá trị và kết thúc việc thực hiện khối lệnh. Hãy cẩn thận, khối begin có thể thay đổi biến toàn cục mà không báo trước, đó cũng là lí do mình dùng từ khóa local ở trên.\nNếu bạn không thích dùng begin, end chúng ta cũng có thể viết:\n1 2 3 4  z = (local x = 1; local y = 2; x + y) z = (local x = 1; local y = 2; x + y)   Mình là người có điều kiện If\u0026hellip; Hãy thử tượng tượng phải lập trình nhưng không được dùng các cấu trúc rẽ nhánh xem. Bạn sẽ làm ra một chương trình mà, hoặc không thể sử dụng được, hoặc chứa một đống các loại đa hình để thay cho cấu trúc rẽ nhánh (cũng không lí tưởng lắm!). Vậy nên, tội gì không sử dụng if - else cho cuộc sống dễ dàng.\n1 2 3 4 5 6 7 8  x = rand(-1:1) if x == 1 println(x) elseif x == 0 println(x + 1) else println(x + 2) end   Chúc mừng, bạn đã viết thành công chương trình in ra số 1 (dùng if - else - end). Trong cấu trúc rẽ nhánh, các từ khóa elseif, else là không bắt buộc, nếu bạn không có nhiều trường hợp thì không phải viết chúng.\nNếu các bạn đang tự hỏi Julia có cấu trúc switch hay không, mình trả lời luôn là không, lí do là\u0026hellip; không cần thiết. Thực chất cấu trúc switch có thể được thay thế bằng if và một đống elseif, mỗi điều kiện chính là một case, và else chính là default.\nToán tử ba ngôi Trong Julia, mọi cấu trúc if đều trả về một giá trị nào đó. Bạn hoàn toàn có thể viết như sau:\n1 2 3 4 5 6  @show a = rand(0:1) # a nhận giá trị 0 hoặc 1, ngẫu nhiên b = if a == 0 0 else 1 end; println(\u0026#34;b=$b\u0026#34;)   Đoạn chương trình trên\u0026hellip; in ra số 0 và gắn b bằng a rồi in ra b. Giá trị của if trả về chính là câu lệnh cuối cùng mà nó chạy. nhưng nếu thích bạn có thể viết từ khóa return để \u0026ldquo;trang trí\u0026rdquo;.\n1 2 3 4 5  b = if a == 0 return 0 else return 1 end   Nhưng mà thực sự, đừng làm như vậy :) Chúng ta có toán tử ba ngôi cho những việc như thế này.\n1 2  a = rand(0:1) b = (a == 1) ? 1 : 0   Vẫn là chương trình random a rồi gán b bằng a, nhưng gọn hơn rất nhiều (mình không nói là cách gọn nhất\u0026hellip;). Dấu ngoặc bao quanh điều kiện là không cần thiết, nhưng mình viết vậy vì nó dễ nhìn.\nNếu dùng @show lên toán tử ba ngôi, chúng ta sẽ thấy nó chỉ là một khối if được đơn giản hóa.\n1 2 3 4 5 6 7  julia\u0026gt; @show (x == 1) ? 1 : 0 if x == 1 1 else 0 end = 1 1   Phạm vi của biến trong if Những biến được khai báo trong khối if sẽ tồn tại ở cả bên ngoài khối. Ví dụ trong đoạn code dưới đây:\n1 2 3 4 5 6  if rand(Bool) x = 1 else x = 10 end @show x   Nếu biến x chưa tồn tại, nó sẽ được khai báo. Nếu nó đã tồn tại, giá trị của nó sẽ được thay đổi. Việc thêm từ khóa local sẽ không có tác dụng gì. Nói cách khác, khối if có cùng phạm vi biến (scope) với khối lệnh chứa nó\nLặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp, lặp\u0026hellip; Thử tưởng tượng lập trình mà không có vòng lặp xem (thực ra các bạn có thể dùng đệ quy thay cho vòng lặp, nhưng mình thấy lặp vẵn dễ sống hơn!). Vòng lặp khác với hai khối trên (ngoài việc nó lặp) ở chỗ: nó không trả về giá trị gì cả, trừ khi bạn ném từ khóa return vào trong vòng lặp.\nJulia cung cấp cho chúng ta hai loại vòng lặp: for và while, hãy cùng tìm hiểu chúng.\nVòng lặp for Đầu tiên chúng ta có vòng lặp for để lặp với số lần xác định trước:\n1 2 3 4 5 6  for i = 1:10 println(i) end for i = 1:2:10 # lặp với bước nhảy 2, mặc định bước nhảy là 1 println(i) end   Bạn cũng có thể dùng lặp với từng phần tử của một tập hợp hay một mảng nào đó.\n1 2 3 4  arr = [1, 2, 3] for x in arr println(x) end   Chúng ta cũng có thể lặp qua một xâu kí tự:\n1 2 3 4  s = \u0026#34;xinchào\u0026#34; for i = 1:length(s) println(s[i]) end   Khi chạy đoạn code trên, chúng ta sẽ thu được\u0026hellip; lỗi.\n1 2 3 4 5 6  ERROR: StringIndexError(\u0026#34;xin chào\u0026#34;, 8) Stacktrace: [1] string_index_err(::String, ::Int64) at ./strings/string.jl:12 [2] getindex_continued(::String, ::Int64, ::UInt32) at ./strings/string.jl:220 [3] getindex(::String, ::Int64) at ./strings/string.jl:213 [4] top-level scope at ./REPL[4]:2   Điều này xảy ra vì Julia hỗ trợ unicode, do đó không phải string nào cũng là ascii (bạn có thể kiểm tra bằng hàm isascii). Những kí tự không nằm trong bảng ascii sẽ chiếm một số lượng index không xác định. Vậy muốn lặp qua một xâu kí tự an toàn thì làm như thế nào?\n1 2 3  for i in eachindex(s) println(s[i]) end   Hàm eachindex sẽ sinh ra một bộ chỉ số của xâu s và bạn có thể lặp qua từng kí tự của s một cách an toàn. Hơn nữa, eachindex nhìn đẹp hơn 1:length(s). Nếu bạn không cần chỉ số mà chỉ cần kí tự, bạn có thể lặp như sau:\n1 2 3  for c in s println(c) end   Không chỉ với string, eachindex hoạt động với tất cả các kiễu dữ liệu có thể lặp được (nói sau nhé), bao gồm cả mảng, ma trận. Nếu mình không nhầm, dùng nó cũng có lợi về hiệu năng hơn vì Julia sẽ không phải kiểm tra việc đánh chỉ số có đúng hay không.\nBạn có thể dùng nhiều vòng lặp lồng nhau như các ngôn ngữ lập trình khác:\n1 2 3 4 5 6 7  for i = 1:2 for j = 3:4 for k = 5:6 @show (i, j, k) end end end   Trong trường hợp vòng lặp bên ngoài không có nhiệm vụ gì ngoài gọi vòng lặp con như trên, code của chúng ta sẽ trông như cái tam giác trống, nhìn hơi tù. Julia cung cấp cho chúng ta cách chồng các vòng lặp lên nhau.\n1 2 3  for i=1:2, j=3:4, k=5:6 @show (i, j, k) end   Đoạn code này sẽ in ra cùng một kết quả như trên, nhưng lại gọn gàng và dễ nhìn hơn. Dù sao, nếu bạn phải dùng tới ba bốn vòng lặp, logic trong code của bạn có thể đã trở nên phức tạp và đó là dấu hiệu của việc bạn nên viết hàm.\nVòng lặp while Cấu trúc lặp while thì mạnh mẽ hơn lặp for rất nhiều, nó có thể dùng để lặp với số lần lặp không xác định (hoặc có, nhưng đó là việc của for). Vòng lặp while không có nhiều thứ cần đặc biệt lưu ý giống như for, các bạn có thể dùng nó với cú pháp như sau:\n1 2 3 4 5  điều_kiện = true # biểu thức điều kiện while điều_kiện # làm gì đó # với dữ liệu end   Phạm vi biến của cấu trúc lặp Vòng lặp trong julia có phạm vi biến riêng. Điều đó có nghĩa, các vòng lặp sẽ không thay đổi các biến toàn cục một các tùy tiện.\n1 2 3 4 5 6  # phạm vi toàn cục (global scope) x = 10 for i = 1:10 x = i # biến i vẫn truy cập được end @show x # x vẫn là 10   Tuy nhiên, khi vòng lặp được lồng trong một phạm vi nội bộ (một vòng lặp khác, một hàm), chúng có thể cập nhật biến trong phạm vi đó:\n1 2 3 4 5 6 7  for i = 1:2 x = i for j = 3:4 x = x * j end @show x # biến x sẽ thay đổi end   Nếu bạn muốn thay đổi biến toàn cục, hãy dùng từ khóa global:\n1 2 3 4 5  x = 10 for i = 1:5 global x *= i end @show x # x = 1200   Thoát lặp, nhảy lặp Nếu bạn đang lặp mà muốn dừng giữa chừng, bạn có thể dùng break để thoát hoàn toàn khỏi vòng lặp.\n1 2 3 4 5 6 7  đếm = 1 while true global đếm += 1 if đếm == 4 break end end   Nếu vì lí do nào đó, bạn muốn nhảy cóc một vòng lặp, bạn có thể dùng từ khóa continue.\n1 2 3 4 5 6 7  for i = 1:4 if i == 3 continue else @show i end end   Với những đoạn rẽ nhánh đơn giản như trên, chúng ta có thể dùng kết hợp với toán tử ba ngôi cho gọn:\n1 2 3  for i = 1:4 i == 3 ? continue : @show i end   Tạm kết Sau khi biết được các cấu trúc điều khiển cơ bản. Hãy nhớ rằng nếu bạn lồng quá nhiều cấu trúc điều khiển với nhau, bạn có thể đang cần tách logic trong code ra thành một hàm. Viết hàm thế nào, hồi sau sẽ rõ :) Hẹn gặp lại các bạn ở bài viết sau.\n","description":"Cấu trúc điều kiện và lặp trong Julia","id":3,"section":"posts","tags":["julia"],"title":"Julia Dojo: cấu trúc điều khiển trong Julia","uri":"https://ndgnuh.github.io/julia-dojo/re-nhanh-va-lap-trong-julia/"},{"content":"Chào mừng các bạn trở lại với Julia Dojo. Hôm nay chúng ta sẽ tìm hiểu về một thứ khá cơ bản và thiết yếu trong các ngôn ngữ lập trình, đó là biến số (ok, không hẳn là thiết yếu, nhưng nó làm cuộc sống dễ dàng hơn), đồng thời khám phá một số kiểu dữ liệu cơ bản và thao tác với chúng.\nBiến số, hằng số Đôi khi, trông các bài hướng dẫn về ngôn ngữ lập trình, họ đồng nhất biến số và hằng số theo kiểu \u0026ldquo;hằng số là một biến số mà không thể thay đổi\u0026rdquo;. Điều này không đúng lắm về mặt kĩ thuật (technically correct is the best kind of correct). Tuy nhiên, nếu nó tiện lợi, nghe thuận tai và dễ hiểu hơn với bạn thì\u0026hellip; meh, tùy, whatever floats your boat.  Để khai báo một biến trong Julia, bạn chỉ cần sử dụng cú pháp:\n1 2  tên_biến = \u0026#34;giátrị\u0026#34; こんにちは世界 = \u0026#34;Helloworld,googledịchvậy:)\u0026#34;   Điều hay nhất là: hai dòng lệnh trên hoàn toàn hợp lệ trong Julia (copy nó vào REPL và chạy thử đi!). Tên biến số, hằng số trong Julia có thể Là kí tự unicode, và các kí tự tiếng Việt không phải ngoại lệ. Tuy nhiên, mình nghĩ bạn không nên code bằng tiếng Việt có dấu, tiêng Nhật, tiếng Tàu hay tiếng Thái đâu. Cách tốt nhất để dùng tính năng này là:\n1 2 3 4 5 6 7 8  #=Bạncóthểgõcáinàytheocácbước:1.Nhập\u0026#34;\\varepsilon\u0026#34;(varepsilon)2.Nhấnphím\u0026lt;tab\u0026gt;TínhnăngnàycótrênmọicôngcụhỗtrợJulia=# ε = 1e-9 # Giờ thì công thức toán trong # code của bạn sẽ gọn và dễ đọc hơn   Cực kì tiện lợi khi bạn code những phần mềm dùng nhiều công thức toán (mà lúc nào chẳng có toán chứ?). Nhân tiện mình giới thiệu luôn, dấu # được dùng để comment trên một dòng code (tất cả những gì sau dấu này sẽ được bỏ qua; còn cặp dấu #= và =# được dùng để comment trên nhiều dòng, mọi thứ giữa hai thằng này sẽ bị bỏ qua khi chạy code.\nCòn đề khai báo hằng số, bạn chỉ cần nhét thêm chữ const vào đầu dòng như sau:\n1  const hằng_số = true   Bất kì biến số, hằng nào bạn định nghĩa như trên trong REPL đều được coi là biến toàn cục. Nếu bạn viết một phần mềm sản xuất, hãy dùng ít biến toàn cục nhất có thể (vì lí do hiệu năng, lí do bảo dưỡng, v.v\u0026hellip; bạn không dùng càng tốt). Nhưng hằng số toàn cục vẫn ok nhé, thực chất Julia chỉ cho phép khai báo hằng số toàn cục thôi. Bạn có thể dùng từ khóa local để khai báo nội bộ và từ khóa global để khai báo toàn cục.\n1 2 3  local x = 1 global y = 2 local const z = \u0026#34;lỗi\u0026#34;   Nếu bạn khai báo biến local trưc tiếp trên REPL, nó sẽ biến mất ngay lập tức và bạn không dùng được nó. Vậy biến nội bộ có hiệu lực ở đâu, hồi sau sẽ rõ :) Giờ chúng ta chuyển sang nói qua về kiểu dữ liệu.\nKiểu dữ liệu Khi bạn gán một biến trong Julia, bộ dịch sẽ tự phát hiện kiểu và gắn kiểu dữ liệu của nó cho biến. Điều tương tự cũng xảy ra với hằng số. Bạn có thể lấy kiểu dữ liệu của một biến hay hằng bằng hàm typeof:\n1 2 3 4 5 6  x = 1.0 typeof(x) # Trả về một kiểu Float typeof(π) # Trả về Irrational{:π} # đây là một hằng số # viết bằng cách \\pi \u0026lt;tab\u0026gt; # có thể dùng chữ pi cũng được   Nhìn mấy cái kiểu dữ liệu có vẻ lằng nhằng, nhưng chúng ta đang ở Level 1, đừng bận tâm về nó vội. Mình chỉ giới thiệu qua một số kiểu dữ liệu hay dùng ở đây thôi.\nCác kiểu số Một ít int\n1  n = 3   Một ít float\n1 2  x = 2.0 y = 4.0   Một ít hữu tỉ\n1  p = 1//2   Một ít hư ảo\n1  z = 1 + 2im # hoặc 1 + 2 * im   Một ít phép toán\n1 2 3 4 5 6 7 8 9 10 11 12 13  đối = -z cộng = n + x cộng += z trừ = n - z nhân = z * p chia = n / x # lấy n chia x chia_ngược = n \\ x # lấy x chia cho n chia_hữu_tỉ = z // (3 - 4im) lũy_thừa = x^n lấy_căn = sqrt(4) lấy_căn_phức = sqrt(complex(-1)) # sqrt(-1) sẽ lỗi, vì kiểu của -1 là Real giá_trị_tuyệt_đối = abs(-3.4) module_phức = abs(z)   Một ít hàm toán học\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # Các hàm liên quan đến logarith exp(x) # e^x, e là hằng số Euler log(x) # loga cơ số e log10(x) # loga cơ số 10 log2(x) # loga cơ số 2 log1p(x) # loga cơ số e của (1 + x) log(y, x) # loga cơ số y của x # Các hàm liên quan tới lượng giác # Ngoài sin ra còn có cos, tan, cot sin(x) # lượng giác, dùng radian, tương tự có cos, tan, cot sind(x) # như sin, nhưng dùng đơn vị độ sinh(x) # hàm hyperbolic asin(x) # lượng giác ngược asind(x) # như asin, đơn vị độ asinh(x) # hàm hyperbolic ngược deg2rad(x) # chuyển từ độ sang radian rad2deg(x) # chuyển từ radian sang độ   Một ít phép so sánh\n1 2 3 4 5 6 7 8 9 10 11 12  bé_hơn = (x \u0026lt; y) lớn_hơn = (x \u0026gt; y) bằng = (x == y) khác = (x != y) khác = (x ≠ y) # \\ne\u0026lt;tab\u0026gt; xấp_xỉ = isapprox(x, y) xấp_xỉ = (x ≈ y) # \\approx\u0026lt;tab\u0026gt; không_xấp_xỉ = (x ≉ y) # \\napprox\u0026lt;tab\u0026gt; lớn_hơn_hoặc_bằng = x \u0026gt;= y lớn_hơn_hoặc_bằng = x ≥ y # \\ge\u0026lt;tab\u0026gt; (Greater than or Equal) bé_hơn_hoặc_bằng = x \u0026lt;= y bé_hơn_hoặc_bằng = x ≤ y # \\le\u0026lt;tab\u0026gt; (Less than or Equal)   Kiểu Bool Julia dùng true và false cho các giá trị thuộc kiểu Bool\n1 2 3 4 5 6 7  a = true b = false phủ_định = !a và_logic = a \u0026amp;\u0026amp; b hoặc_logic = a || b xor_logic = xor(a, b) xor_logc = a ⊻ b # \\xor\u0026lt;tab\u0026gt;   Kí tự và xâu kí tự Trong Julia, kí tự được bao quanh bởi dấu nháy đơn, còn xâu kí tự được bao quanh bởi dấu nháy kép. Bạn có thể dùng 3 dấu nháy kép để viết các xâu kí tự phức tạp, gồm nhiều dòng.\n1 2 3 4 5 6 7 8  kí_tự = \u0026#39;a\u0026#39; xâu = \u0026#34;helloworld\u0026#34; xâu_phức_tạp = \u0026#34;\u0026#34;\u0026#34;\u0026#34;Trămnămtrongcõingườita,ThúyKiềulàmẹ,conlàThúyVân\u0026#34;Câuthơchothấythằngnàongồiviếtcáinàyrấtdốtvăn...\u0026#34;\u0026#34;\u0026#34;   Julia hỗ trợ \u0026ldquo;nội suy\u0026rdquo; xâu kí tự (string interpolation, không mình biết dịch đúng không nữa). Dùng dấu $ là bạn có thể \u0026ldquo;nhúng\u0026rdquo; một biến vào trong xâu kí tự. Nếu bạn muốn dưa một biểu thức vào, hãy dùng $(biểu_thức).\n1 2 3 4  x = rand(-3:3) println(\u0026#34;mộtsốngẫunhiêntrongkhoảng-3tới3:$x\u0026#34;) # hoặc println(\u0026#34;mộtsốngẫunhiêntrongkhoảng-3tới3:$(rand(-3:3))\u0026#34;)   Một số hành động với kí tự và xâu kí tự:\n1 2 3 4 5 6 7 8  clipboard(\u0026#34;copytoànbộxâukítựnày,dùngcáinàymaxtiện\u0026#34;) collect(\u0026#34;xâukítự\u0026#34;) # chuyển xâu kí tự thành một mảng các kí tự Int(\u0026#39;c\u0026#39;) # Chuyển kí tự sang mã Unicode Char(97) # Chuyển mã kí tự thành kí tự length(\u0026#34;độdàixâu\u0026#34;) \u0026#34;nối\u0026#34; * \u0026#34;xâu\u0026#34; * \u0026#34;kítự\u0026#34; \u0026#34;nhânlên3lần\u0026#34; ^ 3 \u0026#34;abc\u0026#34; \u0026lt; \u0026#34;abd\u0026#34; # so sánh theo thứ tự từ điển, dựa vào mã kí tự   Mảng, ma trận Phần hay nhất để dành cuối cùng :) Julia hộ trợ tính toán ma trận rất ngon. Ngon thế nào thì từ từ mới biết hết, đặc biệt các bạn dùng Matlab có thể sẽ thấy nó quen thuộc. Phần này đáng có một bài viết riêng, vì vậy trong bài này mình chỉ giới thiệu thôi.\nTrong Julia, số chiều của ma trận được phân biệt rất rõ ràng. Khi khai báo một vector, chúng ta dùng dấu , hoặc ; để ngăn cách các phần tử:\n1 2  A = [1, 2, 3] B = rand(3) # vector ngẫu nhiên   Đoạn code trên sẽ tạo ra A và B là vector cột. Đối với ma trận, chúng ta dùng dấu cách ngăn cách các phần tử cùng hàng, và dấu ; để ngăn cách giữa các dòng\n1 2 3  M = [1, 2, 3; 4, 5, 6; 7, 8, 9] # lỗi, không dùng được dấu \u0026#34;,\u0026#34; đâu M = [1 2 3; 4 5 6; 7 8 9] N = rand(3, 3) # ma trận ngẫu nhiên   Để lấy chỉ số của vector, ma trận, chúng ta dùng cú pháp ma_trận[chỉ_số]. Julia lưu ma trận theo cột, chúng ta có thể dùng chỉ số 1 chiều hoặc 2 chiều để lấy ra phần tử của ma trận.\n1 2 3 4 5 6 7  M[2, 3] # hàng 2 cột 3, trả ra 6 M[4] # phần tử thứ 4, nhưng duyệt theo từng hàng, trả ra 2 M[end] # phân tử cuối cùng M[1:2, end] # hàng 1 tới hàng 2, cột cuối cùng M[end, [1, 3]] # cột 1 và 3, hàng cuối cùng M[[1, 2], [2, 3]] # đoán xem? :) M[:, end] # cột cuối   Trong Julia, việc gán ma trận sẽ không tạo bản copy của ma trận đó, trừ khi bạn lấy một phần của ma trận:\n1 2 3 4 5 6  L = M L[1] = 2 # M cũng bị thay đổi L = M[[1, 2], :] L[1] = 3 # M không bị đổi L = copy(M) # copy lại M, tạo ma trận mới L[1] = 3 # M không bị đổi   Các phép toán với vector, ma trận được thực hiện rất tự nhiên (theo quy tắc toán học):\n1 2 3 4 5 6 7 8 9 10 11  A * B # báo lỗi, hai vector có chiều 1 × 3 không nhân với nhau được A * B\u0026#39; # nhưng nếu B chuyển vị thành vector hàng thì ok :) M * N # hai ma trận (3, 3) nhân với nhau M * A # nhân ma trận (3, 3) với vector (3, 1) A + B # cộng vector M + N # cộng ma trận A + B\u0026#39; # lỗi, cộng vector ma trận phải cùng chiều A .+ B\u0026#39; # nhưng cộng từng phần tử lại là chuyện khác :) A .* B\u0026#39; # nhân phần tử cũng vậy luôn M ^ 5 # ma trận vuông có thể lấy lũy thừa M .^ 5 # lũy thừa từng phần tử   Lưu ý rằng, đối với trường hợp số thực, chúng ta có thể dùng A' để chuyển vị. Với ma trận số phức hãy dùng transpose. Để biết chi tiết hãy xem thêm:\n transpose: https://en.wikipedia.org/wiki/Transpose adjoint (dấu nháy): https://en.wikipedia.org/wiki/Conjugate_transpose  (sorry vì màu link khó nhìn, mình sẽ gửi issue lên người bảo trì theme này)\n Kết luận Ok, phần giới thiệu tới đây mình nghĩ đủ rồi. Vậy các là các bạn đã biết cách khai báo biến, cộng trừ nhân chia và những trò hay ho mà trên trường giáo viên sẽ bắt chúng ta ngồi tính sấp mặt. Hẹn gặp các bạn trong bài viết sau.\nBonus: nếu đang học đại học, giờ bạn có thể dùng Julia như một cái máy tính cá nhân (nhưng vạn năng hơn một tí)\n1 2  # Giải hệ phương trình A⋅X = B trong một nốt nhạc A^-1 * B   ","description":"Biến số, hằng số, kiểu dữ liệu và một số thao tác đơn giản với chúng trong Julia","id":4,"section":"posts","tags":["julia"],"title":"Julia Dojo: biến số, kiểu dữ liệu, phép toán","uri":"https://ndgnuh.github.io/julia-dojo/bien-so-va-kieu-du-lieu-trong-julia/"},{"content":"Chào mừng các bạn quay trở lại với series Julia Dojo. Hôm nay chúng ta sẽ học cách viết một chương trình trong Julia và làm thế nào để chạy nó.\nDân gian ta có câu:\n Lời chào cao hơn mâm cỗ\n\u0026ndash; Dân Gian Ta (mình cũng không biết đây là thằng nào)\n Lời chào rất quan trọng, trong lĩnh vực lập trình điều này không phải ngoại lệ. Do đó, hôm nay chúng ta sẽ viết chương trình \u0026ldquo;chào thế giới\u0026rdquo;, dân-gian-ta còn gọi là \u0026ldquo;hello world\u0026rdquo;.\nChương trình đầu tiên của bạn Hello world là chương trình rất quen thuộc nếu bạn đã học lập trình trước đây. Nó sẽ cho bạn cái nhìn đầu tiên về cấu trúc ngữ pháp của một ngôn ngữ lập trình. Đầu tiên, hãy mở một trình sửa văn bản, tạo một file tên hello-world.jl.\nTrước đây, đuôi file .j được sử dụng cho ngôn ngữ Julia. Sau này, họ đổi thành .jl, cá nhân mình thấy thích cái đuôi file này hơn.\nKhi tạo file xong, hãy điền nội dung sau vào file:\n1  println(\u0026#34;helloworld\u0026#34;)   Xong, bạn hãy mở một terminal tại vị trí bạn lưu file trên, sau đó chạy lệnh.\n1  julia hello-world.jl   Dòng chữ \u0026ldquo;hello world\u0026rdquo; sẽ được in ra màn hình. Vậy là bạn đã viết và chạy thành công chương trình hello world của mình với Julia.\nRất nhiều cách để nói \u0026ldquo;hello world\u0026rdquo; Chúng ta sẽ chỉnh sửa chương trình hello world một chút. Ở trên mình dùng hàm println để in ra chuỗi hello world. Giờ mình sẽ giới thiệu một vài cách khác:\n1 2 3 4 5 6  println(\u0026#34;helloworld\u0026#34;) print(\u0026#34;helloworld\u0026#34;); println() @show \u0026#34;helloworld\u0026#34; @info \u0026#34;helloworld\u0026#34; @warn \u0026#34;helloworld\u0026#34; @error \u0026#34;helloworld\u0026#34;   Chạy file trên, chúng ta sẽ thu được output:\nhello world hello world \u0026quot;hello world\u0026quot; = \u0026quot;hello world\u0026quot; [ Info: hello world ┌ Warning: hello world └ @ Main /tmp/hello-world.jl:6 ┌ Error: hello world └ @ Main /tmp/hello-world.jl:7  Dòng đầu là kết quả của println, hàm này sẽ in ra tham số của nó, sau đó in kí tự ngắt dòng. Dòng thứ hai là kết quả của print, hàm này giống println nhưng không in kí tự ngắt dòng, do đó mình phải thêm một hàm println() trống ở phía sau. Các bạn để ý thêm. Ở dòng số 2 file hello-world.jl, mình có dấu ;. Đấu này không cần thiết khi bạn viết mỗi lệnh trên một dòng. Tuy nhiên nếu bạn cần viết hai lệnh trên cùng dòng thì sẽ cần tới nó để ngắt giữa hai lệnh. Ở dòng 3, macro @show in ra một điều \u0026ldquo;hiển nhiên\u0026rdquo;: \u0026quot;hello world\u0026quot; = \u0026quot;hello world\u0026quot;. Thực ra, cái này dùng để show ra giá trị của một biến hay hằng số, ở đây chúng ta truyền cho nó một hằng số nên nó in ra củ chuối như vậy\u0026hellip; Macro là gì ư? Tạm thời bạn đừng quan tâm, hãy tạm hiểu nó có dấu @ và làm một cái gì đó cho bạn. Ở dòng 4, chúng ta có @info. Macro này có tính ghi chú, nó chỉ nhận đầu vào là chuỗi kí tự thôi. @info được dùng để đưa ra bản ghi chép (log) cho chương trình của bạn. Ở dòng 5, chúng ta có @warn. Thằng này giống thằng @info, nhưng nó nói với giọng \u0026ldquo;bố đang cảnh báo mày đấy\u0026rdquo;. Tuy hổ báo nhưng nó sẽ không đừng việc thực thi chương trình của bạn. @warn thường được dùng khi một người viết gói chương trình muốn deprecate (tạm dịch là cho lỗi thời, mình không biết dịch như nào cho hay) một tính năng nào đó và cảnh báo người dùng không nên dùng nó. Cuối cùng, chúng ta có @error. Thằng này nó sẽ cảnh báo và cho chương trình của bạn bay màu luôn. @error được dùng rất nhiều. Bạn sẽ gặp nó khi gọi một hàm không tồn tại chẳng hạn.  Chế độ tương tác Bạn có thấy viết hẳn một file, chỉ dành cho một dòng code mà in ra hello world có hơi thừa? Nếu vậy hãy mở terminal ra, chạy câu lệnh sau:\n1  julia   Chế độ tương tác Julia (hay Julia REPL) sẽ chào đón bạn với một cái logo ascii (không có mèo đâu, đấy là hình nền của mình :P)\n chế độ tương tác Julia   Bạn có thể chạy \u0026ldquo;hello world\u0026rdquo; bằng cách nhập câu lệnh trên vào và nhấn Enter:\n hello world trong một dòng   Thậm chí bạn có thể gõ ?println và xem thông tin về những thứ mình vừa viết ở trên.\n chế độ help   Goodbye, world Ok, vậy là bạn đã biết những cách đơn giản nhất viết và chạy chương trình Julia (và cũng là chương trình đơn giản nhất luôn). Chúng ta sẽ lần lượt tìm hiểu những phương thức khác trong các bài tiếp theo. Riêng với chế độ tương tác, mình có thể làm một bài nữa, nói về những tính năng của nó. Hẹn gặp lại các bạn trong những bài viết sau :)\n","description":"Viết chương trình đầu tiên của bạn trong Julia","id":5,"section":"posts","tags":["julia"],"title":"Julia Dojo: Hello world","uri":"https://ndgnuh.github.io/julia-dojo/hello-world/"},{"content":"Chào mừng các bạn đến với bài viết đầu tiên của series \u0026ldquo;Julia từ con số không\u0026rdquo;. Trong bài viết này mình sẽ hướng dẫn các bạn cách cài đặt Julia.\nĐể cài Julia, chúng ta có 2 cách:\n Cài đặt từ bản phân phối chính thức: cách này được khuyến cáo vì nó sẽ không gây lỗi lặt vặt, tuy nhiên quá trình cài đặt sẽ hơi dài một chút. Cài đặt từ bản phân phối của cộng đồng: cách này rất đơn giản, đặc biệt với những bạn dùng Linux. Tuy nhiên cách này có thể gây lỗi vặt (thực ra mình mới chỉ thấy một lỗi trên ArchLinux, chưa thấy có người gửi issue nào khác)  Mình sẽ hướng dẫn các bạn cả hai cách. Việc cài đặt có thể sử dụng tới terminal (dòng lệnh, hiểu nôm na là vậy), vậy có kiến thức cơ bản về việc sử dụng terminal và shell có thể sẽ hữu dụng và giúp quá trình cài đặt dễ dàng hơn. Nếu bạn không biết những thứ này cũng không nên lo quá.\nCài đặt bản phân phối từ cộng đồng Vì cách này ngắn và đơn giản hơn, mình sẽ hướng dẫn trước. Để thực hiện cách cài đặt này, bạn cần có package manager. Cái này trên *Nix thì có chắc chắn có sẵn, còn trên MacOS và Windows có lẽ bạn sẽ phải cài thêm. Khi xong xuôi, bạn chỉ cần mở terminal và ehạy lệnh tương ứng với hệ điều hành của mình:\n  Windows - Chocolately  Cài đặt:\n1  choco install julia --confirm   Cập nhật:\n1  choco upgrade julia --confirm        MacOs - HomeBrew  HomeBrew trên Mac 1  brew cask install julia        Fedora/Red hat/Cent OS và các distro tương tự  Với Fedora bản 19 hoặc hơn:\n1 2  sudo dnf copr enable nalimilan/julia sudo yum install julia   Nếu bạn dùng Cent OS bản 7 hoặc hơn:\n1 2  sudo yum-config-manager –add-repo https://copr.fedorainfracloud.org/coprs/nalimilan/julia/repo/epel-7/nalimilan-julia-epel-7.repo sudo yum install julia   Nếu dnf và yum-config-manager không khả dụng trên hệ thống của bạn, hãy tải file .repo tương ứng ở link phía trên và copy vào /etc/yum.repos, sau đó chạy câu lệnh thứ 2.\nĐể cập nhật Julia:\n1  yum upgrade julia        Debian/Ubuntu và các distro tương tự  Cài đặt:\n1 2  sudo apt update sudo apt install julia   Cập nhật:\n1 2  sudo apt update sudo apt upgrade        Archlinux và các distro tương tự  Cài đặt:\n1 2 3 4  sudo pacman -S julia # bản không chính thức # những bản này cần `yay` để cài tự động sudo yay -S julia-bin # tương ứng với bản chính thức từ trang chủ yay -S julia-git # tương ứng vởi bản build từ git   Cập nhật:\n1 2 3  sudo pacman -Syu # hoặc yay -Syu      Cài đặt từ bản phân phối chính thức Việc cài đặt sẽ chia thành ba bước. Đầu tiên, bạn cần truy cập trang tải về của Julia để lấy bản phân phối chính thức. Mình sẽ hướng dẫn chi tiết quá trình cài đặt. Bước tiếp theo là giải nế và cài đặt. Cuối cùng, chúng ta sẽ cài đặt biến môi trường để có thể truy cập vào Julia mọi lúc mọi nơi.\nTải Julia  Trang download Julia   Julia cung cấp một số lựa chọn:\n Current stable release: phiên bản ổn định. Bản Release Candidate: phiên bản ứng cứ viên phát hành, có thể hiểu là \u0026ldquo;gần\u0026rdquo; ổn định.. Long-term support: Phiên bản hỗ trợ lâu dài, bạn có thể hiểu đây là phiên bạn \u0026ldquo;cực kì ổn định\u0026rdquo;. Bản Nightly: Bản thử nghiệm, dành cho những thanh niên thích thử nghiệm.  Sau khi đã quyết định sẽ sử dụng phiên bản nào, hãy tải về bản cài đặt phù hợp với hệ điều hành của bạn. Ví dụ nếu mình dùng Windows 64 bit hãy tải file Windows (.exe) ở cột 64-bit (trong ảnh).\nGiải nén và cài đặt   Windows  Sau khi tải Julia như trên, chúng ta sẽ có một file .exe. Mở file exe này lên. Việc cài đặt tương đối đơn giản, chỉ cần next, next và next.\nLưu ý rằng, quá trình cài đặt có một bước chọn đường dẫn giải nén. Hãy lưu lại đường dẫn này để sử dụng ở bước sau.\n    MacOS  Sau khi tải Julia như trên, chúng ta sẽ có một file .dmg. Mở file .dmg ấy, bên trong có file Julia-\u0026lt;phiên-bản\u0026gt;.app. Kéo thả file này vào thư mục Application trên desktop của bạn và bạn đã hoàn thành bước này.     Linux, BSD, *Nix  Sau khi tải Julia như trên, chúng ta sẽ có một file .tar.gz. Hãy copy file này vào vị trí cài đặt tương ứng, sau đó giải nén file này ra bằng lệnh:\n1  tar -xvf đường/dẫn/tới/\u0026lt;file-của-bạn\u0026gt;.tar.gz   Một vài file, thư mục mới sẽ xuất hiện, vậy là bạn đã hoàn thành bước này.\n  Thêm đường dẫn đến Julia vào biến môi trường Để có thể gọi Julia từ mọi nơi, bạn cần thêm đường dẫn tới file thực thi Julia vào biến $PATH. Tuy cả ba nhóm hệ điều hành trên đều dùng biến môi trường này, cách cài đặt sẽ khác nhau một chút.\n  Windows 10   Nhấn tổ hợp phím Windows + R, gõ sysdm.cpl và nhấn Enter Một cửa sổ hiện lên, hãy chọn thẻ Advanced, chọn Environment Variables. Thêm một cửa sổ nữa hiện lên, trong phần System variables, chọn Path và click vào nút Edit Một cửa sổ hiện ra, nhấn New. Một cửa sổ mới hiện ra với một hộp văn bản Lấy đường dẫn cài đặt ở bước 2 ra, thêm \\bin vào đuôi và copy vô cái hộp văn bản đó. Ví dụ mình cài Julia vào E:\\julia, mình sẽ ghi E:\\julia\\bin. Ấn Ok, tắt hết các hộp thoại, giờ bạn đã cài xong Julia.      Windows khác   Nhấn tổ hợp phím Windows + R, gõ sysdm.cpl và nhấn Enter Một cửa sổ hiện lên, hãy chọn thẻ Advanced, chọn Environment Variables. Thêm một cửa sổ nữa hiện lên, trong phần System variables, chọn Path và click vào nút Edit Sau khi nhấn Edit, sẽ có một cửa sổ với 2 hộp văn bản xuất hiện. Click vào hộp văn bản thứ 2 (Variable value:) và di chuyển đến cuối dòng, nếu cuối dòng không có dấu ; hãy thêm dấu ; vào. Lấy đường dẫn cài đặt ở bước 2 ra, thêm \\bin vào đuôi và copy thêm vào cuối của hộp văn bản thứ 2. Ví dụ mình cài Julia vào E:\\julia, mình sẽ ghi thêm E:\\julia\\bin vào cuối. Nhắc lại rất kĩ là ghi thêm nhé, ông nào paste đè lên cái cũ xong hỏng máy tôi không chịu trách nhiệm đâu. Ấn Ok, tắt hết các hộp thoại, giờ bạn đã cài xong Julia.      MacOS   Chạy open -a TextEdit ~/.bash_profile trên Terminal. Nếu bạn dùng zsh thì thay .bash_profile bằng .zshrc (nếu bạn không biết bạn đang dùng cái gì thì đừng để ý đoạn zsh này). Lệnh trên sẽ mở file ~/.bash_profile để bạn chỉnh sửa. Thêm dòng export PATH=\u0026quot;/Applications/Julia-.app/Contents/Resources/julia/bin:${PATH}\u0026quot; vào cuối và save lại.      Linux, BSD, *Nix  Bạn có 3 lựa chọn như dưới đây, sau khi thực hiện một trong ba bạn sẽ có thể sử dụng Julia.\n Thêm thư mục Julia vào biến $PATH bằng cách thêm dòng lệnh mình ghi ở dưới vào trong file ~/.bashrc và ~/.bash_profile. Thay hai file trên với ~/.zshrc nếu bạn dùng zsh. Thay những file trên với /etc/profile, /etc/bash.bashrc hoặc /etc/zsh nếu bạn muốn cài đặt trên toàn hệ thống.  1  export PATH=\u0026#34;$PATH:/đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin\u0026#34;    Chạy lệnh echo $PATH xem biến $PATH của bạn có những thư mục nào, ví dụ mình sẽ chọn /usr/bin. Sau đó, hãy tạo liên kết tới Julia trong thư mục đó bằng lệnh sudo ln -s /đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin/julia /usr/bin/ (mình dùng sudo vì cần quyền ghi vào /usr/bin, nếu người dùng của bạn ghi được vào thư mục trên $PATH thì không cần sudo) Cách cục súc: bạn sẽ chạy /đường/dẫn/tới/\u0026lt;julia dir\u0026gt;/bin/julia mỗi lần bạn dùng đến nó.    Lưu ý thêm cho những bạn dùng Windows   Nếu bạn dùng Windows 7   bản update này sẽ giúp trình quản lý gói của Julia hoạt động. Xuống phần Method 2 và click vào link Microsoft Update Catalog. Windows Management Framework 3.0 hoặc hơn để cài Powershell. Vào trang web trên, kéo xuống dưới cái bảng và click vào phiên bản bạn muốn download.    Nhìn chung, nếu bạn dùng Windows, mình khuyên các bạn nên tìm một terminal khác ngoài cmd và cái đi kèm với Powershell. Một số gợi ý cho các bạn:\n Terminal của Visual Studio Code Git bash  Tổng kết Các bạn có thể cài đặt Julia theo cách mình muốn. Bản cài chính thức cài đặt sẽ dài dòng hơn một chút nhưng đảm bảo hơn, bản cài do cộng đồng phân phối sẽ tiện lợi hơn với một tỉ lệ rất rất nhỏ xảy ra bug. Để kiểm tra việc cài đặt Julia có thành công hay không, hãy mở Terminal và chạy lệnh julia.\n Nếu lệnh chạy thành công, chúng ta sẽ thấy màn hình Julia chào đón mình  \n","description":"Hướng dẫn tải và cài đặt Julia trên máy tính của bạn","id":6,"section":"posts","tags":["julia"],"title":"Julia Dojo: cài đặt Julia","uri":"https://ndgnuh.github.io/julia-dojo/cai-dat-julia/"},{"content":"Julia là gì? Tại sao lại học nó? Julia là một ngôn ngữ lập trình bậc cao dễ sử dụng, nhanh và mạnh mẽ. Một số đặc trưng của Julia cũng như lí do bạn sẽ muốn dùng nó (hoặc không):\n Julia là một ngôn ngữ lập trình hàm Kiểu động (dynamic typing) Julia được biên dịch (compile), tuy nhiên cũng có chế độ thông dịch (intepreter) nếu bạn muốn Julia nhanh Cú pháp rất dễ chịu, những bạn nào quen dùng python hoặc matlab sẽ thấy quen thuộc Cực kì mạnh, thư viện tiêu chuẩn hỗ trợ rất tốt việc tính toán toán học và xử lý song song. Multiple dispatch (cái này có thể khiến bạn cảm giác lạ lạ, nhưng nó đỉnh lắm) Julia miễn phí và mã nguồn mở (giấy phép MIT) Julia hứa hẹn sẽ giải quyết vấn đề hai ngôn ngữ  Khoan, nhiều \u0026ldquo;điểm tốt\u0026rdquo; quá, nghe vô lý. Thằng Python bậc cao nhưng nó chậm như rùa, mọi thư viện đều phải binding và viết với C. Thằng C thì nhanh, nhưng mà để viết được nó thì không phải ông nào cũng làm được. Thằng Matlab thì nhanh và dễ viết thật, nhưng bạn ơi, tiền đâu mà dùng Matlab, ngồi crack thôi chứ còn gì. Hơn nữa, Matlab nếu bạn dùng cho mục đích cá nhân thì crack được, chứ một tổ chức hay cơ quan thì họ sẽ bảo rằng:\n Ở đây chúng tôi không làm vậy\n\u0026ndash; Họ không dùng Matlab ở Wakanda\n Ok, mình vẫn chưa giải thích tại sao có nhiều \u0026ldquo;điểm tốt\u0026rdquo; như vậy. Julia đạt được những điều như trên vì 2 lí do:\n Julia dùng Just Intime Compiler (JIT) Việc biên dịch của Julia cực kì phức tạp, khiến cho mã Julia khi dịch xong có tốc độ so sánh được với C hoặc Fortran   Micro benchmark theo thời gian chạy một số ngôn ngữ, thời gian chạy của C được lấy làm mốc. Các ngôn ngữ khác được so sánh tương đối.   Đương nhiên, Julia cũng có khiếm khuyết, không có cái gì hoàn hảo cả. Và cộng đồng cũng rất cố gắng để cải thiện, xử lý chúng.\n Cộng đồng Julia nhỏ một cách tương đối so với những \u0026ldquo;ông lớn\u0026rdquo; như Python, đặc biệt là cộng đồng người Việt. Mình cho rằng đây là vấn đề thời gian, và vấn đề này cũng là lí do mình ở đây, viết cái đống này cho các bạn :). Mảng trong Julia đánh chỉ số từ 1. Có thể bạn đang nghĩ rằng sẽ dừng đọc và drop cái ngôn ngữ của nợ này ngay tại đây, hãy khoan đã. Theo mình thấy, vấn đề chỉ số này không ảnh hưởng nhiều lắm. Việc đánh chỉ số từ 0 được ông Dijikstra đưa ra và áp dụng trong kha khá ngôn ngữ lập trình, nhưng vẫn có những người dám phản dmg ông và đi theo trường phái khác. Cá nhân mình không có thành kiến gì với cả hai trường phái đâu, mình chỉ muốn nói cả hai đều có thể dùng được. Lí do duy nhất mình đưa cái này vào khuyết điểm vì có thể nó sẽ \u0026ldquo;dọa\u0026rdquo; những người mới.   Tôi không biết bao nhiêu người trong số các ông đã đích thân gặp Dijikstra, nhưng các ông chắc đều biết rằng - sự kiêu ngạo trong tính toán khoa học được đo bằng nano-Dijikstra.\n\u0026ndash; Alan Kay (mình không biết ông này nhưng mà câu nói của ổng làm mình thấy khoái)\n Lần đầu chạy code sẽ lâu hơn một chút. Ví dụ khi mình tạo random 100000 số kiểu double, lần đầu chạy rand(Float64, 100000) sẽ mất khoảng 0.06, những lần tiêp theo thời gian sẽ giảm đi còn 0.002 (nhanh gấp khoảng 30 lần). Có lẽ đây là vấn đề lớn nhất trong Julia. Nếu bạn hiểu JIT là cái gì, bạn sẽ thấy đặc điểm này gần như không thể tránh được. Tuy nhiên, với những người định \u0026ldquo;dùng thử\u0026rdquo; Julia, họ sẽ trải nghiệm thời gian compile và tưởng nó là runtime, sau đó sẽ nghĩ rằng \u0026ldquo;cái này không nhanh như quảng cáo\u0026rdquo;. Điều này ảnh hưởng rất nhiều tới khuyết điểm số 1. Hiện tại, cộng đồng Julia đang rất ưu tiên giải quyết vấn đề này, họ đã tìm cách giảm thời gian compile đáng kể, đồng thời có cách để compile hoàn toàn mã nguồn Julia dưới dạng thư viện liên kết động. Scala là cái tên được ghép từ \u0026ldquo;scalable\u0026rdquo; và \u0026ldquo;language\u0026rdquo;. Swift mang nghĩa chuyển động trơn tru và tốc độ cao. Ruby là một viên đá quý. C++ là C tăng lên 1 level. C là kế tiếp của B. Matlab là viết tắt của Matrix Laboratory, thậm chí trong một ngôn ngữ nào đó, nó có nghĩa là sự thông thái\u0026hellip; Vậy Julia cái tên Julia thì sao, nó có ý nghĩa gì?   Đây là câu hỏi ưa thích của mọi người. Thực ra chả có lí do gì đâu, nghe cái tên nó hay hay.\n\u0026ndash; Stefan Karpinski =))\n Huyên thuyên về Julia đủ rồi. Rất tiếc nếu mình không thuyết phục được bạn. Tuy nhiên, nếu bạn quyết định thử Julia và cho nó một cơ hội, hãy chuyển qua phần tiếp theo và bước vào Julia Dojo.\nJulia Dojo Vậy là bạn quyết định cho Julia một cơ hội, mình sẽ cảm ơn các bạn bằng một series hướng dẫn \u0026amp; thảo luận, mang tên \u0026ldquo;Julia Dojo\u0026rdquo;. Series này sẽ tổng hợp từ rất nhiều nguồn kiến thức, nhưng chủ yếu mình sẽ lấy từ 3 nguồn:\n Tài liệu chính thức Julia Con (một hội thảo được tổ chức hàng năm) Hiểu biết của mình  Với tài liệu chính thức và Julia Con, bạn có thể xem một cách miễn phí trên mạng nếu nếu không ngại tiếng Anh; còn cái nguồn thứ ba, bạn có thể xem nếu bạn quen mình ngoài đời thực và có khả năng ngoại cảm.\nÝ tưởng chính của Julia Dojo là: chúng ta sẽ train từng level một. Với mỗi level chúng ta sẽ đi sâu vào trong hệ thống của Julia hơn và thấy các thứ liên kết với nhau như thế nào. Trang này sẽ là nơi mình update các level của Dojo cùng với nội dung trong đó mỗi khi có bài mới.\nCó những bài viết mình đánh đấu là \u0026ldquo;tùy chọn\u0026rdquo; hoặc \u0026ldquo;nên xem\u0026rdquo;, bạn không nhất thiết phải đọc vì nó không phải một \u0026ldquo;cơ bản\u0026rdquo; của Julia. Mình có để intro ở đầu mỗi bài viết, nếu bạn thấy không hứng thú hoặc phần đó bạn đã biết rồi, bạn có thể skip.\nLayout phía dưới có những phần dự định, có thể khi mình viết bài thực sự mình sẽ thêm bớt hoặc chuyển chỗ một vài thứ trong đó.\n Level 1: nhập môn Những thứ cơ bản nhất\n Tải và cài đặt Julia Hello, world Làm việc với trình quản lí gói Sử dụng Julia với Project Jupyter Biến số Cấu trúc điều khiển Hàm  Level 2: vài đường cơ bản (dự định) Giống Level 1, nhưng kĩ hơn một tí, và giới thiệu các gói mình nghĩ là hay.\n Làm việc với file Tuple, từ điển, tập hợp Struct Chuỗi kí tự, biểu thức chính quy và biểu tượng Đại số tuyến tính Mảng, ma trận Thống kê Vẽ đồ thị DataFrame Gọi các ngôn ngữ khác Đa luồng, đa tiến trình Xử lý ngoại lệ Broadcast  Level 3: thiên biến vạn hóa (dự định) Đa hình và những thứ liên quan tới nó\n Nói thêm về hệ thống kiểu dữ liệu Các loại giao diện Multiple dispatch  Level 5: sáng tạo chiêu thức (dự định) Sẽ có một ngày bạn phải tự viết chương trình của riêng mình\n Tạo một project Unit testing Viết tài liệu  Extra: làm chủ vũ khí (dự định) Công cụ lập trình mà bạn có thể sẽ thích.\n [nên đọc] Jupyter notebook [nên đọc] VSCode [tùy chọn] Atom: Juno / Julia pro [tùy chọn] Vim Emacs (chưa chắc) Một số kĩ thuật để code nhanh hơn Tính toán song song Meta programming  Về các module, gói Vì có rất nhiều module của Julia mang tính chuyên ngành cao, mà trình độ của mình có giới hạn nên mình sẽ không cover hết được(mấy cái mô hình hóa sinh thì chịu rồi, mình dốt hóa). Do đó, nếu các bạn muốn hướng dẫn, giới thiệu một gói nào đó. Các bạn có thể:\n Gửi một đường dẫn cho mình tới blog của các bạn, mình sẽ gắn nó vào đây Gửi cho mình bài viết của các bạn kèm với một số thông về bạn, mình sẽ ghi credit đầy đủ cho các bạn, trừ khi bạn không muốn (nhưng mình vẫn sẽ ghi rõ bài viết do độc giả đóng góp) Dịch trang tài liệu chính thức của gói đó và đóng góp cho họ Không làm gì cả =))  Tạm kết Fun fact: \u0026ldquo;Julia\u0026rdquo; nghe rất giống tên của một phụ nữ trong nhiều nền văn hóa, do đó, dù quy chuẩn của cộng đồng cho rằng Julia không dựa trên tên của ai và ngôn ngữ này không được nhân hóa dưới bất kì hình thức nào, một cơ số người khi nói về ngôn ngữ này vẫn vô thức dùng đại từ \u0026ldquo;cô ấy\u0026rdquo;, trong đó có cả mình :))  Ok, mình nghĩ đến đây là đủ cho bài giới thiệu. Chắc các bạn cũng đoán ra được rằng, mình đang muốn mở rộng cộng đồng người dùng Julia, cụ thể hơn là ở Việt Nam. Một lần nữa, nếu bạn quyết định cho Julia một cơ hội, mình xin cảm ơn. Mình sẽ cố viết post chất lượng và giải đáp thắc mắc của các bạn. Nếu thấy có thiếu sót, đừng ngại gửi lại phản hồi cho mình.\n","description":"","id":7,"section":"posts","tags":["julia"],"title":"Julia Dojo: giới thiệu","uri":"https://ndgnuh.github.io/julia-dojo/"},{"content":"whoami? Xin chào mọi người, mình là Hùng, một open source enthusiast, và là một sinh viên.\nWhat am I doing here? Blog này dự kiến sẽ dùng để chia sẻ kiến thức và bàn chuyện trên trời dưới đất. Cụ thể hơn, mình sẽ chia sẻ hiểu biết của mình (chủ yếu) về Linux, lập trình và có thể là một ít toán nữa.\nHiện tại mình blog chưa được implement tính năng bình luận, tạm thời các bạn đọc nếu có thắc mắc, ý kiến đóng góp hay ném gạch chịu khó gửi một email hay để lại một issue trên Github cho mình.\n Email: ndgnuh@protonmail.com Repo github cho trang này: https://github.com/ndgnuh/ndgnuh.github.io  Blog viết bởi một sinh viên, do tác giả còn rất nhiều thứ phải học nên khả năng cao sẽ gặp sai sót. Nếu bạn đọc phát hiện ra lỗi gì, về kĩ thuật, nội dung, câu cú hay lỗi chính tả ₍•⌣•₎ của trang cứ thoải mái đóng góp ý kiến nhé.  ","description":"","id":8,"section":"","tags":null,"title":"Giới thiệu","uri":"https://ndgnuh.github.io/about/"}]